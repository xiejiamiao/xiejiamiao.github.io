{"meta":{"title":"dimsum","subtitle":"","description":"","author":"Jiamiao.x","url":"http://doc.dimsum.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-27T07:39:01.629Z","updated":"2020-03-27T07:22:15.606Z","comments":false,"path":"/404.html","permalink":"http://doc.dimsum.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-27T07:39:01.605Z","updated":"2020-03-27T07:22:15.608Z","comments":false,"path":"about/index.html","permalink":"http://doc.dimsum.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-03-27T07:39:01.578Z","updated":"2020-03-27T07:22:15.608Z","comments":false,"path":"books/index.html","permalink":"http://doc.dimsum.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-27T07:39:01.549Z","updated":"2020-03-27T07:22:15.609Z","comments":false,"path":"categories/index.html","permalink":"http://doc.dimsum.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-27T07:39:01.501Z","updated":"2020-03-27T07:22:15.609Z","comments":false,"path":"repository/index.html","permalink":"http://doc.dimsum.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-27T07:39:01.476Z","updated":"2020-03-27T07:22:15.610Z","comments":false,"path":"tags/index.html","permalink":"http://doc.dimsum.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-03-27T07:39:01.525Z","updated":"2020-03-27T07:22:15.609Z","comments":true,"path":"links/index.html","permalink":"http://doc.dimsum.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-03-27T07:17:51.807Z","updated":"2020-03-27T07:17:51.807Z","comments":true,"path":"2020/03/27/hello-world/","link":"","permalink":"http://doc.dimsum.com/2020/03/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":".NET Core使用Cap","slug":"dotnet-core-cap","date":"2020-03-26T16:00:00.000Z","updated":"2020-03-28T17:05:59.262Z","comments":true,"path":"2020/03/27/dotnet-core-cap/","link":"","permalink":"http://doc.dimsum.com/2020/03/27/dotnet-core-cap/","excerpt":"","text":"准备工作 项目设定 创建ServiceA 创建ServiceB 准备工作CAP需要依赖消息队列和数据存储，支持情况如下：消息队列 123KafkaRabbitMQAzureServiceBus 数据存储 1234SqlServerMySqlPostgreSqlMongoDB 两者自行搭配选择即可，其中SqlServer和RabbitMQ在docker中的安装可参照我另一篇备忘开发常用的docker镜像 项目设定 两个服务，分别为ServiceA,ServiceB SqlServer使用CapDemo数据库，默认sa账号，密码为Today_is_20200328，端口为默认的1433端口 RabbitMQ安装地址为本机，默认端口，账号密码为admin/admin 创建ServiceA 在Visual Studio 2019中创建空白解决方案，取名为Jiamiao.x.CapDemo 在解决方案中新建Asp.net core项目，名字为Jiamiao.x.CapDemo.ServiceA，.net core版本为3.1 nuget安装以下4个包 1234DotNetCore.CAPDotNetCore.CAP.DashboardDotNetCore.CAP.RabbitMQDotNetCore.CAP.SqlServer 在Startup.cs的ConfigureServices方法中加入以下代码 1234567891011services.AddCap(options =&gt;&#123; options.UseSqlServer(\"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1\"); options.UseRabbitMQ(r =&gt; &#123; r.HostName = \"127.0.0.1\"; r.UserName = \"admin\"; r.Password = \"admin\"; &#125;); options.UseDashboard();&#125;); 此时直接运行项目，如果数据库与消息队列均能正常连接，则会在数据库中生成以下两张表 12cap.Publishedcap.Received 在Controllers/WeatherForecastController.cs中编写消息发布代码 6.1 通过构造函数依赖注入ICapPublisher对象 6.2 发布消息只需要调用ICapPublisher对象的PublishAsync或Publish方法，传入参数为队列名和消息值，全部代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace Jiamiao.x.CapDemo.ServiceA.Controllers&#123; [ApiController] [Route(\"[controller]\")] public class WeatherForecastController : ControllerBase &#123; private static readonly string[] Summaries = new[] &#123; \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\" &#125;; private readonly ILogger&lt;WeatherForecastController&gt; _logger; private readonly ICapPublisher _capPublisher; public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,ICapPublisher capPublisher) &#123; _logger = logger; _capPublisher = capPublisher; &#125; [HttpGet] public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; Get() &#123; await _capPublisher.PublishAsync(\"jiamiao.x.cap.demo.show.time\", DateTime.Now); var rng = new Random(); return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast &#123; Date = DateTime.Now.AddDays(index), TemperatureC = rng.Next(-20, 55), Summary = Summaries[rng.Next(Summaries.Length)] &#125;) .ToArray(); &#125; &#125;&#125; 编写接收消息代码，接收消息有两种方式，一种在控制器中，即代码写在***Controller.cs中，另一种是在非控制器中，一般为***Service.cs中，以下分两步执行，因为CAP在默认情况下一个服务多个地方进行订阅，只会进行一次接收，除非进行分组(后面介绍)，所以8/9两个步骤在测试时需要注释其中一个，只保留另一个 编写在控制器中接收消息的代码，直接在控制器中写对应方法，方法参数为发送消息时传入的消息值类型，方法无返回值，再加上方法标签CapSubscribe即可，具体代码如下: 123456789101112131415161718using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;using Microsoft.AspNetCore.Mvc;namespace Jiamiao.x.CapDemo.ServiceA.Controllers&#123; public class SubController : Controller &#123; [CapSubscribe(\"jiamiao.x.cap.demo.show.time\")] public void ShowTime(DateTime value) &#123; Console.WriteLine($\"接受方：SubController.ShowTime 接收到值：&#123;value&#125;\"); &#125; &#125;&#125; 做到这步可以进行一次测试，就可以发现访问/WeatherForecast这个接口，会发送一条当前时间的消息出去，同时接收方也会在控制台打印出接收到的消息 编写服务中接收消息的代码，需要注意接收消息的类需要继承ICapSubscribe接口，同时这里为了方便进行依赖注入，这里我们也自己定义了一个ISubscriberService接口，同时服务需要在Startup.cs的ConfigureServices方法中进行注册 9.1 ISubscriberService.cs代码如下 123456789101112using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;namespace Jiamiao.x.CapDemo.ServiceA.Services&#123; public interface ISubscriberService &#123; void ReceivedShowTimeMessage(DateTime value); &#125;&#125; 9.2 SubscriberService.cs代码如下 1234567891011121314151617using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;namespace Jiamiao.x.CapDemo.ServiceA.Services&#123; public class SubscriberService: ISubscriberService, ICapSubscribe &#123; [CapSubscribe(\"jiamiao.x.cap.demo.show.time\")] public void ReceivedShowTimeMessage(DateTime value) &#123; Console.WriteLine($\"接受方：SubscriberService.ReceivedShowTimeMessage 接收到值：&#123;value&#125;\"); &#125; &#125;&#125; 9.3 服务注册代码如下 1services.AddScoped&lt;ISubscriberService, SubscriberService&gt;(); 注意：这行服务注册代码需要在services.AddCap这个方法之前注册，否则CAP在进行接口扫描的时候找不到对应已经实现了ICapSubscribe接口的实现类，则无法进行订阅者注册 注释掉第8步，进行第9步的测试，效果应该与第8步一致 有时候一个消息需要多个消费者同时消费，则可以使用Group概念，消息发送代码不变，在标记CapSubscribe的时候，使用Group参数，多个Group订阅同个消息Id，消息则会对应分发到多个Group中，同个Group只能消费一次，即一个Group对一个消息Id订阅多次，也会只接收一次，具体代码如下SubscriberService.cs中新增Group参数1[CapSubscribe(\"jiamiao.x.cap.demo.show.time\",Group = \"SubscriberService\")] SubController.cs中新增Group参数1[CapSubscribe(\"jiamiao.x.cap.demo.show.time\",Group = \"SubController\")] 测试Group功能，将项目跑起来，此时再访问发送消息的api，会在控制台中打印出两条消息接收记录 创建ServiceBServiceB使用EFCore来进行配置，找ServiceA步骤2创建Jiamiao.x.CapDemo.ServiceB项目，因为.Net Core 3.1没有自带EFCore，所以这里除了CAP的4个包之外，还需要nuget安装EFCore的两个包，汇总起来需要nuget安装的包如下： 123456DotNetCore.CAPDotNetCore.CAP.DashboardDotNetCore.CAP.RabbitMQDotNetCore.CAP.SqlServerMicrosoft.EntityFrameworkCoreMicrosoft.EntityFrameworkCore.SqlServer创建ServiceDbContext.cs文件，代码如下 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using Microsoft.EntityFrameworkCore;namespace Jiamiao.x.CapDemo.ServiceB.Infrastructure&#123; public class ServiceDbContext: DbContext &#123; public ServiceDbContext(DbContextOptions&lt;ServiceDbContext&gt; options):base(options) &#123; &#125; &#125;&#125;在Startup.cs中配置EFCore和CAP，具体代码如下： 1234567891011121314151617services.AddDbContext&lt;ServiceDbContext&gt;(options =&gt;&#123; options.UseSqlServer( \"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1\");&#125;);services.AddCap(options =&gt;&#123; options.UseEntityFramework&lt;ServiceDbContext&gt;(); options.UseRabbitMQ(r =&gt; &#123; r.HostName = \"127.0.0.1\"; r.UserName = \"admin\"; r.Password = \"admin\"; &#125;); options.UseDashboard();&#125;);后续操作与ServiceA类似，需要注意：多个站点订阅同个消息Id，消息会往多个站点进行发送 附上CAP的Github地址:https://github.com/dotnetcore/CAP 还有一些配合EF的操作还没来得及写，有空再说吧","categories":[{"name":".NET","slug":"NET","permalink":"http://doc.dimsum.com/categories/NET/"}],"tags":[{"name":".NET Core","slug":"NET-Core","permalink":"http://doc.dimsum.com/tags/NET-Core/"},{"name":"CAP","slug":"CAP","permalink":"http://doc.dimsum.com/tags/CAP/"},{"name":"MicroServices","slug":"MicroServices","permalink":"http://doc.dimsum.com/tags/MicroServices/"}]},{"title":"开发常用的docker镜像","slug":"chang-yong-docker","date":"2020-03-26T16:00:00.000Z","updated":"2020-03-28T16:58:35.771Z","comments":true,"path":"2020/03/27/chang-yong-docker/","link":"","permalink":"http://doc.dimsum.com/2020/03/27/chang-yong-docker/","excerpt":"","text":"Redis Elasticsearch(集群) RabbitMq SqlServer 2017 主要用于开发阶段，不涉及生产环境配置，无权限自行添加sudo Redis 获取镜像1docker pull redis 运行Redis1docker run -p 6379:6379 -d redis:lastes redis-server Elasticsearch(集群) 说明： 这里这里使用的是Elasticsearch 7.3.0版本 集群一共有3个Container，一个Master，两个Slave 配置文件中的192.168.2.58为对应节点的IP地址 具体配置:12345678910111213141516Elasticsearch集群 |------ Master |--- 端口：9500 |--- TCP端口：9300 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data |------ Slave1 |--- 端口：9600 |--- TCP端口：9301 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data |------ Slave2 |--- 端口：9700 |--- TCP端口：9302 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data 获取镜像1docker pull elasticsearch:7.3.0 在宿主机创建各个节点的elasticsearch.yml配置文件，具体内容如下: Master节点，配置文件路径：~/var/elasticsearch/config/master/elasticsearch.yml12345678910111213141516171819# 设置支持Elasticsearch-Headhttp.cors.enabled: truehttp.cors.allow-origin: \"*\"# 设置集群Master配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: master# 节点是否为Master，设置为true的话，说明此节点为Master节点node.master: true# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9500# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9300# 手动指定可以成为Master的所有节点的Name或者IP，这些配置将会在第一次选举中进行计算cluster.initial_master_nodes: [\"master\"]# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9301\", \"192.168.2.58:9302\"] Slave1节点，配置文件路径：~/var/elasticsearch/config/slave1/elasticsearch.yml1234567891011121314# 设置集群Slave配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: slave1# 节点是否为Master，设置为true的话，说明此节点为master节点node.master: false# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9600# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9301# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9300\", \"192.168.2.58:9302\"] Slave2节点，配置文件路径：~/var/elasticsearch/config/slave2/elasticsearch.yml1234567891011121314# 设置集群Slave配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: slave2# 节点是否为Master，设置为true的话，说明此节点为master节点node.master: false# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9700# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9302# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9300\", \"192.168.2.58:9301\"] 创建3个节点的data文件夹 123~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data 运行节点 运行Master节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/master/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/master/data:/usr/share/elasticsearch/data --name esMaster -p 9500:9500 -p 9300:9300 elasticsearch:7.3.0 运行Slave1节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/slave1/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave1/data:/usr/share/elasticsearch/data --name esSlave1 -p 9600:9600 -p 9301:9301 elasticsearch:7.3.0 运行Slave2节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/slave2/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave2/data:/usr/share/elasticsearch/data --name esSlave2 -p 9700:9700 -p 9302:9302 elasticsearch:7.3.0 检查运行状态 运行docker ps查看正在运行的Container，确保以上3个容器正常运行 访问http://127.0.0.1:9500/_cat/nodes?v查看是否有3个节点信息，如果节点运行正常，应该有如下信息1234ip heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name172.17.0.2 32 96 70 3.03 0.82 0.28 di - slave1172.17.0.3 30 96 70 3.03 0.82 0.28 di - slave2172.17.0.4 33 96 70 3.03 0.82 0.28 dim * master 安装Elasticsearch-Head1docker run -d --name es-head -p 9100:9100 mobz/elasticsearch-head:5 运行成功后浏览器访问链接:http://127.0.0.1:9100，将里面的连接地址修改为:http://localhost:9500，保存即可看到3个节点的集群信息 安装IK分词软件 这部分操作3个节点均需要操作一边 ElasticSearch版本为7.3.0，对应IK分词版本为7.3,下载链接IK分词 具体操作就是将下载下来的包放在各个节点的共享卷里，然后进入ES容器内命令行，解压并将文件拷贝到plugins文件夹中，重启容器 RabbitMq 获取镜像1docker pull rabbitmq:management 运行镜像，设置用户名密码(admin/admin)1docker run -dit --name Myrabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:managemen 进入管理界面 http://localhost:15672 SqlServer 2017 获取镜像1docker pull mcr.microsoft.com/mssql/server:2017-latest 运行镜像，设置SA密码为Today_is_202003281docker run -e \"ACCEPT_EULA=Y\" -e \"SA_PASSWORD=Today_is_20200328\" -p 1433:1433 --name mssql -d mcr.microsoft.com/mssql/server:2017-latest","categories":[{"name":"Docker","slug":"Docker","permalink":"http://doc.dimsum.com/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://doc.dimsum.com/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://doc.dimsum.com/tags/elasticsearch/"}]}],"categories":[{"name":".NET","slug":"NET","permalink":"http://doc.dimsum.com/categories/NET/"},{"name":"Docker","slug":"Docker","permalink":"http://doc.dimsum.com/categories/Docker/"}],"tags":[{"name":".NET Core","slug":"NET-Core","permalink":"http://doc.dimsum.com/tags/NET-Core/"},{"name":"CAP","slug":"CAP","permalink":"http://doc.dimsum.com/tags/CAP/"},{"name":"MicroServices","slug":"MicroServices","permalink":"http://doc.dimsum.com/tags/MicroServices/"},{"name":"docker","slug":"docker","permalink":"http://doc.dimsum.com/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://doc.dimsum.com/tags/elasticsearch/"}]}