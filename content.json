{"meta":{"title":"dimsum","subtitle":"","description":"","author":"Jiamiao.x","url":"http://www.dimsum.fun","root":"/"},"pages":[{"title":"分类","date":"2020-03-27T07:39:01.549Z","updated":"2020-03-27T07:22:15.609Z","comments":false,"path":"categories/index.html","permalink":"http://www.dimsum.fun/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-03-27T07:39:01.578Z","updated":"2020-03-27T07:22:15.608Z","comments":false,"path":"books/index.html","permalink":"http://www.dimsum.fun/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-27T07:39:01.605Z","updated":"2020-03-27T07:22:15.608Z","comments":false,"path":"about/index.html","permalink":"http://www.dimsum.fun/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2020-03-27T07:39:01.501Z","updated":"2020-03-27T07:22:15.609Z","comments":false,"path":"repository/index.html","permalink":"http://www.dimsum.fun/repository/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2020-03-27T07:39:01.629Z","updated":"2020-03-27T07:22:15.606Z","comments":false,"path":"/404.html","permalink":"http://www.dimsum.fun/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-03-27T07:39:01.525Z","updated":"2020-03-27T07:22:15.609Z","comments":true,"path":"links/index.html","permalink":"http://www.dimsum.fun/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-27T07:39:01.476Z","updated":"2020-03-27T07:22:15.610Z","comments":false,"path":"tags/index.html","permalink":"http://www.dimsum.fun/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"gRPC in ASP.NET Core","slug":"22.gRPC_document","date":"2020-04-20T10:30:00.000Z","updated":"2020-04-22T16:39:50.247Z","comments":true,"path":"2020/04/20/22.gRPC_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/20/22.gRPC_document/","excerpt":"","text":"开发环境 VSCode 消息类型的演进 更新消息类型的规则 默认值 枚举 在.NET Core中使用gRPC ASP.NET Core .NET Core 引包之后的操作 作为服务端 作为客户端 上代码 服务端 创建目录 编写proto 编写测试数据 编写Service 修改Startup 运行项目 客户端 创建项目 复制proto文件 修改Program.cs 运行项目 未完 开发环境VSCodewindow下需要安装Clang，百度找Clang，去官网自行下载，如果下载速度慢，可以添加以下内容到C:\\Windows\\System32\\drivers\\etc\\host文件 12354.231.82.146 vagrantcloud-files-production.s3.amazonaws.com219.76.4.4 s3.amazonaws.com219.76.4.4 github-cloud.s3.amazonaws.com 然后再VSCode中安装两个插件 12vscode-proto3Clang-Format 消息类型的演进 向前兼容变更：使用新的.proto文件来写数据 – 从旧的.proto文件读取数据 向后兼容变更：使用旧的.proto文件来写数据 – 从新的.proto文件读取数据更新消息类型的规则 不要修改任何现有字段的数字(tag) 可以添加新的字段，旧的代码会忽略掉新字段的解析，所以要注意新字段的默认值 字段可以被删除，只要它们的数字(tag)在更新后的消息类型中不再使用即可，也可以把字段名使用OBSOLETE_前缀而不是删除字段，或者把这些字段的数字(tag)进行保留(reserved)，以免未来其他开发者不小心使用这些字段 尽量不要修改原有的字符数据类型默认值默认值在更新Protocol Buffer消息定义的时候有很重要的作用，它可以防止对现有代码/新代码造成破坏性影响。它们也可以保证字段永远不会有null值 但是，默认值还是非常危险的：你无法区分这个默认值到底是来自一个丢失的字段还是字段的实际值正好等于默认值 所以，需要保证这个默认值对于业务来说是一个毫无意义的值，例如int32 pop人口这个字段的默认值可以设置为-1，再就是可能需要再代码里对默认值进行判断处理 枚举enum同样可以进化，就和消息的字段一样，可以添加、删除值，也可以保留值 但是如果代码不知道它接收到的值对应哪个enum值，那么enum的默认值将会被采用 在.NET Core中使用gRPCASP.NET Core依赖包： 1Grpc.AspNetCore .NET Core依赖包： 123Google.ProtobufGrpc.Net.ClientGrpc.Tools 引包之后的操作按照项目类型引入上面的包之后，直接编译是不会得到gRPC框架生成的代码，需要做以下操作：右键.proto文件 -&gt; 属性 -&gt; 将Build Action选择为Protobuf compiler -&gt; gRPC Stub Classes按照需求选择Client and Server/Client only/Server only/Do not generate 进行完上面的操作之后，编译项目会在obj\\Debug\\netcoreapp3.1目录里自动生成RPC代码 作为服务端怎么实现rpc定义的方法：假设在.proto文件里有EmployeeService这样一个service，在编译项目之后，会有一个EmployeeService.EmployeeServiceBase的类，自己编写一个类继承自EmployeeService.EmployeeServiceBase这个类，然后override去重载.proto服务里定义的那些rpc方法即可 作为客户端怎么调用rpc定义的方法：需要先创建Channel，例如： 1using var channel = GrpcChannel.ForAddress(\"https://localhost:5001\"); 然后假设在.proto文件里有EmployeeService这样一个service，在编译项目之后(需要选择client或client and server)，会有一个EmployeeService.EmployeeServiceClient的类，实例化这个类就相当实例化一个client，例如： 1var client = new EmployeeService.EmployeeServiceClient(channel); 在client里就可以调用.proto服务里定义的那些方法 上代码服务端创建名字为RoutingDemo的ASP.NET Core项目，类型为空，通过nuget引入： 1Grpc.AspNetCore 创建目录在项目根目录创建以下三个文件夹 123DataProtosServices 编写proto在Protos文件夹中添加文件Order.proto，具体内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051syntax &#x3D; &quot;proto3&quot;;option csharp_namespace &#x3D; &quot;GrpcDemo.Protos&quot;;message Order&#123; int32 Id &#x3D; 1; string OrderNo &#x3D; 2; int32 Status &#x3D; 3; float Payment &#x3D; 4; repeated OrderProduct Products &#x3D; 5; OrderAddress Address &#x3D; 6; int32 OrderOwner &#x3D; 7; message OrderProduct&#123; string ProductTitle &#x3D; 1; string SkuTitle &#x3D; 2; int32 Num &#x3D; 3; float UnitPrice &#x3D; 4; &#125; message OrderAddress&#123; string Province &#x3D; 1; string City &#x3D; 2; string Districe &#x3D; 3; string Detail &#x3D; 4; string Name &#x3D; 5; string Mobile &#x3D; 6; &#125;&#125;message GetByOrderNoRequest&#123; string OrderNo &#x3D; 1;&#125;message GetByOwnerRequest&#123; int32 OrderOwner &#x3D; 1;&#125;message BatchAddOrderNoReturnResponse&#123; bool IsAllSuccess &#x3D; 1; repeated string FailOrderNo &#x3D; 2;&#125;service OrderService&#123; rpc GetByOrderNo(GetByOrderNoRequest) returns(Order); rpc GetByOwner(GetByOwnerRequest) returns(stream Order); rpc AddOrder(Order) returns(Order); rpc BatchAddOrder(stream Order) returns(stream Order); rpc BatchAddOrderNoReturn(stream Order) returns(BatchAddOrderNoReturnResponse);&#125; 在解决方案资源管理器找到Order.proto文件，右键 -&gt; 属性 -&gt; Build Action选择Protobuf compiler -&gt; gRPC Stub Classes选择Server only 编译一次项目 编写测试数据在Data文件夹创建InMemoryData.cs文件，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using System.Collections.Generic;using GrpcDemo.Protos;namespace GrpcServerDemo.Data&#123; public class InMemoryData &#123; public static List&lt;Order&gt; Orders = new List&lt;Order&gt;() &#123; new Order() &#123; Id = 1, OrderNo = \"2020042201\", Status = 1, Payment = 43141.98f, Products = &#123; new Order.Types.OrderProduct() &#123; ProductTitle = \"Apple iPhone11\", SkuTitle = \"256GB 黑色\", Num = 2, UnitPrice = 9999.99f &#125;, new Order.Types.OrderProduct() &#123; ProductTitle = \"Apple MacBook Pro\", SkuTitle = \"i7 512GB 灰色\", Num = 1, UnitPrice = 23142 &#125; &#125;, Address = new Order.Types.OrderAddress() &#123; Province = \"广东省\", City = \"深圳市\", Districe = \"南山区\", Detail = \"Nanshan Road 1234\", Name = \"Jiamiao.x\", Mobile = \"13500000000\" &#125;, OrderOwner = 100, &#125;, new Order() &#123; Id = 2, OrderNo = \"2020042202\", Status = 2, Payment = 56.00f, Products = &#123; new Order.Types.OrderProduct() &#123; ProductTitle = \"ASP.NET Core微服务实战\", SkuTitle = \"1本\", Num = 1, UnitPrice = 56.00f &#125; &#125;, Address = new Order.Types.OrderAddress() &#123; Province = \"广东省\", City = \"深圳市\", Districe = \"南山区\", Detail = \"Nanshan Road 1234\", Name = \"Jiamiao.x\", Mobile = \"13500000000\" &#125;, OrderOwner = 100 &#125; &#125;; &#125;&#125; 注意：这里的Order是gRPC生成的，命名空间为GrpcDemo.Protos 编写Service在Services文件夹创建DemoOrderService.cs文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081using System;using System.Linq;using System.Threading;using System.Threading.Tasks;using Grpc.Core;using GrpcDemo.Protos;using GrpcServerDemo.Data;using Microsoft.Extensions.Logging;namespace GrpcServerDemo.Services&#123; public class DemoOrderService : OrderService.OrderServiceBase &#123; private readonly ILogger&lt;DemoOrderService&gt; _logger; public DemoOrderService(ILogger&lt;DemoOrderService&gt; logger) &#123; _logger = logger; &#125; public override async Task&lt;Order&gt; GetByOrderNo(GetByOrderNoRequest request, ServerCallContext context) &#123; _logger.LogInformation(\"有人请求接口 -&gt; GetByOrderNo\"); var metaData = context.RequestHeaders; foreach (var item in metaData) &#123; _logger.LogInformation($\"&#123;item.Key&#125;: &#123;item.Value&#125;\"); &#125; await Task.CompletedTask; var dbValue = InMemoryData.Orders.FirstOrDefault(x =&gt; x.OrderNo == request.OrderNo); if (dbValue != null) &#123; return dbValue; &#125; else &#123; throw new Exception(\"订单号错误\"); &#125; &#125; public override async Task GetByOwner(GetByOwnerRequest request, IServerStreamWriter&lt;Order&gt; responseStream, ServerCallContext context) &#123; _logger.LogInformation(\"有人请求接口 -&gt; GetByOwner\"); var dbValue = InMemoryData.Orders.Where(x =&gt; x.OrderOwner == request.OrderOwner); foreach (var item in dbValue) &#123; Thread.Sleep(2000); _logger.LogInformation($\"发送数据：&#123;item&#125;\"); await responseStream.WriteAsync(item); &#125; &#125; public override async Task&lt;Order&gt; AddOrder(Order request, ServerCallContext context) &#123; _logger.LogInformation(\"有人请求接口 -&gt; AddOrder\"); await Task.CompletedTask; request.Id = InMemoryData.Orders.Max(x =&gt; x.Id) + 1; InMemoryData.Orders.Add(request); return request; &#125; public override async Task BatchAddOrder(IAsyncStreamReader&lt;Order&gt; requestStream, IServerStreamWriter&lt;Order&gt; responseStream, ServerCallContext context) &#123; _logger.LogInformation(\"有人请求接口 -&gt; BatchAddOrder\"); while (await requestStream.MoveNext()) &#123; var inputOrder = requestStream.Current; lock (this) &#123; _logger.LogInformation($\"接受数据：&#123;inputOrder&#125;\"); inputOrder.Id = InMemoryData.Orders.Max(x =&gt; x.Id) + 1; InMemoryData.Orders.Add(inputOrder); &#125; await responseStream.WriteAsync(inputOrder); Thread.Sleep(5000); &#125; &#125; &#125;&#125; 注意：这里的OrderService.OrderServiceBase一样是gRPC生成的，命名空间为GrpcDemo.Protos 修改Startup修改Startup.cs，内容如下： 1234567891011121314151617181920212223242526272829303132using GrpcServerDemo.Services;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace GrpcServerDemo&#123; public class Startup &#123; public void ConfigureServices(IServiceCollection services) &#123; services.AddGrpc(); &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapGrpcService&lt;DemoOrderService&gt;(); &#125;); &#125; &#125;&#125; 运行项目在Powershell中进入到项目根目录，直接dotnet run运行目录即可 客户端创建项目创建名字为GrpcClientDemo的控制台应用，通过nuget引入以下三个包： 123Google.ProtobufGrpc.Net.ClientGrpc.Tools 复制proto文件将服务端GrpcServerDemo的Protos文件夹拷贝到项目根目录，在解决方案资源管理器找到Order.proto文件，右键 -&gt; 属性 -&gt; Build Action选择Protobuf compiler -&gt; gRPC Stub Classes选择Client only 修改Program.cs修改Program.cs文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174using System;using System.Collections.Generic;using System.Threading.Tasks;using Grpc.Core;using Grpc.Net.Client;using GrpcDemo.Protos;namespace GrpcClientDemo&#123; class Program &#123; static async Task Main(string[] args) &#123; using var channel = GrpcChannel.ForAddress(\"https://localhost:5001\"); var client = new OrderService.OrderServiceClient(channel); var option = int.Parse(args[0]); switch (option) &#123; case 0: await GetByOrderNoAsync(client); break; case 1: await GetByOwner(client); break; case 2: await AddOrder(client); break; case 3: await BatchAddOrder(client); break; &#125; Console.WriteLine(\"==========END==========\"); &#125; public static async Task GetByOrderNoAsync(OrderService.OrderServiceClient client) &#123; var metaData = new Metadata() &#123; &#123;\"userName\", \"jiamiao.x\"&#125;, &#123;\"clientName\", \"GrpcClientDemo\"&#125; &#125;; var response = await client.GetByOrderNoAsync(new GetByOrderNoRequest() &#123;OrderNo = \"2020042201\"&#125;,metaData); Console.WriteLine($\"接收到数据：&#123;response&#125;\"); &#125; public static async Task GetByOwner(OrderService.OrderServiceClient client) &#123; var response = client.GetByOwner(new GetByOwnerRequest() &#123;OrderOwner = 100&#125;); var responseStream = response.ResponseStream; while (await responseStream.MoveNext()) &#123; Console.WriteLine($\"接收到数据：&#123;responseStream.Current&#125;\"); &#125; Console.WriteLine($\"数据接收完毕\"); &#125; public static async Task AddOrder(OrderService.OrderServiceClient client) &#123; var order = new Order() &#123; OrderNo = \"2020042301\", Status = 1, Payment = 43141.98f, Products = &#123; new Order.Types.OrderProduct() &#123; ProductTitle = \"OnePlus 7T\", SkuTitle = \"256GB 蓝色\", Num = 1, UnitPrice = 3600f &#125; &#125;, Address = new Order.Types.OrderAddress() &#123; Province = \"广东省\", City = \"深圳市\", Districe = \"南山区\", Detail = \"北科大厦7003\", Name = \"Jiamiao.x\", Mobile = \"13822113366\" &#125;, OrderOwner = 100, &#125;; var response = await client.AddOrderAsync(order); Console.WriteLine($\"接收到数据：&#123;response&#125;\"); &#125; public static async Task BatchAddOrder(OrderService.OrderServiceClient client) &#123; var orders = new List&lt;Order&gt;() &#123; new Order() &#123; OrderNo = \"2020042301\", Status = 1, Payment = 3600f, Products = &#123; new Order.Types.OrderProduct() &#123; ProductTitle = \"OnePlus 7T\", SkuTitle = \"256GB 蓝色\", Num = 1, UnitPrice = 3600f &#125; &#125;, Address = new Order.Types.OrderAddress() &#123; Province = \"广东省\", City = \"深圳市\", Districe = \"南山区\", Detail = \"北科大厦7003\", Name = \"Jiamiao.x\", Mobile = \"13822113366\" &#125;, OrderOwner = 100, &#125;, new Order() &#123; OrderNo = \"2020042302\", Status = 1, Payment = 13999.99f, Products = &#123; new Order.Types.OrderProduct() &#123; ProductTitle = \"SONY PS4 Pro\", SkuTitle = \"1TB 黑色\", Num = 1, UnitPrice = 3999.99f &#125;, new Order.Types.OrderProduct() &#123; ProductTitle = \"Surface Desktop Pro\", SkuTitle = \"1TB 白色\", Num = 1, UnitPrice = 13999.99f &#125; &#125;, Address = new Order.Types.OrderAddress() &#123; Province = \"广东省\", City = \"深圳市\", Districe = \"南山区\", Detail = \"北科大厦7003\", Name = \"Jiamiao.x\", Mobile = \"13822113366\" &#125;, OrderOwner = 100, &#125; &#125;; var call = client.BatchAddOrder(); foreach (var order in orders) &#123; await call.RequestStream.WriteAsync(order); &#125; await call.RequestStream.CompleteAsync(); Console.WriteLine(\"----数据发送完毕----\"); await Task.Run(async () =&gt; &#123; while (await call.ResponseStream.MoveNext()) &#123; Console.WriteLine($\"接收到消息：&#123;call.ResponseStream.Current&#125;\"); &#125; &#125;); &#125; &#125;&#125; 运行项目在Powershell进入到项目根目录，使用dotnet run [arg]运行项目既可以看到效果，[arg]是对应switch里的参数 未完","categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/categories/ASP-NET-Core/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"gRPC","slug":"gRPC","permalink":"http://www.dimsum.fun/tags/gRPC/"}]},{"title":"MediatR：轻松实现命令查询职责分离模式(CQRS)","slug":"21.MediatR_document","date":"2020-04-15T07:00:00.000Z","updated":"2020-04-15T15:49:20.106Z","comments":true,"path":"2020/04/15/21.MediatR_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/15/21.MediatR_document/","excerpt":"","text":"一对一 核心对象 代码展示 创建命令和处理者存放路径 创建命令 创建命令处理者 发送命令 运行代码 一对多 核心对象 代码实现 创建事件和事件处理者存放路径 创建事件 创建事件处理者 修改Program 运行代码 一对一核心对象 IMediator IRequest 、IRequest&lt;T&gt; IResuestHandler&lt;in TRequest,TResponse&gt; 代码展示创建名字为MediatorDemo的控制台应用，通过nuget引入以下三个包： 123MediatRMediatR.Extensions.Microsoft.DependencyInjectionMicrosoft.Extensions.DependencyInjection 创建命令和处理者存放路径在根目录创建以下两个文件夹： 12CommandsCommandHandlers 创建命令在Commands文件夹中创建MyCommand.cs，内容如下 1234567891011121314using MediatR;namespace MediatorDemo.Commands&#123; public class MyDemoCommand:IRequest&lt;string&gt; &#123; public string Data &#123; get; &#125; public MyDemoCommand(string data) &#123; Data = data; &#125; &#125;&#125; 创建命令处理者在CommandHandlers文件夹中创建MyDemoCommandHandler.cs，内容如下： 12345678910111213141516using System.Threading;using System.Threading.Tasks;using MediatorDemo.Commands;using MediatR;namespace MediatorDemo.CommandHandlers&#123; public class MyDemoCommandHandler:IRequestHandler&lt;MyDemoCommand,string&gt; &#123; public async Task&lt;string&gt; Handle(MyDemoCommand request, CancellationToken cancellationToken) &#123; await Task.CompletedTask; return $\"Hello from MyDemoCommandHandler.Handler -&gt; command data = &#123;request.Data&#125;\"; &#125; &#125;&#125; 发送命令修改Program.cs，具体内容如下： 1234567891011121314151617181920212223using System;using System.Threading.Tasks;using MediatorDemo.CommandHandlers;using MediatR;using Microsoft.Extensions.DependencyInjection;namespace MediatorDemo&#123; class Program &#123; static async Task Main(string[] args) &#123; var service = new ServiceCollection(); service.AddMediatR(typeof(Program).Assembly); var serviceProvider = service.BuildServiceProvider(); var mediator = serviceProvider.GetService&lt;IMediator&gt;(); var rsp = await mediator.Send(new MyDemoCommand(\"This is my demo command\")); Console.WriteLine(rsp); &#125; &#125;&#125; 解释代码： 通过var service = new ServiceCollection();创建服务容器 service.AddMediatR(typeof(Program).Assembly);是想服务容器注册MediatR组件，同时指定MediatR扫描当前Program所在的程序集，获得当前程序集里的所有Command和Handler(通过接口约束) var mediator = serviceProvider.GetService&lt;IMediator&gt;();从服务容器中获取mediator对象 var rsp = await mediator.Send(new MyDemoCommand(&quot;This is my demo command&quot;));发送一条MyDemoCommand命令 运行代码运行代码之后可以看到控制台打印以下信息： 1Hello from MyDemoCommandHandler.Handler -&gt; command data &#x3D; This is my demo command 可以看到Program并没有直接去引用MyDemoCommandHandler这个类，只是向MediatR发送了一条指定的命令，MediatR框架会自动去查找该命令对应的Handler，调用Handler里的Handle方法 注意：所谓一对一就是当你有对一个命令有多个Handler的时候，MediatR只会找到最后注册的那个来执行 一对多核心对象 IMediator INotification INotificationHandler&lt;in TNotification&gt; 代码实现创建事件和事件处理者存放路径在根目录创建以下两个文件夹： 12EventsEventHandlers 创建事件在Events文件夹中创建MyDemoEvent.cs，内容如下： 1234567891011121314using MediatR;namespace MediatorDemo.Events&#123; public class MyDemoEvent:INotification &#123; public string EventName &#123; get; &#125; public MyDemoEvent(string eventName) &#123; EventName = eventName; &#125; &#125;&#125; 创建事件处理者在EventHandlers文件夹中创建MyDemoEventHandler.cs，内容如下： 1234567891011121314151617181920212223242526using System;using System.Threading;using System.Threading.Tasks;using MediatorDemo.Events;using MediatR;namespace MediatorDemo.EventHandlers&#123; public class MyDemoEventHandler:INotificationHandler&lt;MyDemoEvent&gt; &#123; public async Task Handle(MyDemoEvent notification, CancellationToken cancellationToken) &#123; await Task.CompletedTask; Console.WriteLine($\"MyDemoEventHandler.Handle执行:&#123;notification.EventName&#125;\"); &#125; &#125; public class MyDemoEventHandlerV2 : INotificationHandler&lt;MyDemoEvent&gt; &#123; public async Task Handle(MyDemoEvent notification, CancellationToken cancellationToken) &#123; await Task.CompletedTask; Console.WriteLine($\"MyDemoEventHandlerV2.Handle执行:&#123;notification.EventName&#125;\"); &#125; &#125;&#125; 这里是一个cs文件中写了两个Handler 修改Program在原有的Main方法最后面添加以下代码： 1await mediator.Publish(new MyDemoEvent(\"MyEvent\")); 运行代码运行项目可以看到以下信息： 123Hello from MyDemoCommandHandler.Handler -&gt; command data &#x3D; This is my demo commandMyDemoEventHandler.Handle执行:MyEventMyDemoEventHandlerV2.Handle执行:MyEvent 其中后面两行分别为两个事件处理者打印出来的","categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/categories/ASP-NET-Core/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"DDD","slug":"DDD","permalink":"http://www.dimsum.fun/tags/DDD/"},{"name":"CQRS","slug":"CQRS","permalink":"http://www.dimsum.fun/tags/CQRS/"},{"name":"MediatR","slug":"MediatR","permalink":"http://www.dimsum.fun/tags/MediatR/"}]},{"title":"EntityFramework Core的并发处理","slug":"20.EFCore_Concurrency_document","date":"2020-04-10T08:21:00.000Z","updated":"2020-04-10T10:31:51.922Z","comments":true,"path":"2020/04/10/20.EFCore_Concurrency_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/10/20.EFCore_Concurrency_document/","excerpt":"","text":"什么叫并发 怎么解决 EFCore是怎么做的 Talk is cheap. Show me the code 创建项目 创建数据库实体 配置实体映射规则(这里指定锁) 创建DbContext 修改Startup 添加数据库连接字符串 添加测试控制器 迁移数据库 测试 官方文档 什么叫并发假设一个场景： 用户下了一个单，数据库的Order表存放这个订单数据，其中订单状态=待发货 仓库从数据库中查询出这个代发货订单，进行发货逻辑处理，比如： 判断订单状态 判断地址是否能到达 查询商品库存 获取快递单号 调用打印快递单服务 更新订单状态/商品库存等等 可以看出做发货逻辑处理耗时会比较长，正在这时候，顾客进行了退货申请，一个按钮点击申请退款，注意：业务逻辑要求已发货的订单不能申请退款，但是在顾客点击申请退款那一瞬间，发货流程还没走完，发货系统还在屁颠屁颠的处理发货逻辑，数据库里的订单状态还是待发货，这时候顾客申请退款，接口一下数据库，发现是待发货，就直接将数据库里的订单状态更新为申请退款，并反馈给用户操作成功 这时候苦逼的发货系统终于把所有发货逻辑全部计算完，兴高采烈得将数据库里得订单状态修改为已发货 那么请问，最终这个订单的状态应该是什么呢？待发货？申请退款？已发货？ 上面那个场景就是所谓的并发，多个地方在对同一条数据进行操作的时候，时常会出现这种情况 怎么解决锁！ 悲观锁：是的，相当悲观，对整个世界都不信任的那种！就是假设我读取的数据一定会被修改，所以读数据之前我先把这些数据锁起来，外界拿不到，等我对数据操作完，再把锁释放掉，外界才可以继续用这些数据； 乐观锁：相对来说乐观一些，读取数据的时候不对数据上锁，相信没人会来修改这些数据，但是在处理完数据要重新更新数据库的时候，不能盲目信任，要查一下这些数据有没有发生变化，如果变化了，则说明被别人修改了，于是悲伤的抛出个异常表示对这个世界的不满，如果没有变化，则正常的将数据更新进去； EFCore是怎么做的EFCore使用的是乐观锁，它选择相信这个世界！ EFCore的乐观锁分两种粒度：ConcurrencyToken和RowVersion ConcurrencyToken：这个针对表中的某个字段，为表中的某个字段指定为ConcurrencyToken，则当这个字段被并发修改了，则无法进行SaveChange，如果不是这个字段，而是这一行的其他字段被修改了，则可以正常进行SaveChange。以上面订单例子为例，如果将订单状态这个字段设置为ConcurrencyToken，那个在顾客申请退款之后，发货系统去更新订单状态则会失败，但是如果这个时候不是更新订单状态这个字段，而是更新发货员这个字段，则不会有任何影响，照样可以更新进去 RowVersion：这个针对表中的所有字段，指定表中某个字段为RowVersion，每一次更新都会修改RowVersion这个字段的值，在取出数据重新更新的时候，会查询RowVersion这个字段的值是否与刚刚取出来的值一致，如果不一致说明这个表中可能某个或多个字段被修改过，则无法进行SaveChange Talk is cheap. Show me the code创建项目创建名字为EFCoreConcurrencyDemo的ASP.NET Core项目，类型为API，这里使用的是Sql Server数据库，所有需要引入以下3个包： 123Microsoft.EntityFrameworkCore.SqlServerMicrosoft.EntityFrameworkCore.DesignMicrosoft.EntityFrameworkCore.Tools 创建数据库实体在项目根目录创建以下路径和文件： 123456|--EFCoreConcurrencyDemo |-- DbModel |-- ConcurrencyCheckDemo |-- ConcurrencyCheckDemo.cs |-- RowVersionDemo |-- RowVersionDemo.cs ConcurrencyCheckDemo.cs的内容如下： 1234567891011namespace EFCoreConcurrencyDemo.DbModel.ConcurrencyCheckDemo&#123; public class ConcurrencyCheckDemo &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; &#125;&#125; RowVersionDemo.cs的内容如下： 12345678910111213namespace EFCoreConcurrencyDemo.DbModel.RowVersionDemo&#123; public class RowVersionDemo &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public byte[] RowVersion &#123; get; set; &#125; &#125;&#125; 配置实体映射规则(这里指定锁)在项目根目录创建以下路径和文件 1234|--EFCoreConcurrencyDemo |-- DbModelConfiguration |-- ConcurrencyCheckDemoConfiguration.cs |-- RowVersionDemoConfiguration.cs ConcurrencyCheckDemoConfiguration.cs的内容如下： 123456789101112131415using EFCoreConcurrencyDemo.DbModel.ConcurrencyCheckDemo;using Microsoft.EntityFrameworkCore;using Microsoft.EntityFrameworkCore.Metadata.Builders;namespace EFCoreConcurrencyDemo.DbModelConfiguration&#123; public class ConcurrencyCheckDemoConfiguration : IEntityTypeConfiguration&lt;ConcurrencyCheckDemo&gt; &#123; public void Configure(EntityTypeBuilder&lt;ConcurrencyCheckDemo&gt; builder) &#123; builder.ToTable(\"ConcurrencyCheckDemo\"); builder.Property(x =&gt; x.Name).IsConcurrencyToken(); //并发令牌 &#125; &#125;&#125; RowVersionDemoConfiguration.cs的内容如下： 123456789101112131415using EFCoreConcurrencyDemo.DbModel.RowVersionDemo;using Microsoft.EntityFrameworkCore;using Microsoft.EntityFrameworkCore.Metadata.Builders;namespace EFCoreConcurrencyDemo.DbModelConfiguration&#123; public class RowVersionDemoConfiguration: IEntityTypeConfiguration&lt;RowVersionDemo&gt; &#123; public void Configure(EntityTypeBuilder&lt;RowVersionDemo&gt; builder) &#123; builder.ToTable(\"RowVersionDemo\"); builder.Property(x =&gt; x.RowVersion).IsRowVersion(); //行版本 &#125; &#125;&#125; 创建DbContext在项目根目录创建以下路径和文件 123|--EFCoreConcurrencyDemo |-- DbContext |-- MyDbContext.cs MyDbContext.cs的内容如下： 123456789101112131415161718192021222324using EFCoreConcurrencyDemo.DbModel.ConcurrencyCheckDemo;using EFCoreConcurrencyDemo.DbModel.RowVersionDemo;using EFCoreConcurrencyDemo.DbModelConfiguration;using Microsoft.EntityFrameworkCore;namespace EFCoreConcurrencyDemo.DbContext&#123; public class MyDbContext:Microsoft.EntityFrameworkCore.DbContext &#123; public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options):base(options) &#123; &#125; public DbSet&lt;ConcurrencyCheckDemo&gt; ConcurrencyCheckDemos &#123; get; set; &#125; public DbSet&lt;RowVersionDemo&gt; RowVersionDemos &#123; get; set; &#125; protected override void OnModelCreating(ModelBuilder modelBuilder) &#123; modelBuilder.ApplyConfiguration(new ConcurrencyCheckDemoConfiguration()); modelBuilder.ApplyConfiguration(new RowVersionDemoConfiguration()); &#125; &#125;&#125; 修改Startup修改Startup.ConfigureServices方法，具体内容如下： 123456789public void ConfigureServices(IServiceCollection services)&#123; services.AddDbContext&lt;MyDbContext&gt;(options =&gt; &#123; options.UseSqlServer(Configuration.GetConnectionString(\"EFCoreConcurrencyDemo\")); options.EnableSensitiveDataLogging(false); &#125;); services.AddControllers();&#125; 添加数据库连接字符串在appsettings.json中添加数据库连接字符串，具体内容如下（连接字符串就换成你自己的数据库）： 12345678910111213&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125; &#125;, \"ConnectionStrings\": &#123; \"EFCoreConcurrencyDemo\": \"Password=jiamiao.x.20.demo;Persist Security Info=True;User ID=sa;Initial Catalog=EFCoreConcurrencyDemo;Data Source=127.0.0.1\" &#125;, \"AllowedHosts\": \"*\"&#125; 添加测试控制器在Controllers中添加DemoController.cs，具体内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System.Threading.Tasks;using EFCoreConcurrencyDemo.DbContext;using EFCoreConcurrencyDemo.DbModel.ConcurrencyCheckDemo;using EFCoreConcurrencyDemo.DbModel.RowVersionDemo;using Microsoft.AspNetCore.Mvc;using Microsoft.EntityFrameworkCore;namespace EFCoreConcurrencyDemo.Controllers&#123; [Route(\"[controller]/[action]\")] [ApiController] public class DemoController : ControllerBase &#123; private readonly MyDbContext _dbContext; public DemoController(MyDbContext dbContext) &#123; _dbContext = dbContext; &#125; public async Task&lt;int&gt; SeedData() &#123; var concurrencyCheckDemo = new ConcurrencyCheckDemo() &#123; Name = \"ConcurrencyCheck测试\", Age = 20 &#125;; await _dbContext.ConcurrencyCheckDemos.AddAsync(concurrencyCheckDemo); var rowVersionDemo = new RowVersionDemo() &#123; Name = \"RowVersion测试\", Age = 24 &#125;; await _dbContext.RowVersionDemos.AddAsync(rowVersionDemo); var changedRow = await _dbContext.SaveChangesAsync(); return changedRow; &#125; public async Task&lt;int&gt; ConcurrencyCheck() &#123; var dbValue = await _dbContext.ConcurrencyCheckDemos.FirstOrDefaultAsync(); //dbValue.Name = \"ConcurrencyCheck New Value\"; dbValue.Age = 29; var changedRow = await _dbContext.SaveChangesAsync(); return changedRow; &#125; public async Task&lt;int&gt; RowVersionCheck() &#123; var dbValue = await _dbContext.RowVersionDemos.FirstOrDefaultAsync(); //dbValue.Name = \"RowVersion New Value\"; dbValue.Age = 36; var changedRow = await _dbContext.SaveChangesAsync(); return changedRow; &#125; &#125;&#125; 迁移数据库在Visual Studio 2019中的程序包管理控制台中输入以下命令： 1add-migration InitDemoDb 得到迁移记录之后，用以下命令生成数据库脚本，去Microsoft SQL Server Management Studio中执行即可，或者你可以用EFCore中的update命令直接迁移 1script-migration 测试 这里提供测试思路，将项目运行起来，先访问/demo/SeedData往数据库写入两条测试数据 分别测试/demo/ConcurrencyCheck和/demo/RowVersionCheck，在赋值的那行代码打断点，取得数据之后，自己在Microsoft SQL Server Management Studio中手动修改数据，然后继续运行代码，则可以看出效果 官方文档 https://docs.microsoft.com/zh-cn/ef/core/saving/concurrency","categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/categories/ASP-NET-Core/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"EntityFramework Core","slug":"EntityFramework-Core","permalink":"http://www.dimsum.fun/tags/EntityFramework-Core/"},{"name":"ORM","slug":"ORM","permalink":"http://www.dimsum.fun/tags/ORM/"}]},{"title":"ASP.NET Core发布到Docker中(使用Dockerfile)","slug":"19.Docker_AspNetCore_document","date":"2020-04-09T07:49:00.000Z","updated":"2020-04-09T09:20:56.918Z","comments":true,"path":"2020/04/09/19.Docker_AspNetCore_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/09/19.Docker_AspNetCore_document/","excerpt":"","text":"ASP.NET Core的常用命令 Dockerfile中的命令 FROM WORKDIR COPY RUN ENTRYPOINT 具体操作 创建项目 创建Dockerfile文件 编写Dockerfile文件 生成镜像 ASP.NET Core的常用命令在使用VS 2019、VSCode、Rider这类IDE写完代码之后，在命令行进入项目目录，尝试使用以下命令来恢复、编译、发布、运行项目 恢复所有的NuGet包1dotnet restore [项目名.csproj] 这里的项目文件可以省略，自己在命令行中执行可以省略，但是如果将命令写到文件中，为了方便理解，一般会将项目文件写上 编译1dotnet build [项目名.csproj] -c Release -o /app/build 项目文件解释参照上面 -c 表示编译配置，这里指定编译配置为Release -o 表示编译后文件输出到哪个目录，这里指定编译后输出目录为/app/build 发布1dotnet publish [项目名.csproj] -c Release -o /app/publish 命令参数与编译的参数基本一致 运行在生成发布文件的目录里运行1dotnet [项目名称.dll] Dockerfile中的命令为了快速看到效果，这里只是列举了下面简单示例使用到的命令 FROM指定运行是镜像，例如FROM mcr.microsoft.com/dotnet/core/aspnet:3.1，后面用AS命令可以在执行命令时给镜像起别名，例如FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS base，即表示将mcr.microsoft.com/dotnet/core/aspnet:3.1这个镜像起别名为base 当需要多个镜像的时候，可多次使用这个命令 WORKDIR设定工作目录，类似命令行中的cd命令，设定之后后续的命令相当于在工作目录中运行 COPY拷贝文件，这个命令可以拷贝当前宿主机的文件，也可以拷贝上面那种引用多个镜像进行编译的文件到当前镜像 拷贝宿主机文件1COPY . ./ 表示拷贝当前文件夹的所有文件到镜像中的当前文件夹，一般在执行这个命令之前会设置好工作目录，表示将宿主机当前文件夹中的所有文件拷贝到镜像中的工作目录中 拷贝其他镜像文件1COPY --from=build /app/publish . 使用--from=build表示从build的镜像中拷贝文件，这里的build是引入镜像时指定的别名，/app/publish是build镜像的文件路径，最后一个.是指要拷贝到当前镜像来的目录，.表示当前路径，一般也是配合WORKDIR使用RUN执行命令，构建镜像的时候需要安装其他软件或者编译文件的命令在这里执行，多条命令可以用&amp;&amp;来连接，以发布ASP.NET Core项目为例，将代码拷贝到镜像之后，需要进行restore、build、publish，就可以在这里使用，例如：1RUN dotnet restore \"./Jiamiao.x.ServiceA.csproj\" &amp;&amp; dotnet build \"./Jiamiao.x.ServiceA.csproj\" -c Release -o /app/build &amp;&amp; dotnet publish \"./Jiamiao.x.ServiceA.csproj\" -c Release -o /app/publish ENTRYPOINT一样是执行命令，但是这里是容器启动的时候要执行的命令，比如上面那些恢复、编译、发布的命令就不能在这里执行，因为容器启动的时候是不用做这些操作的，作为容器启动，只需要启动站点即可，所以这里使用的是运行命令，所以每个Dockerfile只有一个ENTRYPOINT，多个ENTRYPOINT后面会覆盖前面1ENTRYPOINT [ &quot;dotnet&quot;,&quot;Jiamiao.x.ServiceA.dll&quot; ] 上面的命令等于在命令行执行dotnet Jiamiao.x.ServiceA.dll这个命令 具体操作创建项目创建名字为Jiamiao.x.ServiceA的ASP.NET Core项目，类型为API，这里只是做发布测试，所以不需要动任何代码 创建Dockerfile文件这里使用VSCode为例，在VSCode中安装Docker扩展，如下图 按Ctrl + Shift + P，打开控制面板，输入add docker，选择Docker:Add Docker Files To Workspace，如下图 选择.NET:ASP.NET Core，如下图 选择Linux，如下图 选择No，如下图 默认输入80, 443保持不变，回车即可生成Dockerfile文件 好了！这里的文件内容不是我们想要的，直接删掉Dockerfile里的文件内容即可，我们主要是要自动生成一个.dockerignore文件 编写Dockerfile文件确定以下思路，这里需要将代码拷贝进容器进行编译发布，然后再将发布好的文件拷贝到运行时的镜像中，容器运行时启动站点，具体代码如下： 12345678910111213141516# 指定运行是镜像FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS baseWORKDIR /app# 指定编译和发布镜像FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build# 设置工作目录为srcWORKDIR /src# 拷贝所有文件到容器中的工作目录COPY . ./RUN dotnet restore \"./Jiamiao.x.ServiceA.csproj\" &amp;&amp; dotnet build \"./Jiamiao.x.ServiceA.csproj\" -c Release -o /app/build &amp;&amp; dotnet publish \"./Jiamiao.x.ServiceA.csproj\" -c Release -o /app/publishFROM base as finalWORKDIR /appCOPY --from=build /app/publish .ENTRYPOINT [ \"dotnet\",\"Jiamiao.x.ServiceA.dll\" ] 这里使用了两个镜像，一个是编译发布用的mcr.microsoft.com/dotnet/core/sdk:3.1简称为build，一个是运行时用的mcr.microsoft.com/dotnet/core/aspnet:3.1简称base 生成镜像在项目根目录，即Dockerfile所在目录运行预下命令 1docker build -t xiejiamiao/aspnetcore . 其中xiejiamiao/aspnetcore为镜像名字，后面的.表示使用当前目录的Dockerfile。如果生成成功，使用docker images应该就可以看到刚刚生成的镜像，执行以下命令启动容器 1docker run -d -p 8080:80 xiejiamiao&#x2F;aspnetcore --name ASPNETCore-X -d表示后台运行容器 8080:80是指将宿主机的8080端口映射到容器中的80端口 xiejiamiao/aspnetcore为镜像的名字 ASPNETCore-X为镜像运行起来的容器的名字容器启动成功后，访问http://127.0.0.1:8080/WeatherForecast应该就可以看到返回一些json","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.dimsum.fun/categories/Docker/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"Docker","slug":"Docker","permalink":"http://www.dimsum.fun/tags/Docker/"}]},{"title":".NET Core开发实战课程备忘(18) -- 微服务之工程结构概览：定义应用分层及依赖关系","slug":"18.MicroService01_document","date":"2020-04-07T10:18:00.000Z","updated":"2020-04-09T09:20:56.918Z","comments":true,"path":"2020/04/07/18.MicroService01_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/07/18.MicroService01_document/","excerpt":"","text":"分层 总结 分层 领域模型层Domain：定义领域模型的地方，这里面会有不同的聚合、领域事件，其中不同的聚合下面就是领域模型 基础设施层Infrastructure：仓储层和一些共享代码的实现、领域模型与数据库之间的映射关系 应用层Application：API和后台任务 Web API也分类一些目录： Application：项目使用了CQRS模式，即命令与查询职责分离，所以我们会把命令放在一个目录，查询放在一个目录，还有两个事件处理的目录，一个是领域模型中领域事件的处理，一个是集成事件的处理 Controllers：主要就是定义Web Extensions：将服务注册进容器的代码和中间件配置的代码，就是ServiceCollection和ApplicationBuilder的扩展 Infrastructure：身份认证、缓存等与基础设施交互的代码 共享层Share GeekTime.Core –主要是承载基础简单的类型，比如自定义异常类，一下帮助类 GeekTime.Domain.Abstractions –领域抽象层，定义领域模型的一些基类、接口、领域事件的接口、领域事件处理的接口、Entity的接口和Entity的基类 GeekTime.Infrastructure.Core –基础设施核心层，可以仓储和EFContext定义一些共享的代码 共享层的代码是在所有项目里面都可以共享的，所有建议的做法是把这些代码通过私有的NuGet仓库来存储，然后其他工程可以使用NuGet包来直接引用即可 各层之间的依赖关系： 共享层：这个层不依赖解决方案中其他层 GeekTime.Core：不依赖任何其他工程 GeekTime.Domain.Abstractions：不依赖任何其他工程 GeekTime.Infrastructure.Core：依赖领域模型的抽象层GeekTime.Domain.Abstractions 领域模型层： 我们的领域模型是需要继承我们定义的模型基类，并且实现一个聚合根的接口，表示它是一个聚合根 领域事件就需要我们实现一个领域事件的机口 基础设施层： 定义仓储和仓储的实现，仓储的定义实际上依赖了基础设施核心层GeekTime.Infrastructure.Core里的仓储定义，这样就能复用仓储层的代码 数据库访问的实现：继承了我们自己定义的EFContext 事务处理的对象：这个对象是来管理我们整个应用程序的请求上下文的事务，这样就可以让我们避免去手动的处理事务，简化我们的代码 应用层： 依赖基础设施层，基础设施层又依赖领域层，应用层实际上是把各层组装在一起的一层，它是我们应用程序的一个宿主，我们协调各层之间的关系，以及组装的代码都在这里实现 总结 领域模型专注业务的实现，不依赖仓储等基础设施层 基础设置的仓储层仅负责领域模型的取出和存储 使用CQRS模型设计应用层 Web API是面向前端的交互接口，避免依赖领域模型 将共享代码设计为共享包，使用私有NuGet仓库来分发管理","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"},{"name":"微服务","slug":"微服务","permalink":"http://www.dimsum.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":".NET Core开发实战课程备忘(14) -- 异常处理中间件：区分真异常与逻辑一场","slug":"14.ExceptionDemo","date":"2020-04-02T14:17:00.000Z","updated":"2020-04-02T17:11:23.324Z","comments":true,"path":"2020/04/02/14.ExceptionDemo/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/14.ExceptionDemo/","excerpt":"","text":"处理异常的方式 代码实现 创建项目 注释掉系统自带的异常处理中间件 创建自定义的异常类 为什么要创建自定义的异常类 自定义异常类 异常处理页代码实现 异常处理匿名委托方法代码实现 IExceptionFilter代码实现 ExceptionFilterAttribute代码实现 总结 处理异常的方式 异常处理页 异常处理匿名委托方法 IExceptionFilter ExceptionFilterAttribute 代码实现创建项目创建名字为ExceptionDemo的ASP.NET Core项目，类型为API 注释掉系统自带的异常处理中间件在Startup.Configure中有app.UseDeveloperExceptionPage();这个中间件，这个就是ASP.NET Core自带的一个异常处理页，但是这个页面错误信息太多，只适合开发时对开发人员进行提示，不适合放到生产环境，所以这里注释掉这个中间件 创建自定义的异常类为什么要创建自定义的异常类通常情况下我们系统里面的异常与我们业务逻辑里的异常是不同的，业务逻辑上的判断异常，比如输入的参数不合法、订单状态不符合条件，当前账户余额不足这样的错误信息，我们有两种处理方式，一种处理方式是对不同的逻辑输出不同的业务对象，还有一种方式就是对于这种业务逻辑输出一个异常，用异常来承载我们的逻辑的特殊分支，那这个时候我们就需要识别出哪些是我们的业务异常，哪些是我们不确定的未知异常，比如网络突发的无法连接、MySql的闪断之类的 那这里怎么识别出哪些是业务异常，哪些是未知异常？ 首先通过定义一个接口，接口里有错误码和错误信息，当我们有一个业务出现异常，我们可以人为的抛出一个已经实现了这个接口的自定义异常类。然后在异常处理过程中，我们尝试将捕获到的异常转为我们定义的异常接口，如果能转成功，说明这个异常是我们认为抛出的业务异常，否则为系统抛出的未知异常 自定义异常类在项目根目录创建文件夹Exceptions，所有异常的自定义类都放在这里 创建IKnownException接口，具体代码如下： 1234567891011namespace ExceptionDemo.Exceptions&#123; public interface IKnownException &#123; string Message &#123; get; &#125; int ErrorCode &#123; get; &#125; object[] ErrorData &#123; get; &#125; &#125;&#125; 创建KnownException类，具体代码如下： 1234567891011121314151617181920212223namespace ExceptionDemo.Exceptions&#123; public class KnownException:IKnownException &#123; public KnownException(object[] errorData, int errorCode, string message) &#123; ErrorData = errorData; ErrorCode = errorCode; Message = message; &#125; public string Message &#123; get; &#125; public int ErrorCode &#123; get; &#125; public object[] ErrorData &#123; get; &#125; public static readonly IKnownException UnKnown = new KnownException(errorData: new object[] &#123; &#125;, errorCode: 9999, message: \"未知错误\"); public static IKnownException FromKnownException(IKnownException exception) &#123; return new KnownException(errorData: exception.ErrorData, errorCode: exception.ErrorCode, message: exception.Message); &#125; &#125;&#125; 创建测试用的InvalidParameterException类，用来模拟参数错误的异常，具体代码如下： 12345678910111213141516using System;namespace ExceptionDemo.Exceptions&#123; public class InvalidParameterException: Exception,IKnownException &#123; public InvalidParameterException(int errorCode, string message, params object[] errorData) : base(message) &#123; ErrorCode = errorCode; ErrorData = errorData; &#125; public int ErrorCode &#123; get; &#125; public object[] ErrorData &#123; get; &#125; &#125;&#125; 异常处理页代码实现创建处理页面控制器ErrorController，在Index方法中获取到当前请求上下文的异常信息，并尝试进行转成IKnownException，如果转成功则表示为业务逻辑异常，如果失败则表示为未知异常，未知异常则通过KnownException的静态方法生成一个特定的未知异常对象，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637using ExceptionDemo.Exceptions;using Microsoft.AspNetCore.Diagnostics;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Controllers&#123; public class ErrorController : Controller &#123; private readonly ILogger&lt;ErrorController&gt; _logger; public ErrorController(ILogger&lt;ErrorController&gt; logger) &#123; _logger = logger; &#125; [Route(\"/error\")] public IActionResult Index() &#123; var exceptionHandlerPathFeature = HttpContext.Features.Get&lt;IExceptionHandlerPathFeature&gt;(); var ex = exceptionHandlerPathFeature?.Error; var knownException = ex as IKnownException; if (knownException == null) &#123; _logger.LogError(ex,ex.Message); knownException = KnownException.UnKnown; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); &#125; return View(knownException); &#125; &#125;&#125; 对应的试图Index.cshtml代码如下： 1234567891011121314151617@model ExceptionDemo.Exceptions.IKnownException@&#123; Layout = null;&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;title&gt;Index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;错误码：@Model.ErrorCode&lt;/p&gt; &lt;p&gt;错误信息：@Model.Message&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 回到Startup，对ConfigureServices和Configure两个方法做出调整，具体代码如下： 12345678910111213141516public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; app.UseExceptionHandler(\"/error\"); app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 切换到WeatherForecastController，在这里来主动抛出异常，将Get方法修改如下： 12345[HttpGet]public IEnumerable&lt;WeatherForecast&gt; Get()&#123; throw new InvalidParameterException(65, \"参数有误\", new List&lt;string&gt;() &#123;\"exception info 1\",\"exception info 2\" &#125;);&#125; 运行代码，访问/weatherforecast，可以看到返回了以下 123错误码：65错误信息：参数有误 将WeatherForecastController.Get里的异常换成一个普通的异常，在重新运行代码，可以看到页面会变成未知错误的提示，同时控制台打印出来的日志是完全的异常日志 异常处理匿名委托方法代码实现将Startup.Configure方法中的app.UseExceptionHandler(&quot;/error&quot;);注释掉，原位置新增以下代码： 123456789101112131415161718192021222324app.UseExceptionHandler(errApp =&gt;&#123; errApp.Run(async context =&gt; &#123; var exceptionHandlerPathFeature = context.Features.Get&lt;IExceptionHandlerPathFeature&gt;(); var knownException = exceptionHandlerPathFeature.Error as IKnownException; if (knownException == null) &#123; var logger = context.RequestServices.GetService&lt;ILogger&lt;Startup&gt;&gt;(); logger.LogError(exceptionHandlerPathFeature.Error, exceptionHandlerPathFeature.Error.Message); knownException = KnownException.UnKnown; context.Response.StatusCode = StatusCodes.Status500InternalServerError; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); context.Response.StatusCode = StatusCodes.Status200OK; &#125; var jsonOptions = context.RequestServices.GetService&lt;IOptions&lt;JsonOptions&gt;&gt;(); context.Response.ContentType = \"application/json; charset=utf-8\"; await context.Response.WriteAsync(JsonSerializer.Serialize(knownException, jsonOptions.Value.JsonSerializerOptions)); &#125;);&#125;); 这里的操作与异常处理页逻辑差不多，只是不再返回视图，而是返回json，同时设定好业务逻辑异常返回200状态码，未知异常返回500状态码(这样做的好处后面说明)，运行代码，访问/weatherforecast，通过修改抛出异常，可看到对应的返回结果 IExceptionFilter代码实现在Exceptions文件夹新建MyExceptionFilter.cs，具体代码如下： 123456789101112131415161718192021222324252627282930313233using Microsoft.AspNetCore.Http;using Microsoft.AspNetCore.Mvc;using Microsoft.AspNetCore.Mvc.Filters;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Exceptions&#123; public class MyExceptionFilter:IExceptionFilter &#123; public void OnException(ExceptionContext context) &#123; var knownException = context.Exception as IKnownException; if (knownException == null) &#123; var logger = context.HttpContext.RequestServices.GetService&lt;ILogger&lt;MyExceptionFilter&gt;&gt;(); logger.LogError(context.Exception,context.Exception.Message); knownException = KnownException.UnKnown; context.HttpContext.Response.StatusCode = StatusCodes.Status500InternalServerError; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); context.HttpContext.Response.StatusCode = StatusCodes.Status200OK; &#125; context.Result = new JsonResult(knownException) &#123; ContentType = \"application/json; charset=utf-8\" &#125;; &#125; &#125;&#125; 这里对异常的处理逻辑与异常处理匿名委托方法一样 修改Startup的ConfigureServices、Configure，具体代码如下： 12345678910111213141516171819public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews(options =&gt; &#123; options.Filters.Add&lt;MyExceptionFilter&gt;(); &#125;).AddJsonOptions( options =&gt; &#123; options.JsonSerializerOptions.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping; &#125;);&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 运行代码，访问/weatherforecast，通过修改抛出异常，可看到对应的返回结果 ExceptionFilterAttribute代码实现在Exceptions中新建MyExceptionFilterAttribute.cs，具体代码如下： 123456789101112131415161718192021222324252627282930313233using Microsoft.AspNetCore.Http;using Microsoft.AspNetCore.Mvc;using Microsoft.AspNetCore.Mvc.Filters;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Exceptions&#123; public class MyExceptionFilterAttribute : ExceptionFilterAttribute &#123; public override void OnException(ExceptionContext context) &#123; var knownException = context.Exception as IKnownException; if (knownException == null) &#123; var logger = context.HttpContext.RequestServices.GetService&lt;ILogger&lt;MyExceptionFilterAttribute&gt;&gt;(); logger.LogError(context.Exception, context.Exception.Message); knownException = KnownException.UnKnown; context.HttpContext.Response.StatusCode = StatusCodes.Status500InternalServerError; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); context.HttpContext.Response.StatusCode = StatusCodes.Status200OK; &#125; context.Result = new JsonResult(knownException) &#123; ContentType = \"application/json; charset=utf-8\" &#125;; &#125; &#125;&#125; 修改Startup的ConfigureServices、Configure，具体代码如下： 1234567891011121314public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 在WeatherForecastController中添加类特性，具体代码如下： 12345678910111213141516171819202122232425262728293031using System.Collections.Generic;using ExceptionDemo.Exceptions;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Controllers&#123; [ApiController] [Route(\"[controller]\")] [MyExceptionFilter] public class WeatherForecastController : ControllerBase &#123; private static readonly string[] Summaries = new[] &#123; \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\" &#125;; private readonly ILogger&lt;WeatherForecastController&gt; _logger; public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger) &#123; _logger = logger; &#125; [HttpGet] public IEnumerable&lt;WeatherForecast&gt; Get() &#123; throw new InvalidParameterException(65, \"参数有误！！！\", new List&lt;string&gt;() &#123;\"exception info 1\",\"exception info 2\" &#125;); &#125; &#125;&#125; 运行代码，访问/weatherforecast，通过修改抛出异常，可看到对应的返回结果 总结 用特定的异常类或接口表示业务逻辑异常 为业务逻辑异常定义全局错误码 为未知异常定义特定的输出信息和错误码，不应该输出系统内部的异常堆栈 对已知的业务逻辑异常相应HTTP 200，这样对监控系统友好，不会区分不开真异常和逻辑异常 对于未预见的异常相应HTTP 500 为所有异常记录详细的日志","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(14) -- 异常处理中间件：区分真异常与逻辑一场","slug":"14.Exception_document","date":"2020-04-02T14:17:00.000Z","updated":"2020-04-03T08:32:55.159Z","comments":true,"path":"2020/04/02/14.Exception_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/14.Exception_document/","excerpt":"","text":"处理异常的方式 代码实现 创建项目 注释掉系统自带的异常处理中间件 创建自定义的异常类 为什么要创建自定义的异常类 自定义异常类 异常处理页代码实现 异常处理匿名委托方法代码实现 IExceptionFilter代码实现 ExceptionFilterAttribute代码实现 总结 处理异常的方式 异常处理页 异常处理匿名委托方法 IExceptionFilter ExceptionFilterAttribute 代码实现创建项目创建名字为ExceptionDemo的ASP.NET Core项目，类型为API 注释掉系统自带的异常处理中间件在Startup.Configure中有app.UseDeveloperExceptionPage();这个中间件，这个就是ASP.NET Core自带的一个异常处理页，但是这个页面错误信息太多，只适合开发时对开发人员进行提示，不适合放到生产环境，所以这里注释掉这个中间件 创建自定义的异常类为什么要创建自定义的异常类通常情况下我们系统里面的异常与我们业务逻辑里的异常是不同的，业务逻辑上的判断异常，比如输入的参数不合法、订单状态不符合条件，当前账户余额不足这样的错误信息，我们有两种处理方式，一种处理方式是对不同的逻辑输出不同的业务对象，还有一种方式就是对于这种业务逻辑输出一个异常，用异常来承载我们的逻辑的特殊分支，那这个时候我们就需要识别出哪些是我们的业务异常，哪些是我们不确定的未知异常，比如网络突发的无法连接、MySql的闪断之类的 那这里怎么识别出哪些是业务异常，哪些是未知异常？ 首先通过定义一个接口，接口里有错误码和错误信息，当我们有一个业务出现异常，我们可以人为的抛出一个已经实现了这个接口的自定义异常类。然后在异常处理过程中，我们尝试将捕获到的异常转为我们定义的异常接口，如果能转成功，说明这个异常是我们认为抛出的业务异常，否则为系统抛出的未知异常 自定义异常类在项目根目录创建文件夹Exceptions，所有异常的自定义类都放在这里 创建IKnownException接口，具体代码如下： 1234567891011namespace ExceptionDemo.Exceptions&#123; public interface IKnownException &#123; string Message &#123; get; &#125; int ErrorCode &#123; get; &#125; object[] ErrorData &#123; get; &#125; &#125;&#125; 创建KnownException类，具体代码如下： 1234567891011121314151617181920212223namespace ExceptionDemo.Exceptions&#123; public class KnownException:IKnownException &#123; public KnownException(object[] errorData, int errorCode, string message) &#123; ErrorData = errorData; ErrorCode = errorCode; Message = message; &#125; public string Message &#123; get; &#125; public int ErrorCode &#123; get; &#125; public object[] ErrorData &#123; get; &#125; public static readonly IKnownException UnKnown = new KnownException(errorData: new object[] &#123; &#125;, errorCode: 9999, message: \"未知错误\"); public static IKnownException FromKnownException(IKnownException exception) &#123; return new KnownException(errorData: exception.ErrorData, errorCode: exception.ErrorCode, message: exception.Message); &#125; &#125;&#125; 创建测试用的InvalidParameterException类，用来模拟参数错误的异常，具体代码如下： 12345678910111213141516using System;namespace ExceptionDemo.Exceptions&#123; public class InvalidParameterException: Exception,IKnownException &#123; public InvalidParameterException(int errorCode, string message, params object[] errorData) : base(message) &#123; ErrorCode = errorCode; ErrorData = errorData; &#125; public int ErrorCode &#123; get; &#125; public object[] ErrorData &#123; get; &#125; &#125;&#125; 异常处理页代码实现创建处理页面控制器ErrorController，在Index方法中获取到当前请求上下文的异常信息，并尝试进行转成IKnownException，如果转成功则表示为业务逻辑异常，如果失败则表示为未知异常，未知异常则通过KnownException的静态方法生成一个特定的未知异常对象，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637using ExceptionDemo.Exceptions;using Microsoft.AspNetCore.Diagnostics;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Controllers&#123; public class ErrorController : Controller &#123; private readonly ILogger&lt;ErrorController&gt; _logger; public ErrorController(ILogger&lt;ErrorController&gt; logger) &#123; _logger = logger; &#125; [Route(\"/error\")] public IActionResult Index() &#123; var exceptionHandlerPathFeature = HttpContext.Features.Get&lt;IExceptionHandlerPathFeature&gt;(); var ex = exceptionHandlerPathFeature?.Error; var knownException = ex as IKnownException; if (knownException == null) &#123; _logger.LogError(ex,ex.Message); knownException = KnownException.UnKnown; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); &#125; return View(knownException); &#125; &#125;&#125; 对应的试图Index.cshtml代码如下： 1234567891011121314151617@model ExceptionDemo.Exceptions.IKnownException@&#123; Layout = null;&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;title&gt;Index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;错误码：@Model.ErrorCode&lt;/p&gt; &lt;p&gt;错误信息：@Model.Message&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 回到Startup，对ConfigureServices和Configure两个方法做出调整，具体代码如下： 12345678910111213141516public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; app.UseExceptionHandler(\"/error\"); app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 切换到WeatherForecastController，在这里来主动抛出异常，将Get方法修改如下： 12345[HttpGet]public IEnumerable&lt;WeatherForecast&gt; Get()&#123; throw new InvalidParameterException(65, \"参数有误\", new List&lt;string&gt;() &#123;\"exception info 1\",\"exception info 2\" &#125;);&#125; 运行代码，访问/weatherforecast，可以看到返回了以下 123错误码：65错误信息：参数有误 将WeatherForecastController.Get里的异常换成一个普通的异常，在重新运行代码，可以看到页面会变成未知错误的提示，同时控制台打印出来的日志是完全的异常日志 异常处理匿名委托方法代码实现将Startup.Configure方法中的app.UseExceptionHandler(&quot;/error&quot;);注释掉，原位置新增以下代码： 123456789101112131415161718192021222324app.UseExceptionHandler(errApp =&gt;&#123; errApp.Run(async context =&gt; &#123; var exceptionHandlerPathFeature = context.Features.Get&lt;IExceptionHandlerPathFeature&gt;(); var knownException = exceptionHandlerPathFeature.Error as IKnownException; if (knownException == null) &#123; var logger = context.RequestServices.GetService&lt;ILogger&lt;Startup&gt;&gt;(); logger.LogError(exceptionHandlerPathFeature.Error, exceptionHandlerPathFeature.Error.Message); knownException = KnownException.UnKnown; context.Response.StatusCode = StatusCodes.Status500InternalServerError; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); context.Response.StatusCode = StatusCodes.Status200OK; &#125; var jsonOptions = context.RequestServices.GetService&lt;IOptions&lt;JsonOptions&gt;&gt;(); context.Response.ContentType = \"application/json; charset=utf-8\"; await context.Response.WriteAsync(JsonSerializer.Serialize(knownException, jsonOptions.Value.JsonSerializerOptions)); &#125;);&#125;); 这里的操作与异常处理页逻辑差不多，只是不再返回视图，而是返回json，同时设定好业务逻辑异常返回200状态码，未知异常返回500状态码(这样做的好处后面说明)，运行代码，访问/weatherforecast，通过修改抛出异常，可看到对应的返回结果 IExceptionFilter代码实现在Exceptions文件夹新建MyExceptionFilter.cs，具体代码如下： 123456789101112131415161718192021222324252627282930313233using Microsoft.AspNetCore.Http;using Microsoft.AspNetCore.Mvc;using Microsoft.AspNetCore.Mvc.Filters;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Exceptions&#123; public class MyExceptionFilter:IExceptionFilter &#123; public void OnException(ExceptionContext context) &#123; var knownException = context.Exception as IKnownException; if (knownException == null) &#123; var logger = context.HttpContext.RequestServices.GetService&lt;ILogger&lt;MyExceptionFilter&gt;&gt;(); logger.LogError(context.Exception,context.Exception.Message); knownException = KnownException.UnKnown; context.HttpContext.Response.StatusCode = StatusCodes.Status500InternalServerError; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); context.HttpContext.Response.StatusCode = StatusCodes.Status200OK; &#125; context.Result = new JsonResult(knownException) &#123; ContentType = \"application/json; charset=utf-8\" &#125;; &#125; &#125;&#125; 这里对异常的处理逻辑与异常处理匿名委托方法一样 修改Startup的ConfigureServices、Configure，具体代码如下： 12345678910111213141516171819public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews(options =&gt; &#123; options.Filters.Add&lt;MyExceptionFilter&gt;(); &#125;).AddJsonOptions( options =&gt; &#123; options.JsonSerializerOptions.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping; &#125;);&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 运行代码，访问/weatherforecast，通过修改抛出异常，可看到对应的返回结果 ExceptionFilterAttribute代码实现在Exceptions中新建MyExceptionFilterAttribute.cs，具体代码如下： 123456789101112131415161718192021222324252627282930313233using Microsoft.AspNetCore.Http;using Microsoft.AspNetCore.Mvc;using Microsoft.AspNetCore.Mvc.Filters;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Exceptions&#123; public class MyExceptionFilterAttribute : ExceptionFilterAttribute &#123; public override void OnException(ExceptionContext context) &#123; var knownException = context.Exception as IKnownException; if (knownException == null) &#123; var logger = context.HttpContext.RequestServices.GetService&lt;ILogger&lt;MyExceptionFilterAttribute&gt;&gt;(); logger.LogError(context.Exception, context.Exception.Message); knownException = KnownException.UnKnown; context.HttpContext.Response.StatusCode = StatusCodes.Status500InternalServerError; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); context.HttpContext.Response.StatusCode = StatusCodes.Status200OK; &#125; context.Result = new JsonResult(knownException) &#123; ContentType = \"application/json; charset=utf-8\" &#125;; &#125; &#125;&#125; 修改Startup的ConfigureServices、Configure，具体代码如下： 1234567891011121314public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 在WeatherForecastController中添加类特性，具体代码如下： 12345678910111213141516171819202122232425262728293031using System.Collections.Generic;using ExceptionDemo.Exceptions;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Controllers&#123; [ApiController] [Route(\"[controller]\")] [MyExceptionFilter] public class WeatherForecastController : ControllerBase &#123; private static readonly string[] Summaries = new[] &#123; \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\" &#125;; private readonly ILogger&lt;WeatherForecastController&gt; _logger; public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger) &#123; _logger = logger; &#125; [HttpGet] public IEnumerable&lt;WeatherForecast&gt; Get() &#123; throw new InvalidParameterException(65, \"参数有误！！！\", new List&lt;string&gt;() &#123;\"exception info 1\",\"exception info 2\" &#125;); &#125; &#125;&#125; 运行代码，访问/weatherforecast，通过修改抛出异常，可看到对应的返回结果 总结 用特定的异常类或接口表示业务逻辑异常 为业务逻辑异常定义全局错误码 为未知异常定义特定的输出信息和错误码，不应该输出系统内部的异常堆栈 对已知的业务逻辑异常相应HTTP 200，这样对监控系统友好，不会区分不开真异常和逻辑异常 对于未预见的异常相应HTTP 500 为所有异常记录详细的日志","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(13) -- 中间件：掌握请求处理过程的关键","slug":"13.Middleware_document","date":"2020-04-02T10:12:00.000Z","updated":"2020-04-02T17:11:23.323Z","comments":true,"path":"2020/04/02/13.Middleware_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/13.Middleware_document/","excerpt":"","text":"核心对象 代码实现 创建项目 直接注入委托 对特定路径注册特定中间件 对特定路径注册中间件升级版 使用扩展方法来注册中间件(最佳姿势) 核心对象 IApplicationBuilder：让我们注册我们自己的中间件 RequestDelegate：我们处理整个请求的委托 代码实现创建项目创建名字为MiddlewareDemo的ASP.NET Core项目，类型为API 直接注入委托Startup.Configure方法里，在app.UseHttpsRedirection()中间件之前添加以下代码： 12345app.Use(async (context, next) =&gt;&#123; await next(); await context.Response.WriteAsync(\"Hello world -- my middleware in delegate\");&#125;); 运行代码访问/WeatherForecast，可以看到原本的json后面会添加Hello world -- my middleware in delegate这句话 对特定路径注册特定中间件注释掉上面的代码，在原处新增以下代码 12345678app.Map(\"/abc\", builder =&gt;&#123; builder.Use(async (context, next) =&gt; &#123; await next(); await context.Response.WriteAsync(\"Hello world abc -- from map middleware\"); &#125;);&#125;); 运行代码访问/WeatherForecast，结果与初始项目运行一致，访问/abc，页面会返回Hello world abc -- from map middleware 对特定路径注册中间件升级版当这个特定路径的判断比较复杂，可以使用MapWhen来注册，注释掉上一步代码，在原处新增以下代码： 12345678app.MapWhen(context =&gt; &#123; return context.Request.Query.Keys.Contains(\"abc\"); &#125;, builder =&gt;&#123; builder.Use(async (context, next) =&gt; &#123; await next(); await context.Response.WriteAsync(\"Hello world query abc -- from mapWhen middleware\"); &#125;);&#125;); 这里表示当url参数里包含abc这个函数，则触发指定的中间件，运行代码，运行代码访问/WeatherForecast，结果与初始项目运行一致，访问/WeatherForecast?abc=aaa，会在原有的返回结果后面添加Hello world query abc -- from mapWhen middleware 使用扩展方法来注册中间件(最佳姿势)自定义中间件是按约定来调用的，即中间件里需要包含一个InvokeAsync方法，方法参数为HttpContext，通常中间件不直接对外暴露，所以类的访问修饰符通常是默认的internal，然后通过IApplicationBuilder的扩展方法向外暴露 在根目录创建文件夹Middlewares/MyMiddleware，在目录下创建两个文件MyMiddleware.cs和MyMiddlewareExtension.cs，具体代码如下： MyMiddleware.cs代码： 12345678910111213141516171819202122232425262728293031using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using Microsoft.AspNetCore.Http;using Microsoft.Extensions.Logging;namespace MiddlewareDemo.Middlewares.MyMiddleware&#123; class MyMiddleware &#123; private readonly RequestDelegate _next; private readonly ILogger&lt;MyMiddleware&gt; _logger; public MyMiddleware(RequestDelegate next,ILogger&lt;MyMiddleware&gt; logger) &#123; _next = next; _logger = logger; &#125; public async Task InvokeAsync(HttpContext context) &#123; using (_logger.BeginScope(\"TraceIdentifier:&#123;TraceIdentifier&#125;\",context.TraceIdentifier)) &#123; _logger.LogDebug(\"开始执行MyMiddleware中间件\"); await _next(context); _logger.LogDebug(\"执行MyMiddleware中间件结束\"); &#125; &#125; &#125;&#125; MyMiddlewareExtension.cs代码： 123456789101112using Microsoft.AspNetCore.Builder;namespace MiddlewareDemo.Middlewares.MyMiddleware&#123; public static class MyMiddlewareExtension &#123; public static IApplicationBuilder UseMyMiddleware(this IApplicationBuilder app) &#123; return app.UseMiddleware&lt;MyMiddleware&gt;(); &#125; &#125;&#125; 因为这里使用了日志作用域，所以还需要到appsettings.json里修改以下日志配置，具体内容如下： 12345678910111213141516&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Trace\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"IncludeScopes\": true, \"LogLevel\": &#123; \"MiddlewareDemo.Middlewares.MyMiddleware.MyMiddleware\": \"Trace\" &#125; &#125; &#125;, \"AllowedHosts\": \"*\"&#125; 回到Startup.Configure，注释掉前面的测试代码，在原处新增以下代码： 1app.UseMyMiddleware(); 运行项目，访问/WeatherForecast，可以看到控制台打印出了对应的日志","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(12) -- 结构化日志组件Serilog：记录对查询分析友好的日志","slug":"LoggingSerilog_document","date":"2020-04-02T08:12:00.000Z","updated":"2020-04-02T17:11:23.324Z","comments":true,"path":"2020/04/02/LoggingSerilog_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/LoggingSerilog_document/","excerpt":"","text":"结构化日志的好处 主要场景 代码实现 创建项目 用Serilog替换自带的日志框架 修改appsettings.json文件 输出日志 结构化日志的好处 易于检索 易于分析统计 主要场景 实现日志告警 实现上下文的关联 实现与追踪系统集成 代码实现创建项目创建名字为LoggingSerilogDemo的ASP.NET Core项目，类型为API，因为使用的日志结构化组件为Serilog，所以需要引入以下的包: 1Serilog.AspNetCore 用Serilog替换自带的日志框架修改Program类，让Serilog替换掉ASP.NET Core自带的日志框架，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.IO;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.Hosting;using Serilog;using Serilog.Formatting.Compact;namespace LoggingSerilogDemo&#123; public class Program &#123; public static IConfiguration Configuration &#123; get; &#125; = new ConfigurationBuilder() .SetBasePath(Directory.GetCurrentDirectory()) .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true) .AddJsonFile($\"appsettings&#123;Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\") ?? \"Production\"&#125;.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); public static int Main(string[] args) &#123; Log.Logger = new LoggerConfiguration() .ReadFrom.Configuration(Configuration) .MinimumLevel.Debug() .Enrich.FromLogContext() .WriteTo.Console(new RenderedCompactJsonFormatter()) .WriteTo.File(formatter: new CompactJsonFormatter(), \"logs\\\\log.txt\", rollingInterval: RollingInterval.Day) .CreateLogger(); try &#123; Log.Information(\"Starting web host\"); CreateHostBuilder(args).Build().Run(); return 0; &#125; catch (Exception ex) &#123; Log.Fatal(ex,\"Host terminated unexpectedly\"); return 1; &#125; finally &#123; Log.CloseAndFlush(); &#125; &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; webBuilder.UseStartup&lt;Startup&gt;(); &#125;) .UseSerilog(dispose: true); &#125;&#125; 代码解析： 新建Configuration静态属性，直接读取appsettings.json的配置 new LoggerConfiguration是创建一个Serilog的logger对象，调的各种方法是进行日志配置 CreateHostBuilder的时候用try...catch包住是确保应用程序从开启到结束都有日志输出，包括启动失败，最后Log.CloseAndFlush()表示应用程序结束时会释放日志资源 UseSerilog表示正式引入Serilog组件，dispose:true表示应用程序关闭之后会自动释放日志资源 修改appsettings.json文件在appsettings.json文件中新增Serilog节点，具体内容如下： 12345678910111213141516171819&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125; &#125;, \"Serilog\": &#123; \"MinimumLevel\": &#123; \"Default\": \"Information\", \"Override\": &#123; \"Microsoft\": \"Information\", \"System\": \"Information\" &#125; &#125; &#125;, \"AllowedHosts\": \"*\"&#125; 输出日志在WeatherForecastController.Get方法中新增以下代码： 1_logger.LogInformation(\"This is information log\"); 运行项目，可以看到控制台打印出了结构化的日志，同时在项目根目录也有一个logs文件夹，进入文件夹可以看到日志文件","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(17) -- 路由与终结点：如何规划好你的Web API","slug":"17.Routing_document","date":"2020-04-02T08:02:00.000Z","updated":"2020-04-03T08:34:59.335Z","comments":true,"path":"2020/04/02/17.Routing_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/17.Routing_document/","excerpt":"","text":"路由注册方式 路由模板的方式 RouteAttribute方式 路由约束 类型约束 范围约束 正则表达式 是否必选 自定义IRouteConstraint Url生成 LinkGenerator IUrlHelper 代码实现创建项目创建名字为RoutingDemo的ASP.NET Core项目，类型为API，为了方便演示，这里配置了swagger的组件，需要引入以下的包 1Swashbuckle.AspNetCore 然后右键项目名称-&gt;属性-&gt;生成-&gt;输出，勾选上XML文档文件 回到Startup.ConfigureServices方法，在services.AddControllers();后面新增以下代码： 1234567services.AddSwaggerGen(c =&gt;&#123; c.SwaggerDoc(\"v1\", new OpenApiInfo() &#123;Title = \"My API\", Version = \"v1\"&#125;); var xmlFile = $\"&#123;Assembly.GetExecutingAssembly().GetName().Name&#125;.xml\"; var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile); c.IncludeXmlComments(xmlPath);&#125;); 在Startup.Configure的if(env.IsDevelopment()){...}这个if判断后面，新增以下代码： 12app.UseSwagger();app.UseSwaggerUI(c =&gt; &#123; c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"My API V1\"); &#125;); 添加测试控制器新增控制器OrderController，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System;using Microsoft.AspNetCore.Mvc;using Microsoft.AspNetCore.Routing;namespace RoutingDemo.Controllers&#123; /// &lt;summary&gt; /// 订单控制器 /// &lt;/summary&gt; [Route(\"api/[controller]/[action]\")] [ApiController] public class OrderController : ControllerBase &#123; /// &lt;summary&gt; /// 订单是否存在 /// &lt;/summary&gt; /// &lt;param name=\"id\"&gt;必须可以转为long&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; //[HttpGet(\"&#123;id:MyRouteConstraint&#125;\")] [HttpGet(\"&#123;id:isLong&#125;\")] public bool OrderExist([FromRoute]string id) &#123; return true; &#125; /// &lt;summary&gt; /// 订单最大数量 /// &lt;/summary&gt; /// &lt;param name=\"id\"&gt;最大20&lt;/param&gt; /// &lt;param name=\"linkGenerator\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpGet(\"&#123;id:max(20)&#125;\")] public bool Max(long id, [FromServices] LinkGenerator linkGenerator) &#123; var a = linkGenerator.GetPathByAction(\"Reque\", \"Order\"); return true; &#125; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;para name=\"ss\"&gt;必填&lt;/para&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpGet(\"&#123;name:required&#125;\")] [Obsolete] public bool Reque(string name) &#123; return true; &#125; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=\"number\"&gt;以三个数字开始&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpGet(\"&#123;number:regex(^\\\\d&#123;&#123;3&#125;&#125;$)&#125;\")] public bool Number(string number) &#123; return true; &#125; &#125;&#125; 自定义路由约束在项目根目录新增Constraint文件夹，在文件夹里新增MyRouteConstraint.cs，具体代码如下： 1234567891011121314151617181920212223using Microsoft.AspNetCore.Http;using Microsoft.AspNetCore.Routing;namespace RoutingDemo.Constraint&#123; public class MyRouteConstraint:IRouteConstraint &#123; public bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection) &#123; if (RouteDirection.IncomingRequest == routeDirection) &#123; var v = values[routeKey]; if (long.TryParse(v.ToString(), out var value)) &#123; return true; &#125; &#125; return false; &#125; &#125;&#125; 将自定义路由约束注册到框架中，在Startup.ConfigureServices方法里追加以下代码： 1234services.AddRouting(options =&gt;&#123; options.ConstraintMap.Add(\"isLong\", typeof(MyRouteConstraint));&#125;); 运行代码，访问/swagger，即可以看到路由配置的情况 总结 Restful不是必须的 约定好API的表达契约 将API约束在特定的目录下，如/api/ 使用ObsoleteAttribute标记即将废弃的API","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(12) -- 结构化日志组件Serilog：记录对查询分析友好的日志","slug":"12.LoggingSerilog_document","date":"2020-04-02T06:12:00.000Z","updated":"2020-04-02T17:12:26.749Z","comments":true,"path":"2020/04/02/12.LoggingSerilog_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/12.LoggingSerilog_document/","excerpt":"","text":"结构化日志的好处 主要场景 代码实现 创建项目 用Serilog替换自带的日志框架 修改appsettings.json文件 输出日志 结构化日志的好处 易于检索 易于分析统计 主要场景 实现日志告警 实现上下文的关联 实现与追踪系统集成 代码实现创建项目创建名字为LoggingSerilogDemo的ASP.NET Core项目，类型为API，因为使用的日志结构化组件为Serilog，所以需要引入以下的包: 1Serilog.AspNetCore 用Serilog替换自带的日志框架修改Program类，让Serilog替换掉ASP.NET Core自带的日志框架，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.IO;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.Hosting;using Serilog;using Serilog.Formatting.Compact;namespace LoggingSerilogDemo&#123; public class Program &#123; public static IConfiguration Configuration &#123; get; &#125; = new ConfigurationBuilder() .SetBasePath(Directory.GetCurrentDirectory()) .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true) .AddJsonFile($\"appsettings&#123;Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\") ?? \"Production\"&#125;.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); public static int Main(string[] args) &#123; Log.Logger = new LoggerConfiguration() .ReadFrom.Configuration(Configuration) .MinimumLevel.Debug() .Enrich.FromLogContext() .WriteTo.Console(new RenderedCompactJsonFormatter()) .WriteTo.File(formatter: new CompactJsonFormatter(), \"logs\\\\log.txt\", rollingInterval: RollingInterval.Day) .CreateLogger(); try &#123; Log.Information(\"Starting web host\"); CreateHostBuilder(args).Build().Run(); return 0; &#125; catch (Exception ex) &#123; Log.Fatal(ex,\"Host terminated unexpectedly\"); return 1; &#125; finally &#123; Log.CloseAndFlush(); &#125; &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; webBuilder.UseStartup&lt;Startup&gt;(); &#125;) .UseSerilog(dispose: true); &#125;&#125; 代码解析： 新建Configuration静态属性，直接读取appsettings.json的配置 new LoggerConfiguration是创建一个Serilog的logger对象，调的各种方法是进行日志配置 CreateHostBuilder的时候用try...catch包住是确保应用程序从开启到结束都有日志输出，包括启动失败，最后Log.CloseAndFlush()表示应用程序结束时会释放日志资源 UseSerilog表示正式引入Serilog组件，dispose:true表示应用程序关闭之后会自动释放日志资源 修改appsettings.json文件在appsettings.json文件中新增Serilog节点，具体内容如下： 12345678910111213141516171819&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125; &#125;, \"Serilog\": &#123; \"MinimumLevel\": &#123; \"Default\": \"Information\", \"Override\": &#123; \"Microsoft\": \"Information\", \"System\": \"Information\" &#125; &#125; &#125;, \"AllowedHosts\": \"*\"&#125; 输出日志在WeatherForecastController.Get方法中新增以下代码： 1_logger.LogInformation(\"This is information log\"); 运行项目，可以看到控制台打印出了结构化的日志，同时在项目根目录也有一个logs文件夹，进入文件夹可以看到日志文件","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(16) -- 文件提供程序：让你可以将文件放在任何地方","slug":"16.FileProvider_document","date":"2020-04-02T04:30:00.000Z","updated":"2020-04-03T08:34:56.257Z","comments":true,"path":"2020/04/02/16.FileProvider_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/16.FileProvider_document/","excerpt":"","text":"核心类型 IFileProvider：用来访问各种各样文件的提供程序的接口，通过这样抽象的定义，让我们与具体的文件的读取代码进行隔离，这样的好处是我们可以从不同的地方读取文件，不仅仅是本地物理文件，也可以是嵌入式文件，甚至是云端上面的其他API提供的文件 IFileInfo IDirectoryContents 内置文件提供程序 PhysicalFileProvider：物理文件的提供程序 EmbeddedFileProvider：嵌入式的提供程序 CompositeFileProvider：组合文件的提供程序，当我们由多个数据源来提供文件的手，可以将这些源合并为一个目录 代码实现创建项目创建名字为FileProviderDemo的控制台应用，通过nuget引入以下四个包： 1234Microsoft.Extensions.FileProviders.AbstractionsMicrosoft.Extensions.FileProviders.CompositeMicrosoft.Extensions.FileProviders.EmbeddedMicrosoft.Extensions.FileProviders.Physical 创建PhysicalFileProvider在Program.Main方法中新增以下代码： 123456var phyProvider = new PhysicalFileProvider(AppDomain.CurrentDomain.BaseDirectory);var contents = phyProvider.GetDirectoryContents(\"/\");foreach (var item in contents)&#123; Console.WriteLine(item.Name);&#125; 运行代码，可以看到控制台打印出类似以下信息： 12345678FileProviderDemo.runtimeconfig.dev.jsonFileProviderDemo.runtimeconfig.jsonMicrosoft.Extensions.FileProviders.Abstractions.dllMicrosoft.Extensions.FileProviders.Composite.dllMicrosoft.Extensions.FileProviders.Embedded.dllMicrosoft.Extensions.FileProviders.Physical.dllMicrosoft.Extensions.FileSystemGlobbing.dllMicrosoft.Extensions.Primitives.dll 创建EmbeddedFileProvider在项目根目录创建一个emb.html的文件，右键emb.html文件-&gt;属性-&gt;生成操作选择为嵌入的资源，然后在上面的测试代码后面追加以下代码： 123var embProvider = new EmbeddedFileProvider(typeof(Program).Assembly);var html = embProvider.GetFileInfo(\"emb.html\");Console.WriteLine($\"获取到嵌入式文件:&#123;html.Exists&#125;\"); 运行代码可以看到除了上一步打印的信息外，还有打印出了以下信息： 1获取到嵌入式文件:True 创建CompositeFileProvider继续上面的测试代码后面新增以下代码： 1234567Console.WriteLine(\"=====↓CompositeFileProvider↓=====\");var compositeProvider = new CompositeFileProvider(phyProvider, embProvider);var comContent = compositeProvider.GetDirectoryContents(\"/\");foreach (var item in comContent)&#123; Console.WriteLine(item.Name);&#125; 运行代码可以看到除了前两步打印的信息外，还打印了以下信息： 1234567891011121314&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;↓CompositeFileProvider↓&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;FileProviderDemo.deps.jsonFileProviderDemo.dllFileProviderDemo.exeFileProviderDemo.pdbFileProviderDemo.runtimeconfig.dev.jsonFileProviderDemo.runtimeconfig.jsonMicrosoft.Extensions.FileProviders.Abstractions.dllMicrosoft.Extensions.FileProviders.Composite.dllMicrosoft.Extensions.FileProviders.Embedded.dllMicrosoft.Extensions.FileProviders.Physical.dllMicrosoft.Extensions.FileSystemGlobbing.dllMicrosoft.Extensions.Primitives.dllemb.html","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(11) -- 日志框架：聊聊记日志的最佳姿势","slug":"11.LoggingSimple_document","date":"2020-04-02T03:12:00.000Z","updated":"2020-04-02T08:49:15.050Z","comments":true,"path":"2020/04/02/11.LoggingSimple_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/11.LoggingSimple_document/","excerpt":"","text":"概念 依赖包 日志级别 日志记录器 代码示例 创建项目 手动创建日志记录器 创建配置文件appsettings.json 依赖注入创建日志记录器 关于日志作用域 日志作用域的使用场景 代码演示 注意 概念依赖包对于输出到控制台的日志框架，主要依赖包有以下： 1234Microsoft.Extensions.LoggingMicrosoft.Extensions.Logging.ConsoleMicrosoft.Extensions.Logging.DebugMicrosoft.Extensions.Logging.TraceSource 日志级别.NET Core中日志级别分7个级别，从低到高具体如下： 1Trace -&gt; Debug -&gt; Information -&gt; Warning -&gt; Error -&gt; Critical -&gt; None 在配置中如果配置指定级别，则指定级别及以上的日志会被记录，低于指定级别的日志不会被记录，举例：配置项中指定级别为Warning，则只会记录Warning、Error、Critical这些日志，Trace、Debug、Information是不会记录下来，缺省默认配置为Information，如果指定为None级别则以为着不会有日志记录 日志记录器记录日志的级别是属于某个日志记录器的，通过ILoggerFactory的对象方法CreateLogger创建一个日志记录器，传入参数就是这个日志记录去的名字，在配置相中对应配置该日志记录器的日志级别，即可指定要哪个日志记录器需要记录到哪些级别的日志 通常正常开发比较少去自己创建日志记录器，都是通过构造函数获取依赖注入的对象ILogger&lt;T&gt;，这样获取到的日志记录器的名字为项目名.类型名称，按照这个规律就可以自行配置各个日志记录器的日志记录级别，下面会有代码示例 代码示例创建项目创建名字为LoggingSimpleDemo的控制台应用，通过nuget引入以下五个包 12345Microsoft.Extensions.Configuration.JsonMicrosoft.Extensions.LoggingMicrosoft.Extensions.Logging.ConsoleMicrosoft.Extensions.Logging.DebugMicrosoft.Extensions.Logging.TraceSource 这里引用Microsoft.Extensions.Configuration.Json这个包是因为记录日志的记录要从配置项中读取 手动创建日志记录器修改Program.Main，代码如下： 1234567891011121314151617181920212223242526272829303132using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; class Program &#123; static void Main(string[] args) &#123; var configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true); var configurationRoot = configurationBuilder.Build(); var serviceCollection = new ServiceCollection(); serviceCollection.AddSingleton&lt;IConfigurationRoot&gt;(p =&gt; configurationRoot); serviceCollection.AddLogging(builder =&gt; &#123; builder.AddConfiguration(configurationRoot.GetSection(\"Logging\")); builder.AddConsole(); &#125;); var serviceProvider = serviceCollection.BuildServiceProvider(); var loggerFactory = serviceProvider.GetService&lt;ILoggerFactory&gt;(); var loggerA = loggerFactory.CreateLogger(\"LoggerA\"); loggerA.LogDebug(2001,\"This is LoggerA -- logDebug\"); loggerA.LogInformation(\"This is LoggerA -- logInformation\"); loggerA.LogError(new Exception(\"LoggerA Error\"),\"This is LoggerA -- LogError\"); &#125; &#125;&#125; Main方法中前三行代码是读取appsettings.json的配置项 new ServiceCollection()是创建一个服务容器，然后将上面读到的服务注册到服务容器中去，有服务容器来管理配置项服务生命周期 serviceCollection.AddLogging()是添加日志服务到服务容器中，builder.AddConfiguration()指的是日志使用的是配置框架里Logging的配置项，builder.AddConsole()是添加一个名字为Console的控制台日志到日志工厂中去 serviceCollection.BuildServiceProvider()是生成一个服务容器实例 serviceProvider.GetService&lt;ILoggerFactory&gt;()是从服务容器中获取一个ILoggerFactory的日志工厂对象 loggerFactory.CreateLogger(&quot;LoggerA&quot;)是创建一个名字为LoggerA的日志记录器 LogDebug、LogInformation、LogError则是记录对应级别的日志 创建配置文件appsettings.json创建文件appsettings.json，具体内容如下： 1234567891011121314&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"LogLevel\": &#123; \"LoggerA\": \"Trace\" &#125; &#125; &#125; &#125; 将appsettings.json拷贝到输出目录(可参照文件配置提供程序里的操作)，运行项目，可以看到控制台打出以下信息： 1234567dbug: LoggerA[2001] This is LoggerA -- logDebuginfo: LoggerA[0] This is LoggerA -- logInformationfail: LoggerA[0] This is LoggerA -- LogErrorSystem.Exception: LoggerA Error 可以自行调整appsettings.json里的LoggerA配置来尝试不同级别的日志记录 依赖注入创建日志记录器创建测试服务类OrderService，具体代码如下： 1234567891011121314151617181920using System;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; public class OrderService &#123; private readonly ILogger&lt;OrderService&gt; _logger; public OrderService(ILogger&lt;OrderService&gt; logger) &#123; _logger = logger; &#125; public void Show() &#123; _logger.LogInformation(\"Show Time &#123;time&#125;\",DateTime.Now); &#125; &#125;&#125; 在Program.Main方法中将OrderService注册进服务容器中，并获取出服务实例，调用Show方法，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; class Program &#123; static void Main(string[] args) &#123; var configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true); var configurationRoot = configurationBuilder.Build(); var serviceCollection = new ServiceCollection(); serviceCollection.AddSingleton&lt;IConfigurationRoot&gt;(p =&gt; configurationRoot); serviceCollection.AddTransient&lt;OrderService&gt;(); serviceCollection.AddLogging(builder =&gt; &#123; builder.AddConfiguration(configurationRoot.GetSection(\"Logging\")); builder.AddConsole(); &#125;); var serviceProvider = serviceCollection.BuildServiceProvider(); var loggerFactory = serviceProvider.GetService&lt;ILoggerFactory&gt;(); var loggerA = loggerFactory.CreateLogger(\"LoggerA\"); loggerA.LogDebug(2001,\"This is LoggerA -- logDebug\"); loggerA.LogInformation(\"This is LoggerA -- logInformation\"); loggerA.LogError(new Exception(\"LoggerA Error\"),\"This is LoggerA -- LogError\"); var orderService = serviceProvider.GetService&lt;OrderService&gt;(); orderService.Show(); Console.ReadKey(); &#125; &#125;&#125; 修改appsettings.json，具体内容如下： 123456789101112131415&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"LogLevel\": &#123; \"LoggerA\": \"Trace\", \"LoggingSimpleDemo.OrderService\": \"Trace\" &#125; &#125; &#125; &#125; 运行项目，可以看到控制台输出日志信息 123456789dbug: LoggerA[2001] This is LoggerA -- logDebuginfo: LoggerA[0] This is LoggerA -- logInformationfail: LoggerA[0] This is LoggerA -- LogErrorSystem.Exception: LoggerA Errorinfo: LoggingSimpleDemo.OrderService[0] Show Time 04&#x2F;02&#x2F;2020 12:06:46 也可以自行调整appsettings.json里的配置来尝试不同级别的日志记录 关于日志作用域日志作用域的使用场景 一个事务包含多条操作时 复杂流程的日志关联时 调用链追踪与请求处理过程对应时 代码演示将上面获取日志记录器的代码注释掉，手动获取一个Program的日志记录器，然后创建日志作用域，具体代码如下 12345678910111213141516171819202122232425262728293031323334353637383940using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; class Program &#123; static void Main(string[] args) &#123; var configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true); var configurationRoot = configurationBuilder.Build(); var serviceCollection = new ServiceCollection(); serviceCollection.AddSingleton&lt;IConfigurationRoot&gt;(p =&gt; configurationRoot); serviceCollection.AddTransient&lt;OrderService&gt;(); serviceCollection.AddLogging(builder =&gt; &#123; builder.AddConfiguration(configurationRoot.GetSection(\"Logging\")); builder.AddConsole(); builder.AddDebug(); &#125;); var serviceProvider = serviceCollection.BuildServiceProvider(); var loggerFactory = serviceProvider.GetService&lt;ILoggerFactory&gt;(); var logger = loggerFactory.CreateLogger&lt;Program&gt;(); using (var scope = logger.BeginScope(\"scopeId=&#123;scopeId&#125;\",Guid.NewGuid())) &#123; logger.LogTrace(\"This is Trace in scope\"); logger.LogInformation(\"This is Information in scope\"); logger.LogWarning(\"This is Warning in scope\"); logger.LogError(\"This is Error in scope\"); &#125; Console.ReadKey(); &#125; &#125;&#125; 在appsettings.json中添加IncludeScopes属性，具体代码如下： 12345678910111213141516&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"IncludeScopes\": true, \"LogLevel\": &#123; \"LoggerA\": \"Trace\", \"LoggingSimpleDemo.OrderService\": \"Trace\" &#125; &#125; &#125; &#125; 运行代码，可以看到控制台打印出类似以下信息： 123456789info: LoggingSimpleDemo.Program[0] &#x3D;&gt; scopeId&#x3D;40c5bb84-584d-4a4c-a56b-f3b66214e1ac This is Information in scopewarn: LoggingSimpleDemo.Program[0] &#x3D;&gt; scopeId&#x3D;40c5bb84-584d-4a4c-a56b-f3b66214e1ac This is Warning in scopefail: LoggingSimpleDemo.Program[0] &#x3D;&gt; scopeId&#x3D;40c5bb84-584d-4a4c-a56b-f3b66214e1ac This is Error in scope 在ASP.NET Core项目中，要启用日志作用域，一样只需要在配置文件中新增IncludeScopes属性即可 注意 日志记录要避免敏感信息，如密码、密钥等 日志记录的时候最好用占位符的方式传参数，可以节省不必要的字符串拼接","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(11) -- 日志框架：聊聊记日志的最佳姿势","slug":"LoggingSimple_document","date":"2020-04-02T03:12:00.000Z","updated":"2020-04-02T08:46:34.054Z","comments":true,"path":"2020/04/02/LoggingSimple_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/LoggingSimple_document/","excerpt":"","text":"概念 依赖包 日志级别 日志记录器 代码示例 创建项目 手动创建日志记录器 创建配置文件appsettings.json 依赖注入创建日志记录器 关于日志作用域 日志作用域的使用场景 代码演示 注意 概念依赖包对于输出到控制台的日志框架，主要依赖包有以下： 1234Microsoft.Extensions.LoggingMicrosoft.Extensions.Logging.ConsoleMicrosoft.Extensions.Logging.DebugMicrosoft.Extensions.Logging.TraceSource 日志级别.NET Core中日志级别分7个级别，从低到高具体如下： 1Trace -&gt; Debug -&gt; Information -&gt; Warning -&gt; Error -&gt; Critical -&gt; None 在配置中如果配置指定级别，则指定级别及以上的日志会被记录，低于指定级别的日志不会被记录，举例：配置项中指定级别为Warning，则只会记录Warning、Error、Critical这些日志，Trace、Debug、Information是不会记录下来，缺省默认配置为Information，如果指定为None级别则以为着不会有日志记录 日志记录器记录日志的级别是属于某个日志记录器的，通过ILoggerFactory的对象方法CreateLogger创建一个日志记录器，传入参数就是这个日志记录去的名字，在配置相中对应配置该日志记录器的日志级别，即可指定要哪个日志记录器需要记录到哪些级别的日志 通常正常开发比较少去自己创建日志记录器，都是通过构造函数获取依赖注入的对象ILogger&lt;T&gt;，这样获取到的日志记录器的名字为项目名.类型名称，按照这个规律就可以自行配置各个日志记录器的日志记录级别，下面会有代码示例 代码示例创建项目创建名字为LoggingSimpleDemo的控制台应用，通过nuget引入以下五个包 12345Microsoft.Extensions.Configuration.JsonMicrosoft.Extensions.LoggingMicrosoft.Extensions.Logging.ConsoleMicrosoft.Extensions.Logging.DebugMicrosoft.Extensions.Logging.TraceSource 这里引用Microsoft.Extensions.Configuration.Json这个包是因为记录日志的记录要从配置项中读取 手动创建日志记录器修改Program.Main，代码如下： 1234567891011121314151617181920212223242526272829303132using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; class Program &#123; static void Main(string[] args) &#123; var configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true); var configurationRoot = configurationBuilder.Build(); var serviceCollection = new ServiceCollection(); serviceCollection.AddSingleton&lt;IConfigurationRoot&gt;(p =&gt; configurationRoot); serviceCollection.AddLogging(builder =&gt; &#123; builder.AddConfiguration(configurationRoot.GetSection(\"Logging\")); builder.AddConsole(); &#125;); var serviceProvider = serviceCollection.BuildServiceProvider(); var loggerFactory = serviceProvider.GetService&lt;ILoggerFactory&gt;(); var loggerA = loggerFactory.CreateLogger(\"LoggerA\"); loggerA.LogDebug(2001,\"This is LoggerA -- logDebug\"); loggerA.LogInformation(\"This is LoggerA -- logInformation\"); loggerA.LogError(new Exception(\"LoggerA Error\"),\"This is LoggerA -- LogError\"); &#125; &#125;&#125; Main方法中前三行代码是读取appsettings.json的配置项 new ServiceCollection()是创建一个服务容器，然后将上面读到的服务注册到服务容器中去，有服务容器来管理配置项服务生命周期 serviceCollection.AddLogging()是添加日志服务到服务容器中，builder.AddConfiguration()指的是日志使用的是配置框架里Logging的配置项，builder.AddConsole()是添加一个名字为Console的控制台日志到日志工厂中去 serviceCollection.BuildServiceProvider()是生成一个服务容器实例 serviceProvider.GetService&lt;ILoggerFactory&gt;()是从服务容器中获取一个ILoggerFactory的日志工厂对象 loggerFactory.CreateLogger(&quot;LoggerA&quot;)是创建一个名字为LoggerA的日志记录器 LogDebug、LogInformation、LogError则是记录对应级别的日志 创建配置文件appsettings.json创建文件appsettings.json，具体内容如下： 1234567891011121314&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"LogLevel\": &#123; \"LoggerA\": \"Trace\" &#125; &#125; &#125; &#125; 将appsettings.json拷贝到输出目录(可参照文件配置提供程序里的操作)，运行项目，可以看到控制台打出以下信息： 1234567dbug: LoggerA[2001] This is LoggerA -- logDebuginfo: LoggerA[0] This is LoggerA -- logInformationfail: LoggerA[0] This is LoggerA -- LogErrorSystem.Exception: LoggerA Error 可以自行调整appsettings.json里的LoggerA配置来尝试不同级别的日志记录 依赖注入创建日志记录器创建测试服务类OrderService，具体代码如下： 1234567891011121314151617181920using System;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; public class OrderService &#123; private readonly ILogger&lt;OrderService&gt; _logger; public OrderService(ILogger&lt;OrderService&gt; logger) &#123; _logger = logger; &#125; public void Show() &#123; _logger.LogInformation(\"Show Time &#123;time&#125;\",DateTime.Now); &#125; &#125;&#125; 在Program.Main方法中将OrderService注册进服务容器中，并获取出服务实例，调用Show方法，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; class Program &#123; static void Main(string[] args) &#123; var configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true); var configurationRoot = configurationBuilder.Build(); var serviceCollection = new ServiceCollection(); serviceCollection.AddSingleton&lt;IConfigurationRoot&gt;(p =&gt; configurationRoot); serviceCollection.AddTransient&lt;OrderService&gt;(); serviceCollection.AddLogging(builder =&gt; &#123; builder.AddConfiguration(configurationRoot.GetSection(\"Logging\")); builder.AddConsole(); &#125;); var serviceProvider = serviceCollection.BuildServiceProvider(); var loggerFactory = serviceProvider.GetService&lt;ILoggerFactory&gt;(); var loggerA = loggerFactory.CreateLogger(\"LoggerA\"); loggerA.LogDebug(2001,\"This is LoggerA -- logDebug\"); loggerA.LogInformation(\"This is LoggerA -- logInformation\"); loggerA.LogError(new Exception(\"LoggerA Error\"),\"This is LoggerA -- LogError\"); var orderService = serviceProvider.GetService&lt;OrderService&gt;(); orderService.Show(); Console.ReadKey(); &#125; &#125;&#125; 修改appsettings.json，具体内容如下： 123456789101112131415&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"LogLevel\": &#123; \"LoggerA\": \"Trace\", \"LoggingSimpleDemo.OrderService\": \"Trace\" &#125; &#125; &#125; &#125; 运行项目，可以看到控制台输出日志信息 123456789dbug: LoggerA[2001] This is LoggerA -- logDebuginfo: LoggerA[0] This is LoggerA -- logInformationfail: LoggerA[0] This is LoggerA -- LogErrorSystem.Exception: LoggerA Errorinfo: LoggingSimpleDemo.OrderService[0] Show Time 04&#x2F;02&#x2F;2020 12:06:46 也可以自行调整appsettings.json里的配置来尝试不同级别的日志记录 关于日志作用域日志作用域的使用场景 一个事务包含多条操作时 复杂流程的日志关联时 调用链追踪与请求处理过程对应时 代码演示将上面获取日志记录器的代码注释掉，手动获取一个Program的日志记录器，然后创建日志作用域，具体代码如下 12345678910111213141516171819202122232425262728293031323334353637383940using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; class Program &#123; static void Main(string[] args) &#123; var configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true); var configurationRoot = configurationBuilder.Build(); var serviceCollection = new ServiceCollection(); serviceCollection.AddSingleton&lt;IConfigurationRoot&gt;(p =&gt; configurationRoot); serviceCollection.AddTransient&lt;OrderService&gt;(); serviceCollection.AddLogging(builder =&gt; &#123; builder.AddConfiguration(configurationRoot.GetSection(\"Logging\")); builder.AddConsole(); builder.AddDebug(); &#125;); var serviceProvider = serviceCollection.BuildServiceProvider(); var loggerFactory = serviceProvider.GetService&lt;ILoggerFactory&gt;(); var logger = loggerFactory.CreateLogger&lt;Program&gt;(); using (var scope = logger.BeginScope(\"scopeId=&#123;scopeId&#125;\",Guid.NewGuid())) &#123; logger.LogTrace(\"This is Trace in scope\"); logger.LogInformation(\"This is Information in scope\"); logger.LogWarning(\"This is Warning in scope\"); logger.LogError(\"This is Error in scope\"); &#125; Console.ReadKey(); &#125; &#125;&#125; 在appsettings.json中添加IncludeScopes属性，具体代码如下： 12345678910111213141516&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"IncludeScopes\": true, \"LogLevel\": &#123; \"LoggerA\": \"Trace\", \"LoggingSimpleDemo.OrderService\": \"Trace\" &#125; &#125; &#125; &#125; 运行代码，可以看到控制台打印出类似以下信息： 123456789info: LoggingSimpleDemo.Program[0] &#x3D;&gt; scopeId&#x3D;40c5bb84-584d-4a4c-a56b-f3b66214e1ac This is Information in scopewarn: LoggingSimpleDemo.Program[0] &#x3D;&gt; scopeId&#x3D;40c5bb84-584d-4a4c-a56b-f3b66214e1ac This is Warning in scopefail: LoggingSimpleDemo.Program[0] &#x3D;&gt; scopeId&#x3D;40c5bb84-584d-4a4c-a56b-f3b66214e1ac This is Error in scope 在ASP.NET Core项目中，要启用日志作用域，一样只需要在配置文件中新增IncludeScopes属性即可 注意 日志记录要避免敏感信息，如密码、密钥等 日志记录的时候最好用占位符的方式传参数，可以节省不必要的字符串拼接","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(15) -- 静态文件中间件：前后端分离开发合并部署骚操作","slug":"15.StaticFiles_document","date":"2020-04-02T02:30:00.000Z","updated":"2020-04-03T08:34:52.046Z","comments":true,"path":"2020/04/02/15.StaticFiles_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/15.StaticFiles_document/","excerpt":"","text":"静态文件中间件的能力 代码实现 创建项目 创建测试用的静态文件 默认静态文件中间件 设置默认文件为index.html 支持目录浏览 多目录映射 功能实现 静态文件中间件的能力 支持指定相对路径 支持目录浏览 支持设置默认文档 支持多目录映射 代码实现创建项目创建名字为StaticFilesDemo的ASP.NET Core项目，类型为API 创建测试用的静态文件在根目录创建wwwroot文件夹，参照下面结构进行对应文件创建： 123456wwwroot |-- app.js |-- index.html |-- a |-- a.js |-- index.html 具体代码如下： /wwwroot/index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;静态首页&lt;/title&gt; &lt;script src=\"/app.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是静态首页 wwwroot/index.html&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; /wwwroot/app.js 1alert(\"这是/index.html\") /wwwroot/a/index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"a.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是/a/index.html&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; /wwwroot/a/a.js 1alert(\"这是/a/index.html\") 默认静态文件中间件在Startup.Configure中，将以下代码添加到app.UseHttpsRedirection();下一行 1app.UseStaticFiles(); 运行项目访问https://localhost:5001/index.html和https://localhost:5001/a/index.html可看到静态页面信息 设置默认文件为index.html能起到的效果如下： https://localhost:5001 = https://localhost:5001/index.html https://localhost:5001/a = https://localhost:5001/a/index.html 在app.UseStaticFiles();前面添加以下代码即可： 1app.UseDefaultFiles(); 运行项目访问https://localhost:5001和https://localhost:5001/a可看到静态页面信息 支持目录浏览注释掉默认文件的那个中间件，添加目录浏览的中间件，代码如下： 1app.UseDirectoryBrowser(); 然后在Startup.ConfigureServices配置目录浏览的服务，代码如下： 1services.AddDirectoryBrowser(); 运行项目访问https://localhost:5001，可以看到wwwroot的目录结构 多目录映射当文件支持存在放wwwroot这个文件夹的时候，可以使用静态文件中间件的重载来映射其他文件夹，注释掉上一步的代码，将Startup.Configure修改如下： 1234567891011121314151617181920212223public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseStaticFiles(new StaticFileOptions() &#123; FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), \"file\")) &#125;); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 在项目根目录创建file文件夹，在里面创建个file_page.html文件，随便写点东西，运行项目，访问https://localhost:5001/file_page.html，可以看到静态页内容。注意，如果出现同名文件，则先注册的路径优先权更高，如果需要在访问指定文件夹有指定url地址，可以使用StaticFileOptions对象的RequestPath属性，假设这里的RequestPath=&quot;/myfiles&quot;，则说明要想访问file文件夹的内容，路径前面得加上myfiles，例如https://localhost:5001/myfiles/file_page.html 功能实现有这样一个需求，接口里所有接口的路由都由api开始，即/api/xxx，静态文件放在默认的wwwroot文件夹中，如果访问的地址不是接口，同时也找不到对应的静态文件，则重写到/index.html页面，具体代码如下： 修改WeatherForecastController，将原本的[Route(&quot;[controller]&quot;)]修改为[Route(&quot;/api/[controller]&quot;)] 修改Startup.Configure方法，代码如下： 1234567891011121314151617181920212223242526public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseStaticFiles(); app.MapWhen(context =&gt; &#123; return !context.Request.Path.Value.StartsWith(\"/api\"); &#125;, appBuilder =&gt; &#123; var option = new RewriteOptions(); option.AddRewrite(regex: \".*\", replacement: \"/index.html\", skipRemainingRules: true); appBuilder.UseRewriter(option); appBuilder.UseStaticFiles(); &#125;); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 运行项目，访问https://localhost:5001/api/WeatherForecast，可以看到正常返回接口信息，访问https://localhost:5001/a/index.html可以看到正常访问到/a/index.html文件内容，访问https://localhost:5001/order/get则会返回/index.html文件内容","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":"特基础教程系列","slug":"StepByStep","date":"2020-04-01T14:18:00.000Z","updated":"2020-04-01T16:49:32.267Z","comments":true,"path":"2020/04/01/StepByStep/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/StepByStep/","excerpt":"","text":"Visual Studio Code 下载安装 关于安装扩展插件 关于汉化 平时写静态页流程 todo:常用的vscode插件 todo:常用的vscode代码段 Visual Studio Code下载安装下载地址：https://code.visualstudio.com/，下载之后双击安装即可 关于安装扩展插件如下图，点击左边的插件tab，输入插件名称进行搜索，然后点击install即可进行安装 关于汉化vscode的汉化包使用的也是通过插件的形式来安装，搜索chinese，找到Chinese (Simplified) Language Pack for Visual Studio Code这个插件进行安装，安装完重启即可 平时写静态页流程 一般我会在电脑指定一个盘创建一个文件夹，指定这个文件夹存放自己的源码，无论个人电脑还是公司电脑，比如G盘里创建了repo的文件夹作为我统一管理源码的文件夹 通常自己写代码会分两种级别，一种是为了学习测试而写的demo，一种是比较有一定业务逻辑需求的小项目，所以一般会在repo文件夹下再创建两个文件夹，分别为jiamiao.x.demo和jiamiao.x.project 注意一点，无论是在写demo还是写project，都不要出现类似demo1、demo2、project1、project2这种没意义的名字，以下以我写一段表单demo为例子： 在G:/repo/jiamiao.x.demo的文件夹中创建文件夹form_demo，然后再form_demo文件夹上右键，点击通过Code打开 打开之后可以看到左边有文件夹的目录，当前现在是一片空白，如下图： 接下来在vscode中操作，在FORM_DEMO下方空白处右键，点击新建文件，输入index.html回车，可以看到创建了index.html文件，在右边的编辑区则可以进行编码，只要文件扩展名.html正确，则可以代码高亮和智能提示 当静态页需要引用图片、样式、脚本等，可以在FORM_DEMO下方空白处右键，点击新建文件夹，对应输入image/style/script等名字之后回车即可 写完页面之后，可以右键index.html文件，点击Open In Default Browser(需要安装插件Open in Browser)，直接打开浏览器来查看页面效果，如下图： todo:常用的vscode插件todo:常用的vscode代码段","categories":[{"name":"StepByStep","slug":"StepByStep","permalink":"http://www.dimsum.fun/categories/StepByStep/"}],"tags":[{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://www.dimsum.fun/tags/Visual-Studio-Code/"},{"name":"特基础","slug":"特基础","permalink":"http://www.dimsum.fun/tags/%E7%89%B9%E5%9F%BA%E7%A1%80/"}]},{"title":".NET Core开发实战课程备忘(10) -- 选项框架：服务组件集成配置的最佳实现","slug":"10.Option_document","date":"2020-04-01T05:13:13.000Z","updated":"2020-04-01T09:04:58.074Z","comments":true,"path":"2020/04/01/10.Option_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/10.Option_document/","excerpt":"","text":"选项框架特性 设计原则 建议 代码实现 创建测试服务与测试服务对应的选项 修改appsettings.json 注册服务和选项 获取服务进行测试 选项框架热更新 关键类型 代码示例 IOptionsSnapshot IOptionsMonitor IOptionsMonitor监听配置变动 优化代码结构 动态修改选项值 选项框架特性 支持单例模式读取配置 支持快照 支持配置变更通知 支持运行时动态修改选项值 设计原则 接口分离原则(ISP)，我们的类不应该依赖它不使用的配置 关注点分离(SoC)，不同组件、服务、类之间的配置不应相互依赖或耦合 建议 为我们的服务设计XXXOptions 使用IOptions&lt;XXXOptions&gt;、IOptionsSnapshot&lt;XXXOptions&gt;、IOptionsMonitor&lt;XXXOptions&gt;作为服务构造函数的参数 代码实现创建名为OptionsDemo的ASP.NET Core项目，类型为API 创建测试服务与测试服务对应的选项创建OrderService.cs为了方便测试，这里将IOrderService、OrderService、OrderServiceOption都放在OrderService.cs文件中，具体代码如下： 12345678910111213141516171819202122232425262728using Microsoft.Extensions.Options;namespace OptionsDemo.Services&#123; public interface IOrderService &#123; int ShowMaxOrderCount(); &#125; public class OrderService:IOrderService &#123; private readonly IOptions&lt;OrderServiceOptions&gt; _options; public OrderService(IOptions&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.Value.MaxOrderCount; &#125; &#125; public class OrderServiceOptions &#123; public int MaxOrderCount &#123; get; set; &#125; = 100; &#125;&#125; 修改appsettings.json将项目中的appsettings.json的内容修改如下： 12345678910111213&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125; &#125;, \"AllowedHosts\": \"*\", \"OrderService\": &#123; \"MaxOrderCount\": 400 &#125; &#125; 注册服务和选项在Startup.ConfigureServices中添加以下代码： 12services.Configure&lt;OrderServiceOptions&gt;(Configuration.GetSection(\"OrderService\"));services.AddScoped&lt;IOrderService, OrderService&gt;(); 获取服务进行测试修改WeatherForecastController.Get方法，具体代码如下： 123456[HttpGet]public int Get([FromServices]IOrderService orderService)&#123; Console.WriteLine($\"orderService.ShowMaxOrderCount:&#123;orderService.ShowMaxOrderCount()&#125;\"); return 1;&#125; 运行项目，可以访问/WeatherForecast，可以看到控制台打印出以下信息： 1orderService.ShowMaxOrderCount:400 这里如果在项目运行时修改appsettings.json里配置项的值，重新访问/WeatherForecast地址，会发现控制台打印出来的值不会变，还依旧是400，这里就需要使用到下面的热更新。 选项框架热更新关键类型 单例服务(Singleton)使用IOptionsMonitor&lt;out TOptions&gt; 范围作用域类型(Scope)使用IOptionsSnapshot&lt;out TOptions&gt; 代码示例IOptionsSnapshot上个示例对OrderService注册的是Scope服务，所以这里先测试Scope对应的IOptionsSnapshot，将OrderService构造函数获取服务的类型修改为IOptionsSnapshot&lt;OrderServiceOptions&gt;，最终修改后OrderService类的代码如下： 123456789101112public class OrderService:IOrderService&#123; private readonly IOptionsSnapshot&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsSnapshot&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.Value.MaxOrderCount; &#125;&#125; 运行代码，访问/WeatherForecast，发现现在打印出来的是appsettings.json现有的值，对该配置项进行修改，保存之后重新访问/WeatherForecast，可以发现获取到的是新的值 IOptionsMonitor将OrderService构造函数获取服务的类型修改为IOptionsMonitor&lt;OrderServiceOptions&gt;，最终修改后OrderService类的代码如下： 123456789101112public class OrderService:IOrderService&#123; private readonly IOptionsMonitor&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsMonitor&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.CurrentValue.MaxOrderCount; &#125;&#125; 在Startup.ConfigureServices方法中将OrderService注册为单例模式，代码如下： 1services.AddSingleton&lt;IOrderService, OrderService&gt;(); 运行代码，访问/WeatherForecast，发现现在打印出来的是appsettings.json现有的值，对该配置项进行修改，保存之后重新访问/WeatherForecast，可以发现获取到的是新的值 IOptionsMonitor监听配置变动通过IOptionsMonitor对象的OnChange方法来注册配置变动操作，只需要在获取对象后注册相应操作即可，具体代码如下： 12345678910111213141516public class OrderService:IOrderService&#123; private readonly IOptionsMonitor&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsMonitor&lt;OrderServiceOptions&gt; options) &#123; _options = options; this._options.OnChange(changedOptions =&gt; &#123; Console.WriteLine($\"配置发生了变化,新值为:&#123;changedOptions.MaxOrderCount&#125;\"); &#125;); &#125; public int ShowMaxOrderCount() &#123; return _options.CurrentValue.MaxOrderCount; &#125;&#125; 运行代码，修改appsettings.json的值，就可以看到控制台打印出类似以下信息： 1配置发生了变化,新值为:100 优化代码结构在开发中经常会出现服务与选项一起注册的情况，为了优化代码结构，一般会为统一将一个服务的注册放到IServiceCollection的扩展方法中去。创建OrderServiceExtensions.cs，具体代码如下： 123456789101112131415using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.Configure&lt;OrderServiceOptions&gt;(configuration.GetSection(\"OrderService\")); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 将Startup.ConfigureServices修改后代码如下： 12345public void ConfigureServices(IServiceCollection services)&#123; services.AddOrderService(Configuration); services.AddControllers();&#125; 运行之后可发现效果与上面一致 动态修改选项值在注入选项之后，可动态对选项的值进行操作，这里以为MaxOrderCount的值增加100为例，修改OrderServiceExtensions，代码如下： 12345678910111213141516171819using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.Configure&lt;OrderServiceOptions&gt;(configuration.GetSection(\"OrderService\")); services.PostConfigure&lt;OrderServiceOptions&gt;(options =&gt; &#123; options.MaxOrderCount += 100; &#125;); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 运行代码，可发现获得到的值比appsettings.json里的值增加100","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(9) -- 自定义配置数据源：低成本实现定制配置方案","slug":"9.ConfigurationCustom_document","date":"2020-04-01T04:12:12.000Z","updated":"2020-04-01T09:04:52.857Z","comments":true,"path":"2020/04/01/9.ConfigurationCustom_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/9.ConfigurationCustom_document/","excerpt":"","text":"拓展步骤 代码实现 创建项目 创建自定义数据源Provider 创建自定义数据源Source 创建IConfigurationBuilder扩展方法 引用自定义配置源并监听配置源变化 拓展步骤 实现IConfigurationSource 实现IConfigurationProvider 实现AddXXX扩展方法 代码实现创建项目创建名字为ConfigurationCustomDemo的控制台应用，通过nuget引入以下两个包： 12Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.Abstractions 创建自定义数据源Provider创建MyConfigurationProvider，继承ConfigurationProvider这个抽象类，调用基类的OnReload方法能触发重新加载配置，这里因为要自动修改和触发配置，所以这个类里用了Timer对象来模拟配置变化的操作，具体代码如下： 123456789101112131415161718192021222324252627282930313233using System;using System.Timers;using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; internal class MyConfigurationProvider:ConfigurationProvider &#123; private Timer timer; public MyConfigurationProvider():base() &#123; timer = new Timer(); timer.Elapsed += Timer_Elapsed; timer.Interval = 3000; timer.Start(); &#125; private void Timer_Elapsed(object sender, ElapsedEventArgs e) &#123; Load(true); &#125; void Load(bool reload) &#123; this.Data[\"lastTime\"] = DateTime.Now.ToString(); if (reload) &#123; base.OnReload(); &#125; &#125; &#125;&#125; 创建自定义数据源Source创建MyConfigurationSource，实现IConfigurationSource接口，在Build方法直接返回上面创建的Provider，具体代码如下： 123456789101112using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; internal class MyConfigurationSource:IConfigurationSource &#123; public IConfigurationProvider Build(IConfigurationBuilder builder) &#123; return new MyConfigurationProvider(); &#125; &#125;&#125; 创建IConfigurationBuilder扩展方法可以看到上面两个类的都是用internal的访问修饰符，这是因为一般在Provider和Source都是通过拓展方法来调用，而不会将自己直接暴露被调用者，所以接下来要创建一个IConfigurationBuilder的扩展方法，代码如下： 12345678910111213using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; public static class MyConfigurationBuilderExtension &#123; public static IConfigurationBuilder AddMyConfiguration(this IConfigurationBuilder builder) &#123; builder.Add(new MyConfigurationSource()); return builder; &#125; &#125;&#125; 引用自定义配置源并监听配置源变化Program.Main方法修改如下： 12345678910111213141516171819202122232425using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.Primitives;namespace ConfigurationCustomDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddMyConfiguration(); var configurationRoot = builder.Build(); ChangeToken.OnChange(() =&gt; configurationRoot.GetReloadToken(), () =&gt; &#123; var lastTime = configurationRoot[\"lastTime\"]; Console.WriteLine($\"lastTime=&#123;lastTime&#125;\"); Console.WriteLine(\"======\"); &#125;); Console.ReadKey(); &#125; &#125;&#125; 运行代码，可以看到控制台3秒钟打印一次当前时间的效果","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(8) -- 文件配置提供程序：自由选择配置的格式","slug":"8.ConfigurationFile_document","date":"2020-04-01T03:11:11.000Z","updated":"2020-04-01T09:04:48.264Z","comments":true,"path":"2020/04/01/8.ConfigurationFile_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/8.ConfigurationFile_document/","excerpt":"","text":"文件配置提供程序 特性 代码示例 创建项目 创建测试配置项appSetting.json 获取appSetting.json里的配置 获取ini配置文件 文件配置提供程序读取不同文件格式或从不同位置读取配置 Microsoft.Extensions.Configuration.Ini Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.UserSecrets Microsoft.Extensions.Configuration.Xml 特性 指定文件可选、必选 指定是否监视文件的变更 代码示例创建项目创建名字为ConfigurationFileDemo的控制台应用，通过nuget引入以下四个包： 1234Microsoft.Extensions.Configuration.IniMicrosoft.Extensions.Configuration.JsonMicrosoft.Extensions.Configuration.UserSecretsMicrosoft.Extensions.Configuration.Xml 这里不用引用Microsoft.Extensions.Configuration和Microsoft.Extensions.Configuration.Abstractions两个基础包，是因为其他包已经包含了两个基础包 创建测试配置项appSetting.json在项目根目录创建appSetting.json文件，内容如下： 123456&#123; \"Key1\": \"value1\", \"Key2\": \"value2\", \"Key3\": false, \"Key4\": 10&#125; 在Visual Studio 2019中通过右键appSetting.json文件-&gt;属性-复制到输出目录选择如果较新则复制 在Visual Studio Code中通过修改ConfigurationFileDemo.csproj文件，新增文件输出到配置，具体代码如下：1234567891011121314151617&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;&lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;&lt;/PropertyGroup&gt;&lt;ItemGroup&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Ini\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Json\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.UserSecrets\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Xml\" Version=\"3.1.3\" /&gt;&lt;/ItemGroup&gt;&lt;ItemGroup&gt; &lt;None Update=\"appSetting.json\"&gt; &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt; &lt;/None&gt;&lt;/ItemGroup&gt;&lt;/Project&gt; 获取appSetting.json里的配置修改Program.Main方法，内容如下：12345678910111213141516171819202122232425using System;using Microsoft.Extensions.Configuration;namespace ConfigurationFileDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddJsonFile(\"appSetting.json\",optional:false,reloadOnChange:true); var configurationRoot = builder.Build(); Console.WriteLine(\"开始了。。输入随意字符串返回配置项，直接回车推出\"); var isStop = Console.ReadLine(); while (!string.IsNullOrEmpty(isStop)) &#123; Console.WriteLine($\"Key1=&#123;configurationRoot[\"Key1\"]&#125;\"); Console.WriteLine($\"Key2=&#123;configurationRoot[\"Key2\"]&#125;\"); Console.WriteLine($\"Key3=&#123;configurationRoot[\"Key3\"]&#125;\"); Console.WriteLine($\"Key4=&#123;configurationRoot[\"Key4\"]&#125;\"); Console.WriteLine(\"=====分割线=====\"); isStop = Console.ReadLine(); &#125; &#125; &#125;&#125; optional：表示文件是否可选，false=没文件会报错，true=可以没有文件 reloadOnChange：表示监视配置文件的变动，配置文件变动会进行重新读取 运行代码，然后在控制台随意输入字符串回车，可以看到以下信息： 12345Key1&#x3D;value1Key2&#x3D;value2Key3&#x3D;FalseKey4&#x3D;10&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 进入项目根目录/bin/Debug/netcoreapp3.1里，找到appSetting.json文件，修改里面的配置值，再回到控制台输入随意字符串回车，可以看到打印出来的值已经有所变化 获取ini配置文件在项目根目录创建appSetting.ini文件，内容如下： 12Key4=Hello worldKey5=value5 类似appSetting.json那样配置拷贝到输出目录，修改Program.Main方法，在AddJsonFile方法下面新增添加ini配置源的调用，代码如下： 1builder.AddIniFile(\"appSetting.ini\", optional: false, reloadOnChange: true); 运行代码，然后在控制台输入随意字符串回车，可以看到以下信息： 123456Key1&#x3D;value1Key2&#x3D;value2Key3&#x3D;FalseKey4&#x3D;Hello worldKey5&#x3D;value5&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 可以看到ini文件里的配置已经加载进去了，同时后面加载的配置项如果与前面已经加载的配置项名称一致，会覆盖掉前面加载的配置项","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(7) -- 环境变量配置提供程序：容器环境下配置注入的最佳途径","slug":"7.ConfigurationEnvironmentVariables_Document","date":"2020-04-01T02:10:10.000Z","updated":"2020-04-01T09:04:43.281Z","comments":true,"path":"2020/04/01/7.ConfigurationEnvironmentVariables_Document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/7.ConfigurationEnvironmentVariables_Document/","excerpt":"","text":"使用场景 在Docker中运行 在Kubernetes中运行 需要设置ASP.NET Core的一些内置特殊配置时 特性 对应配置的分层键，支持用双下划线”--“代替”:“ 支持根据前缀加载 代码示例创建项目创建名字为ConfigurationEnvironmentVariablesDemo的控制台应用，通过nuget引入以下三个包： 123Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.AbstractionsMicrosoft.Extensions.Configuration.EnvironmentVariables 获取环境变量配置修改Program.Main方法，代码如下： 123456789101112131415161718using System;using Microsoft.Extensions.Configuration;namespace ConfigurationEnvironmentVariablesDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddEnvironmentVariables(); var configurationRoot = builder.Build(); Console.WriteLine($\"KEY3=&#123;configurationRoot[\"KEY3\"]&#125;\"); var section = configurationRoot.GetSection(\"SECTIONA\"); Console.WriteLine($\"SECTIONA:KEY2=&#123;section[\"KEY2\"]&#125;\"); &#125; &#125;&#125; 配置测试参数： 在Visual Studio 2019中，可以右键项目名称-&gt;属性-&gt;调试-&gt;环境变量中添加以下内容：12345&quot;DIMSUM_KEY1&quot;: &quot;dimsum_value1&quot;,&quot;KEY3&quot;: &quot;value3&quot;,&quot;KEY1&quot;: &quot;value1&quot;,&quot;SECTIONA__KEY2&quot;: &quot;value2&quot;,&quot;KEY4&quot;: &quot;value4&quot; 在Visual Studio Code中，可以编辑launchSettings.json文件，新增environmentVariables字段，具体代码如下:1234567891011121314&#123; \"profiles\": &#123; \"ConfigurationEnvironmentVariablesDemo\": &#123; \"commandName\": \"Project\", \"environmentVariables\": &#123; \"DIMSUM_KEY1\": \"dimsum_value1\", \"KEY3\": \"value3\", \"KEY1\": \"value1\", \"SECTIONA__KEY2\": \"value2\", \"KEY4\": \"value4\" &#125; &#125; &#125;&#125; 运行项目，会得到以下信息：12KEY3&#x3D;value3SECTIONA:KEY2&#x3D;value2 前缀过滤过滤指定前缀的环境变量，具体代码如下： 12345678910111213141516using System;using Microsoft.Extensions.Configuration;namespace ConfigurationEnvironmentVariablesDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddEnvironmentVariables(\"DIMSUM_\"); var configurationRoot = builder.Build(); Console.WriteLine($\"DIMSUM_KEY1=&#123;configurationRoot[\"KEY1\"]&#125;\"); &#125; &#125;&#125; 运行项目可以得到以下信息 1DIMSUM_KEY1&#x3D;dimsum_value1 说明这里获取到的是DIMSUM_KEY1这个配置，而非KEY这个配置","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(9) -- 自定义配置数据源：低成本实现定制配置方案","slug":"ConfigurationCustom_document","date":"2020-03-31T16:00:00.000Z","updated":"2020-04-01T08:54:13.648Z","comments":true,"path":"2020/04/01/ConfigurationCustom_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/ConfigurationCustom_document/","excerpt":"","text":"拓展步骤 代码实现 创建项目 创建自定义数据源Provider 创建自定义数据源Source 创建IConfigurationBuilder扩展方法 引用自定义配置源并监听配置源变化 拓展步骤 实现IConfigurationSource 实现IConfigurationProvider 实现AddXXX扩展方法 代码实现创建项目创建名字为ConfigurationCustomDemo的控制台应用，通过nuget引入以下两个包： 12Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.Abstractions 创建自定义数据源Provider创建MyConfigurationProvider，继承ConfigurationProvider这个抽象类，调用基类的OnReload方法能触发重新加载配置，这里因为要自动修改和触发配置，所以这个类里用了Timer对象来模拟配置变化的操作，具体代码如下： 123456789101112131415161718192021222324252627282930313233using System;using System.Timers;using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; internal class MyConfigurationProvider:ConfigurationProvider &#123; private Timer timer; public MyConfigurationProvider():base() &#123; timer = new Timer(); timer.Elapsed += Timer_Elapsed; timer.Interval = 3000; timer.Start(); &#125; private void Timer_Elapsed(object sender, ElapsedEventArgs e) &#123; Load(true); &#125; void Load(bool reload) &#123; this.Data[\"lastTime\"] = DateTime.Now.ToString(); if (reload) &#123; base.OnReload(); &#125; &#125; &#125;&#125; 创建自定义数据源Source创建MyConfigurationSource，实现IConfigurationSource接口，在Build方法直接返回上面创建的Provider，具体代码如下： 123456789101112using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; internal class MyConfigurationSource:IConfigurationSource &#123; public IConfigurationProvider Build(IConfigurationBuilder builder) &#123; return new MyConfigurationProvider(); &#125; &#125;&#125; 创建IConfigurationBuilder扩展方法可以看到上面两个类的都是用internal的访问修饰符，这是因为一般在Provider和Source都是通过拓展方法来调用，而不会将自己直接暴露被调用者，所以接下来要创建一个IConfigurationBuilder的扩展方法，代码如下： 12345678910111213using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; public static class MyConfigurationBuilderExtension &#123; public static IConfigurationBuilder AddMyConfiguration(this IConfigurationBuilder builder) &#123; builder.Add(new MyConfigurationSource()); return builder; &#125; &#125;&#125; 引用自定义配置源并监听配置源变化Program.Main方法修改如下： 12345678910111213141516171819202122232425using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.Primitives;namespace ConfigurationCustomDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddMyConfiguration(); var configurationRoot = builder.Build(); ChangeToken.OnChange(() =&gt; configurationRoot.GetReloadToken(), () =&gt; &#123; var lastTime = configurationRoot[\"lastTime\"]; Console.WriteLine($\"lastTime=&#123;lastTime&#125;\"); Console.WriteLine(\"======\"); &#125;); Console.ReadKey(); &#125; &#125;&#125; 运行代码，可以看到控制台3秒钟打印一次当前时间的效果","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(8) -- 文件配置提供程序：自由选择配置的格式","slug":"ConfigurationFile_document","date":"2020-03-31T16:00:00.000Z","updated":"2020-04-01T08:54:13.649Z","comments":true,"path":"2020/04/01/ConfigurationFile_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/ConfigurationFile_document/","excerpt":"","text":"文件配置提供程序 特性 代码示例 创建项目 创建测试配置项appSetting.json 获取appSetting.json里的配置 获取ini配置文件 配置热更新操作 将配置项绑定到强类型上 引入绑定包 创建测试类 将配置项绑定到指定对象上 文件配置提供程序读取不同文件格式或从不同位置读取配置 Microsoft.Extensions.Configuration.Ini Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.UserSecrets Microsoft.Extensions.Configuration.Xml 特性 指定文件可选、必选 指定是否监视文件的变更 代码示例创建项目创建名字为ConfigurationFileDemo的控制台应用，通过nuget引入以下四个包： 1234Microsoft.Extensions.Configuration.IniMicrosoft.Extensions.Configuration.JsonMicrosoft.Extensions.Configuration.UserSecretsMicrosoft.Extensions.Configuration.Xml 这里不用引用Microsoft.Extensions.Configuration和Microsoft.Extensions.Configuration.Abstractions两个基础包，是因为其他包已经包含了两个基础包 创建测试配置项appSetting.json在项目根目录创建appSetting.json文件，内容如下： 123456&#123; \"Key1\": \"value1\", \"Key2\": \"value2\", \"Key3\": false, \"Key4\": 10&#125; 在Visual Studio 2019中通过右键appSetting.json文件-&gt;属性-复制到输出目录选择如果较新则复制 在Visual Studio Code中通过修改ConfigurationFileDemo.csproj文件，新增文件输出到配置，具体代码如下：1234567891011121314151617&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;&lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;&lt;/PropertyGroup&gt;&lt;ItemGroup&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Ini\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Json\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.UserSecrets\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Xml\" Version=\"3.1.3\" /&gt;&lt;/ItemGroup&gt;&lt;ItemGroup&gt; &lt;None Update=\"appSetting.json\"&gt; &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt; &lt;/None&gt;&lt;/ItemGroup&gt;&lt;/Project&gt; 获取appSetting.json里的配置修改Program.Main方法，内容如下：12345678910111213141516171819202122232425using System;using Microsoft.Extensions.Configuration;namespace ConfigurationFileDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddJsonFile(\"appSetting.json\",optional:false,reloadOnChange:true); var configurationRoot = builder.Build(); Console.WriteLine(\"开始了。。输入随意字符串返回配置项，直接回车推出\"); var isStop = Console.ReadLine(); while (!string.IsNullOrEmpty(isStop)) &#123; Console.WriteLine($\"Key1=&#123;configurationRoot[\"Key1\"]&#125;\"); Console.WriteLine($\"Key2=&#123;configurationRoot[\"Key2\"]&#125;\"); Console.WriteLine($\"Key3=&#123;configurationRoot[\"Key3\"]&#125;\"); Console.WriteLine($\"Key4=&#123;configurationRoot[\"Key4\"]&#125;\"); Console.WriteLine(\"=====分割线=====\"); isStop = Console.ReadLine(); &#125; &#125; &#125;&#125; optional：表示文件是否可选，false=没文件会报错，true=可以没有文件 reloadOnChange：表示监视配置文件的变动，配置文件变动会进行重新读取 运行代码，然后在控制台随意输入字符串回车，可以看到以下信息： 12345Key1&#x3D;value1Key2&#x3D;value2Key3&#x3D;FalseKey4&#x3D;10&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 进入项目根目录/bin/Debug/netcoreapp3.1里，找到appSetting.json文件，修改里面的配置值，再回到控制台输入随意字符串回车，可以看到打印出来的值已经有所变化 获取ini配置文件在项目根目录创建appSetting.ini文件，内容如下： 12Key4=Hello worldKey5=value5 类似appSetting.json那样配置拷贝到输出目录，修改Program.Main方法，在AddJsonFile方法下面新增添加ini配置源的调用，代码如下： 1builder.AddIniFile(\"appSetting.ini\", optional: false, reloadOnChange: true); 运行代码，然后在控制台输入随意字符串回车，可以看到以下信息： 123456Key1&#x3D;value1Key2&#x3D;value2Key3&#x3D;FalseKey4&#x3D;Hello worldKey5&#x3D;value5&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 可以看到ini文件里的配置已经加载进去了，同时后面加载的配置项如果与前面已经加载的配置项名称一致，会覆盖掉前面加载的配置项 配置热更新操作这里只用appSetting.json文件变更来触发热更新操作作为示例，将Program.Main修改为加载appSetting.json，并注册配置更新操作代码，具体代码如下： 1234567891011121314151617181920212223242526272829using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.Primitives;namespace ConfigurationFileDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddJsonFile(\"appSetting.json\", optional: false, reloadOnChange: true); var configurationRoot = builder.Build(); Console.WriteLine($\"Key1=&#123;configurationRoot[\"Key1\"]&#125;\"); Console.WriteLine($\"Key2=&#123;configurationRoot[\"Key2\"]&#125;\"); Console.WriteLine($\"Key3=&#123;configurationRoot[\"Key3\"]&#125;\"); ChangeToken.OnChange(() =&gt; configurationRoot.GetReloadToken(), () =&gt; &#123; Console.WriteLine(\"配置发生了变化\"); Console.WriteLine($\"Key1=&#123;configurationRoot[\"Key1\"]&#125;\"); Console.WriteLine($\"Key2=&#123;configurationRoot[\"Key2\"]&#125;\"); Console.WriteLine($\"Key3=&#123;configurationRoot[\"Key3\"]&#125;\"); &#125;); Console.ReadKey(); &#125; &#125;&#125; 运行代码，控制台打出现有配置项的键值对，然后到/bin/Debug/netcoreapp3.1里修改appSetting.json里配置项的值，可以看到控制台打出了新配置项的键值对 将配置项绑定到强类型上 支持将配置值绑定到已有对象 支持将配置值绑定到私有属性上 引入绑定包使用nuget引入以下包 1Microsoft.Extensions.Configuration.Binder 创建测试类创建测试类Config，具体代码如下: 1234567class Config&#123; public string Key1 &#123; get; set; &#125; public bool Key3 &#123; get; set; &#125; public int Key4 &#123; get; set; &#125; public string Key5 &#123; get; private set; &#125;&#125; 将配置项绑定到指定对象上修改Program.Main方法，具体代码如下： 123456789101112131415161718192021222324252627282930class Program&#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddJsonFile(\"appSetting.json\", optional: false, reloadOnChange: true); var configurationRoot = builder.Build(); var config = new Config() &#123; Key1 = \"default1\", Key3 = false, Key4 = 0 &#125;; configurationRoot.Bind(config); Console.WriteLine($\"Key1=&#123;config.Key1&#125;\"); Console.WriteLine($\"Key3=&#123;config.Key3&#125;\"); Console.WriteLine($\"Key4=&#123;config.Key4&#125;\"); Console.WriteLine($\"Key5=&#123;config.Key5&#125;\"); Console.WriteLine(\"======\"); configurationRoot.GetSection(\"OrderService\").Bind(config, options =&gt; &#123; options.BindNonPublicProperties = true; &#125;); Console.WriteLine($\"Key1=&#123;config.Key1&#125;\"); Console.WriteLine($\"Key3=&#123;config.Key3&#125;\"); Console.WriteLine($\"Key4=&#123;config.Key4&#125;\"); Console.WriteLine($\"Key5=&#123;config.Key5&#125;\"); &#125;&#125; appSetting.json修改如下： 123456789101112131415&#123; \"Key1\": \"value1\", \"Key2\": \"value2\", \"Key3\": true, \"Key4\": 10, \"key5\": \"level1\" , \"OrderService\": &#123; \"Key1\": \"order_value1\", \"Key2\": \"order_value2\", \"Key3\": false, \"Key4\": 200, \"key5\": \"order_value5\" &#125; &#125; 运行代码，控制台会打印出以下信息： 123456789Key1&#x3D;value1Key3&#x3D;TrueKey4&#x3D;10Key5&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Key1&#x3D;order_value1Key3&#x3D;FalseKey4&#x3D;200Key5&#x3D;order_value5 通过IConfigurationRoot的Bind方法将配置项绑定到指定对象上，如果是多个层级，则通过IConfigurationRoot的GetSection筛选出指定的层，再绑定到指定对象上，绑定时可以通过设定BindNonPublicProperties这个属性来将配置型绑定到私有属性上，默认配置项是不绑定到私有属性的","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(7) -- 环境变量配置提供程序：容器环境下配置注入的最佳途径","slug":"ConfigurationEnvironmentVariables_Document","date":"2020-03-31T16:00:00.000Z","updated":"2020-03-31T17:11:39.269Z","comments":true,"path":"2020/04/01/ConfigurationEnvironmentVariables_Document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/ConfigurationEnvironmentVariables_Document/","excerpt":"","text":"使用场景 在Docker中运行 在Kubernetes中运行 需要设置ASP.NET Core的一些内置特殊配置时 特性 对应配置的分层键，支持用双下划线”--“代替”:“ 支持根据前缀加载 代码示例创建项目创建名字为ConfigurationEnvironmentVariablesDemo的控制台应用，通过nuget引入以下三个包： 123Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.AbstractionsMicrosoft.Extensions.Configuration.EnvironmentVariables 获取环境变量配置修改Program.Main方法，代码如下： 123456789101112131415161718using System;using Microsoft.Extensions.Configuration;namespace ConfigurationEnvironmentVariablesDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddEnvironmentVariables(); var configurationRoot = builder.Build(); Console.WriteLine($\"KEY3=&#123;configurationRoot[\"KEY3\"]&#125;\"); var section = configurationRoot.GetSection(\"SECTIONA\"); Console.WriteLine($\"SECTIONA:KEY2=&#123;section[\"KEY2\"]&#125;\"); &#125; &#125;&#125; 配置测试参数： 在Visual Studio 2019中，可以右键项目名称-&gt;属性-&gt;调试-&gt;环境变量中添加以下内容：12345&quot;DIMSUM_KEY1&quot;: &quot;dimsum_value1&quot;,&quot;KEY3&quot;: &quot;value3&quot;,&quot;KEY1&quot;: &quot;value1&quot;,&quot;SECTIONA__KEY2&quot;: &quot;value2&quot;,&quot;KEY4&quot;: &quot;value4&quot; 在Visual Studio Code中，可以编辑launchSettings.json文件，新增environmentVariables字段，具体代码如下:1234567891011121314&#123; \"profiles\": &#123; \"ConfigurationEnvironmentVariablesDemo\": &#123; \"commandName\": \"Project\", \"environmentVariables\": &#123; \"DIMSUM_KEY1\": \"dimsum_value1\", \"KEY3\": \"value3\", \"KEY1\": \"value1\", \"SECTIONA__KEY2\": \"value2\", \"KEY4\": \"value4\" &#125; &#125; &#125;&#125; 运行项目，会得到以下信息：12KEY3&#x3D;value3SECTIONA:KEY2&#x3D;value2 前缀过滤过滤指定前缀的环境变量，具体代码如下： 12345678910111213141516using System;using Microsoft.Extensions.Configuration;namespace ConfigurationEnvironmentVariablesDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddEnvironmentVariables(\"DIMSUM_\"); var configurationRoot = builder.Build(); Console.WriteLine($\"DIMSUM_KEY1=&#123;configurationRoot[\"KEY1\"]&#125;\"); &#125; &#125;&#125; 运行项目可以得到以下信息 1DIMSUM_KEY1&#x3D;dimsum_value1 说明这里获取到的是DIMSUM_KEY1这个配置，而非KEY这个配置","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(10) -- 选项框架：服务组件集成配置的最佳实现","slug":"Option_document","date":"2020-03-31T16:00:00.000Z","updated":"2020-04-01T16:49:32.266Z","comments":true,"path":"2020/04/01/Option_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/Option_document/","excerpt":"","text":"选项框架特性 设计原则 建议 代码实现 创建测试服务与测试服务对应的选项 修改appsettings.json 注册服务和选项 获取服务进行测试 选项框架热更新 关键类型 代码示例 IOptionsSnapshot IOptionsMonitor IOptionsMonitor监听配置变动 优化代码结构 动态修改选项值 为选项添加验证逻辑 三种验证方法 代码示例 直接注册验证 实现IValidateOptions&lt;TOptions&gt; 使用属性标签的方式 选项框架特性 支持单例模式读取配置 支持快照 支持配置变更通知 支持运行时动态修改选项值 设计原则 接口分离原则(ISP)，我们的类不应该依赖它不使用的配置 关注点分离(SoC)，不同组件、服务、类之间的配置不应相互依赖或耦合 建议 为我们的服务设计XXXOptions 使用IOptions&lt;XXXOptions&gt;、IOptionsSnapshot&lt;XXXOptions&gt;、IOptionsMonitor&lt;XXXOptions&gt;作为服务构造函数的参数 代码实现创建名为OptionsDemo的ASP.NET Core项目，类型为API 创建测试服务与测试服务对应的选项创建OrderService.cs为了方便测试，这里将IOrderService、OrderService、OrderServiceOption都放在OrderService.cs文件中，具体代码如下： 12345678910111213141516171819202122232425262728using Microsoft.Extensions.Options;namespace OptionsDemo.Services&#123; public interface IOrderService &#123; int ShowMaxOrderCount(); &#125; public class OrderService:IOrderService &#123; private readonly IOptions&lt;OrderServiceOptions&gt; _options; public OrderService(IOptions&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.Value.MaxOrderCount; &#125; &#125; public class OrderServiceOptions &#123; public int MaxOrderCount &#123; get; set; &#125; = 100; &#125;&#125; 修改appsettings.json将项目中的appsettings.json的内容修改如下： 12345678910111213&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125; &#125;, \"AllowedHosts\": \"*\", \"OrderService\": &#123; \"MaxOrderCount\": 400 &#125; &#125; 注册服务和选项在Startup.ConfigureServices中添加以下代码： 12services.Configure&lt;OrderServiceOptions&gt;(Configuration.GetSection(\"OrderService\"));services.AddScoped&lt;IOrderService, OrderService&gt;(); 获取服务进行测试修改WeatherForecastController.Get方法，具体代码如下： 123456[HttpGet]public int Get([FromServices]IOrderService orderService)&#123; Console.WriteLine($\"orderService.ShowMaxOrderCount:&#123;orderService.ShowMaxOrderCount()&#125;\"); return 1;&#125; 运行项目，可以访问/WeatherForecast，可以看到控制台打印出以下信息： 1orderService.ShowMaxOrderCount:400 这里如果在项目运行时修改appsettings.json里配置项的值，重新访问/WeatherForecast地址，会发现控制台打印出来的值不会变，还依旧是400，这里就需要使用到下面的热更新。 选项框架热更新关键类型 单例服务(Singleton)使用IOptionsMonitor&lt;out TOptions&gt; 范围作用域类型(Scope)使用IOptionsSnapshot&lt;out TOptions&gt; 代码示例IOptionsSnapshot上个示例对OrderService注册的是Scope服务，所以这里先测试Scope对应的IOptionsSnapshot，将OrderService构造函数获取服务的类型修改为IOptionsSnapshot&lt;OrderServiceOptions&gt;，最终修改后OrderService类的代码如下： 123456789101112public class OrderService:IOrderService&#123; private readonly IOptionsSnapshot&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsSnapshot&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.Value.MaxOrderCount; &#125;&#125; 运行代码，访问/WeatherForecast，发现现在打印出来的是appsettings.json现有的值，对该配置项进行修改，保存之后重新访问/WeatherForecast，可以发现获取到的是新的值 IOptionsMonitor将OrderService构造函数获取服务的类型修改为IOptionsMonitor&lt;OrderServiceOptions&gt;，最终修改后OrderService类的代码如下： 123456789101112public class OrderService:IOrderService&#123; private readonly IOptionsMonitor&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsMonitor&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.CurrentValue.MaxOrderCount; &#125;&#125; 在Startup.ConfigureServices方法中将OrderService注册为单例模式，代码如下： 1services.AddSingleton&lt;IOrderService, OrderService&gt;(); 运行代码，访问/WeatherForecast，发现现在打印出来的是appsettings.json现有的值，对该配置项进行修改，保存之后重新访问/WeatherForecast，可以发现获取到的是新的值 IOptionsMonitor监听配置变动通过IOptionsMonitor对象的OnChange方法来注册配置变动操作，只需要在获取对象后注册相应操作即可，具体代码如下： 12345678910111213141516public class OrderService:IOrderService&#123; private readonly IOptionsMonitor&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsMonitor&lt;OrderServiceOptions&gt; options) &#123; _options = options; this._options.OnChange(changedOptions =&gt; &#123; Console.WriteLine($\"配置发生了变化,新值为:&#123;changedOptions.MaxOrderCount&#125;\"); &#125;); &#125; public int ShowMaxOrderCount() &#123; return _options.CurrentValue.MaxOrderCount; &#125;&#125; 运行代码，修改appsettings.json的值，就可以看到控制台打印出类似以下信息： 1配置发生了变化,新值为:100 优化代码结构在开发中经常会出现服务与选项一起注册的情况，为了优化代码结构，一般会为统一将一个服务的注册放到IServiceCollection的扩展方法中去。创建OrderServiceExtensions.cs，具体代码如下： 123456789101112131415using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.Configure&lt;OrderServiceOptions&gt;(configuration.GetSection(\"OrderService\")); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 将Startup.ConfigureServices修改后代码如下： 12345public void ConfigureServices(IServiceCollection services)&#123; services.AddOrderService(Configuration); services.AddControllers();&#125; 运行之后可发现效果与上面一致 动态修改选项值在注入选项之后，可动态对选项的值进行操作，这里以为MaxOrderCount的值增加100为例，修改OrderServiceExtensions，代码如下： 12345678910111213141516171819using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.Configure&lt;OrderServiceOptions&gt;(configuration.GetSection(\"OrderService\")); services.PostConfigure&lt;OrderServiceOptions&gt;(options =&gt; &#123; options.MaxOrderCount += 100; &#125;); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 运行代码，可发现获得到的值比appsettings.json里的值增加100 为选项添加验证逻辑三种验证方法 直接注册验证函数 实现IValidateOptions&lt;TOptions&gt; 使用Microsoft.Extensions.Options.DataAnnotations 代码示例直接注册验证修改OrderServiceExtensions，具体代码如下： 12345678910111213141516171819202122using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Options;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.AddOptions&lt;OrderServiceOptions&gt;().Configure(options =&gt; &#123; configuration.GetSection(\"OrderService\").Bind(options); &#125;).Validate(options =&gt; &#123; return options.MaxOrderCount &lt;= 100; &#125;,\"MaxOrderCount 不能大于100\"); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 修改appsettings.json对应的配置为101，然后运行代码，访问/WeatherForecast的时候会报错提示MaxOrderCount 不能大于100 实现IValidateOptions&lt;TOptions&gt;修改OrderService.cs，在里面新增OrderServiceValidateOptions类，实现IValidateOptions&lt;OrderServiceOptions&gt;接口，具体代码如下： 1234567891011121314public class OrderServiceValidateOptions : IValidateOptions&lt;OrderServiceOptions&gt;&#123; public ValidateOptionsResult Validate(string name, OrderServiceOptions options) &#123; if (options.MaxOrderCount &gt; 100) &#123; return ValidateOptionsResult.Fail(\"MaxOrderCount 不能大于100\"); &#125; else &#123; return ValidateOptionsResult.Success; &#125; &#125;&#125; 修改OrderServiceExtensions，具体代码如下： 123456789101112131415161718using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Options;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.AddOptions&lt;OrderServiceOptions&gt;() .Configure(options =&gt; &#123; configuration.GetSection(\"OrderService\").Bind(options); &#125;).Services .AddSingleton&lt;IValidateOptions&lt;OrderServiceOptions&gt;, OrderServiceValidateOptions&gt;(); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 运行代码会得到与上一个示例一致的结果 使用属性标签的方式修改OrderServiceOptions，具体代码如下： 12345public class OrderServiceOptions&#123; [Range(1,20)] public int MaxOrderCount &#123; get; set; &#125; = 100;&#125; 修改OrderServiceExtensions，具体代码如下： 12345678910111213141516171819using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Options;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.AddOptions&lt;OrderServiceOptions&gt;().Configure(options =&gt; &#123; configuration.GetSection(\"OrderService\").Bind(options); &#125;).ValidateDataAnnotations(); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 运行代码，访问/WeatherForecast会提示The field MaxOrderCount must be between 1 and 20.的错误信息","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(6) -- 命令行配置提供程序：最简单快捷的配置注入方法","slug":"6.ConfigurationCommandLine_document","date":"2020-03-31T07:15:15.000Z","updated":"2020-04-01T09:04:35.678Z","comments":true,"path":"2020/03/31/6.ConfigurationCommandLine_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/6.ConfigurationCommandLine_document/","excerpt":"","text":"命令行参数支持的格式 命令替换模式 代码示例 创建项目 测试支持命令行参数的三种格式 测试命令替换 命令行参数支持的格式 无前缀的key=value模式 双中横线--key=value或--key value模式 正斜杠/key=value或/key value模式 备注：等号分隔符和空格分隔符不能混用* 命令替换模式 必须以单横线-或双横线--开头 映射字典不能包含重复key 主要作用是命令缩写的作用 代码示例创建项目创建名字为ConfigurationCommandLineDemo的控制台应用，通过nuget引入以下三个包： 123Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.AbstractionsMicrosoft.Extensions.Configuration.CommandLine 测试支持命令行参数的三种格式修改Program.Main方法，代码如下： 1234567891011121314151617181920using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationCommandLineDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddCommandLine(args); var configurationRoot = builder.Build(); Console.WriteLine($\"CommandLineKey1:&#123;configurationRoot[\"CommandLineKey1\"]&#125;\"); Console.WriteLine($\"CommandLineKey2:&#123;configurationRoot[\"CommandLineKey2\"]&#125;\"); Console.WriteLine($\"CommandLineKey3:&#123;configurationRoot[\"CommandLineKey3\"]&#125;\"); Console.ReadKey(); &#125; &#125;&#125; 配置测试参数： 在Visual Studio 2019中，可以右键项目名称-&gt;属性-&gt;调试-&gt;应用程序参数中输入以下内容：1CommandLineKey1&#x3D;value1 --CommandLineKey2&#x3D;value2 &#x2F;CommandLineKey3&#x3D;value3 在Visual Studio Code中，可以编辑launchSettings.json文件，新增commandLineArgs字段，具体代码如下:12345678&#123; \"profiles\": &#123; \"ConfigurationCommandLineDemo\": &#123; \"commandName\": \"Project\", \"commandLineArgs\": \"CommandLineKey1=value1 --CommandLineKey2=value2 /CommandLineKey3=value3\" &#125; &#125;&#125; 运行项目，可以看到控制台打印出对应的键值对，类似以下信息： 123CommandLineKey1:value1CommandLineKey2:value2CommandLineKey3:value3 测试命令替换为Program.Main方法添加命令替换映射，代码如下： 123456789101112131415161718192021using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationCommandLineDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); var mapper = new Dictionary&lt;string, string&gt;() &#123;&#123;\"-k1\", \"CommandLineKey1\"&#125;&#125;; builder.AddCommandLine(args, mapper); var configurationRoot = builder.Build(); Console.WriteLine($\"CommandLineKey1:&#123;configurationRoot[\"CommandLineKey1\"]&#125;\"); Console.WriteLine($\"CommandLineKey2:&#123;configurationRoot[\"CommandLineKey2\"]&#125;\"); Console.WriteLine($\"CommandLineKey3:&#123;configurationRoot[\"CommandLineKey3\"]&#125;\"); Console.ReadKey(); &#125; &#125;&#125; mapper表示用-k1这个命令可以代替CommandLineKey1将应用参数修改为： 1CommandLineKey1&#x3D;value1 --CommandLineKey2&#x3D;value2 &#x2F;CommandLineKey3&#x3D;value3 -k1&#x3D;value4 运行项目会在控制台打印出以下信息： 123CommandLineKey1:value4CommandLineKey2:value2CommandLineKey3:value3 可以发现CommandLineKey1原本的值value1被后面的-k1的值value4所替换了，说明了替换规则生效","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(5) -- 配置框架：让服务无缝适应各种环境","slug":"5.Configuration_document","date":"2020-03-31T06:14:14.000Z","updated":"2020-04-01T09:04:29.535Z","comments":true,"path":"2020/03/31/5.Configuration_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/5.Configuration_document/","excerpt":"","text":"概念 配置框架的核心包 框架配置 配置框架核心类型 配置框架扩展点 代码实现 创建项目 完善代码 概念配置框架的核心包与依赖注入框架的核心包类似，使用的是接口实现分离的设计模式 12Microsoft.Extensions.Configuration &#x2F;&#x2F;实现包Microsoft.Extensions.Configuration.Abstractions &#x2F;&#x2F;抽象包 框架配置 以key-value字符串键值对的方式抽象了配置 支持从各种不同的数据源读取配置，比如从命令行读取、环境变量读取、从文件读取等 配置框架核心类型1234IConfigurationIConfigurationRootIConfigurationSectionIConfigurationBuilder 配置框架扩展点可以通过拓展点注入我们自己的配置源，也就是我们可以指定任意我们指定的配置源到我们的配置框架中去 12IConfigurationSourceIConfigurationProvider 代码实现创建项目创建名字为ConfigurationDemo的控制台应用，通过nuget引入以下两个包： 12Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.Abstractions 完善代码在Program.cs的Main完善测试代码，具体代码如下： 123456789101112131415161718192021222324using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddInMemoryCollection(new Dictionary&lt;string, string&gt;() &#123; &#123;\"key1\", \"value1\"&#125;, &#123;\"key2\", \"value2\"&#125;, &#123;\"sectionA:key4\", \"value4\"&#125; &#125;); var configurationRoot = builder.Build(); Console.WriteLine($\"key1=&#123;configurationRoot[\"key1\"]&#125;\"); Console.WriteLine($\"key2=&#123;configurationRoot[\"key2\"]&#125;\"); var sectionA = configurationRoot.GetSection(\"sectionA\"); Console.WriteLine($\"sectionA:key4=&#123;sectionA[\"key4\"]&#125;\"); &#125; &#125;&#125; 创建一个ConfigurationBuilder对象，添加内存配置源，然后调用Build方法来生成一个IConfigurationRoot对象，通过这个对象可以直接获取配置源的配置项，用:来区分多个层级，通过GetSetion可获取指定层级，可以依次推各个层级的键值对","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(4) -- 用Autofac增强容器能力","slug":"4.DependencyInjectionAutofac_document","date":"2020-03-31T05:13:13.000Z","updated":"2020-04-01T09:04:21.075Z","comments":true,"path":"2020/03/31/4.DependencyInjectionAutofac_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/4.DependencyInjectionAutofac_document/","excerpt":"","text":"引入Autofac增强什么能力 核心扩展点 集成Autofac 代码验证 项目与依赖 在代码中引入Autofac 创建测试服务 获取Autofac根容器 一般注册服务 基于名字注册服务 属性注入 AOP切面拦截器 创建子容器 引入Autofac增强什么能力 基于名称的注入：需要把一个服务按照名称来区分它的不同实现 属性注入：直接把服务注册到某个类的属性里面去，而不需要定义构造函数 子容器：类似原生的scope，但是功能更加丰富 基于动态代理的AOP：当我们需要在服务中注入我们额外的行为的时候 核心扩展点IServiceProviderFactory&lt;TContainerBuilder&gt;：第三方的依赖注入容器都是使用这个类来作为拓展点，把自己注入到整个框架里面来，也就是我们在使用依赖注入框架的时候，不需要关注谁家的特性谁家接口时怎么样的，我们直接使用官方核心的定义即可，不需要直接依赖这些框架 集成Autofac Autofac.Extensions.DependencyInjection Autofac.Extras.DynamicProxy 代码验证项目与依赖创建名字为DependencyInjectionAutofacDemo的ASP.NET Core项目，类型为API 通过nuget引入以下两个包 12Autofac.Extensions.DependencyInjectionAutofac.Extras.DynamicProxy 在代码中引入Autofac在Program.cs的CreateDefaultBuilder后面添加以下代码 1.UseServiceProviderFactory(new AutofacServiceProviderFactory()) UseServiceProviderFactory用来注册第三方容器的入口 在Startup中新增ConfigureContainer方法，代码如下： 123public void ConfigureContainer(ContainerBuilder builder)&#123;&#125; 至此Autofac框架引入完毕，下面要创建测试服务类 创建测试服务创建测试服务MyService.cs类，具体代码如下： 1234567891011121314151617181920212223242526using System;namespace DependencyInjectionAutofacDemo.Services&#123; public interface IMyService &#123; void ShowCode(); &#125; public class MyService : IMyService &#123; public void ShowCode() &#123; Console.WriteLine($\"MyService.ShowCode:&#123;GetHashCode()&#125;\"); &#125; &#125; public class MyServiceV2 : IMyService &#123; public MyNameService MyNameService &#123; get; set; &#125; public void ShowCode() &#123; Console.WriteLine($\"MyServiceV2.ShowCode:&#123;GetHashCode()&#125;,MyNameService是否为空:&#123;MyNameService==null&#125;\"); &#125; &#125; public class MyNameService &#123; &#125;&#125; 创建测试拦截器MyInterceptor.cs，代码如下： 123456789101112131415using System;using Castle.DynamicProxy;namespace DependencyInjectionAutofacDemo.Services&#123; public class MyInterceptor:IInterceptor &#123; public void Intercept(IInvocation invocation) &#123; Console.WriteLine($\"Intercept before,Method:&#123;invocation.Method.Name&#125;\"); invocation.Proceed(); Console.WriteLine($\"Intercept after,Method:&#123;invocation.Method.Name&#125;\"); &#125; &#125;&#125; IInterceptor 是Autofac面向切面最重要的一个接口，他可以把我们的逻辑注入到方法的切面里面去 invocation.Proceed()是指具体方法的执行，如果这句不执行，就相当于把切面方法拦截了，让具体类的方法不执行 获取Autofac根容器在Startup里新增类型为ILifetimeScope的AutofacContainer属性，然后在Configure方法中为这个属性复制为Autofac的根容器，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using Autofac;using Autofac.Extensions.DependencyInjection;using Autofac.Extras.DynamicProxy;using DependencyInjectionAutofacDemo.Services;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace DependencyInjectionAutofacDemo&#123; public class Startup &#123; public Startup(IConfiguration configuration) &#123; Configuration = configuration; &#125; public IConfiguration Configuration &#123; get; &#125; public void ConfigureServices(IServiceCollection services) &#123; services.AddControllers(); &#125; public void ConfigureContainer(ContainerBuilder builder) &#123; &#125; public ILifetimeScope AutofacContainer &#123; get; private set; &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; this.AutofacContainer = app.ApplicationServices.GetAutofacRoot(); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125; &#125;&#125; 一般注册服务在ConfigureContainer方法中进行服务注册，然后在Configure方法中获取服务实现对象，调用服务的ShowCode方法，具体代码如下: 123456789public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyService&gt;().As&lt;IMyService&gt;();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var serviceNoName = this.AutofacContainer.Resolve&lt;IMyService&gt;(); serviceNoName.ShowCode();&#125; Autofac注册服务与ASP.NET Core写法相反，先注册实现类，然后再标记这个实现类为哪种类型 运行项目会看到控制台打印了MyService对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyService.ShowCode:16336406 基于名字注册服务注释掉上一步的测试代码，一样是在ConfigureContainer方法中进行服务注册，然后在Configure方法中获取服务实现对象，调用服务的ShowCode方法，具体代码如下: 123456789public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyServiceV2&gt;().Named&lt;IMyService&gt;(\"service2\");&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.ResolveNamed&lt;IMyService&gt;(\"service2\"); service.ShowCode();&#125; 运行项目会看到控制台打印了MyServiceV2对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyServiceV2.ShowCode:16336406,MyNameService是否为空:True 属性注入注释掉上一步的测试代码，在ConfigureContainer方法中进行服务注册，注意需要先将属性的服务先进行注册，再进行调用方的服务注册，然后一样再Configure中获取对象，调用ShowCode方法 12345678910public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyNameService&gt;(); builder.RegisterType&lt;MyServiceV2&gt;().As&lt;IMyService&gt;().PropertiesAutowired();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.Resolve&lt;IMyService&gt;(); service.ShowCode();&#125; 运行项目会看到控制台打印了MyServiceV2对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyServiceV2.ShowCode:10309404,MyNameService是否为空:False 可以发现MyNameService属性已经不为空了，通过属性注入的操作注入到了服务对象中去，打断点进行调试，可以看出MyNameService类型就是上面注册的类型 AOP切面拦截器注释掉上一步的测试代码，先在ConfigureContainer方法中注册拦截器，然后在服务，并指定拦截器为刚刚所注册的拦截器，并且允许接口拦截器生效，获取服务与上一步操作一致 12345678910public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyInterceptor&gt;(); builder.RegisterType&lt;MyServiceV2&gt;().As&lt;IMyService&gt;().PropertiesAutowired().InterceptedBy(typeof(MyInterceptor)).EnableInterfaceInterceptors();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.Resolve&lt;IMyService&gt;(); service.ShowCode();&#125; 运行项目，可以看到控制台在打印出MyServiceV2的ShowCode方法所打印的信息前后，有拦截器打印出来的信息，类似信息如下： 123Intercept before,Method:ShowCodeMyServiceV2.ShowCode:25116876,MyNameService是否为空:TrueIntercept after,Method:ShowCode 创建子容器子容器主要适用于将服务注册进指定名字的容器里，这样只有在创建出指定名字的容器才可获取到服务对象，其他容器无法获得该服务对象，具体代码如下： 12345678910111213141516171819public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyNameService&gt;().InstancePerMatchingLifetimeScope(\"myScope\");&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; using (var myScope = this.AutofacContainer.BeginLifetimeScope(\"myScope\")) &#123; var service0 = myScope.Resolve&lt;MyNameService&gt;(); using (var scope = myScope.BeginLifetimeScope()) &#123; var service1 = scope.Resolve&lt;MyNameService&gt;(); var service2 = scope.Resolve&lt;MyNameService&gt;(); Console.WriteLine($\"service0=service1:&#123;service0==service1&#125;\"); Console.WriteLine($\"service1=service2:&#123;service1==service2&#125;\"); &#125; &#125;&#125; 运行代码可看到对象获取成功，并且获取到的对象在作用域内为同一个对象，类似信息如下： 12service0&#x3D;service1:Trueservice1&#x3D;service2:True 如果这时候不通过创建指定名字的容器来获得服务对象，会发现代码运行直接报错","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(3) -- 作用域与对象释放行为","slug":"3.DependencyInjectionScopeAndDisposable_document","date":"2020-03-31T04:12:12.000Z","updated":"2020-04-01T09:04:14.822Z","comments":true,"path":"2020/03/31/3.DependencyInjectionScopeAndDisposable_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/3.DependencyInjectionScopeAndDisposable_document/","excerpt":"","text":"实现IDisposable接口类型的释放 建议 代码验证 项目 创建测试服务 测试Transient服务的释放时机 测试Scope服务的释放时机 测试Singleton服务的释放时机 避坑 自己new服务 在跟容器获取Transient服务 实现IDisposable接口类型的释放 DI只负责释放其创建的对象实例 DI在容器或子容器释放时，释放尤其创建的对象实例 建议 避免在根容器获取实现了IDisposable接口的瞬时服务 避免手动创建实现了IDisposable对象，应该使用容器来管理其生命周期 代码验证项目创建名为DependencyInjectionScopeAndDisposableDemo的ASP.NET Core项目，类型为API 创建测试服务创建测试服务类OrderService.cs，代码如下： 123456789101112using System;namespace DependencyInjectionScopeAndDisposableDemo.Services&#123; public interface IOrderService &#123; &#125; public class DisposableOrderService : IOrderService, IDisposable &#123; public void Dispose() &#123; Console.WriteLine($\"DisposableOrderService Disposed:&#123;this.GetHashCode()&#125;\"); &#125; &#125;&#125; 测试Transient服务的释放时机在Startup.ConfigureServices里注册一个瞬时服务 1services.AddTransient&lt;IOrderService, DisposableOrderService&gt;(); 在WeatherForecastController里的Get方法通过方法参数的形式获取两个IOrderService接口对象，代码如下： 123456[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2)&#123; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 保存之后运行项目，可以看到在打印接口请求处理结束之后两个对象都被释放掉，类似以下信息 123&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:64923656DisposableOrderService Disposed:11404313 得出的结论是：transient对象会在使用后被释放 测试Scope服务的释放时机注释掉上一步注册瞬时服务的代码，重新注册一个scope服务，这里使用工厂模式，只是熟悉以下工厂模式的写法，没特殊意义 1services.AddScoped&lt;IOrderService&gt;(serviceProvider =&gt; new DisposableOrderService()); 这时运行项目，控制台会打印出一个对象被释放，因为scope服务在当前容器内为单例，下面就这个结论再次测试以下，用using创建一个服务容器出来，看是否能创建出新的服务对象，并且代码运行超过using范围，服务对象是否会被释放。在WeatherForecastController的Get方法新增创建容器和获取服务操作，代码如下： 12345678910111213[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2)&#123; Console.WriteLine(\"========1==========\"); using (var scope = HttpContext.RequestServices.CreateScope()) &#123; var service = scope.ServiceProvider.GetService&lt;IOrderService&gt;(); &#125; Console.WriteLine(\"========2==========\"); Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; HttpContext.RequestServices.CreateScope()表示从根容器中创建一个子容器出来，scope.ServiceProvider.GetService&lt;IOrderService&gt;()表示从创建出来的子容器获取IOrderService的服务实现对象，运行项目可以得到两个对象被释放的信息，类似以下信息： 12345&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:5568949&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:31307802 得出结论是：scope对象会在对象产生的容器被释放的时候同时一起释放 测试Singleton服务的释放时机注释掉上一步注册scope服务的代码，重新注册一个singleton服务，这里一样使用工厂模式 1services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt; new DisposableOrderService()); 将WeatherForecastController的Get方法修改为以下代码： 1234567891011[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2,[FromServices] IHostApplicationLifetime hostApplicationLifetime,[FromQuery]bool isStop=false)&#123; if (isStop) &#123; hostApplicationLifetime.StopApplication(); &#125; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 这里有获取了另一个服务IHostApplicationLifetime，这个服务对象控制了整个应用程序的生命周期，可以调用这个服务对象的StopApplication方法来停止应用程序，即停止整个站点，为了方便测试这里用了isStop这个参数来控制是否停止应用程序 运行项目，不管怎么刷新/WeatherForecast链接，都不会有对象被释放的信息打印出来，访问/WeatherForecast?isStop=true的时候，会看到应用程序被停止，同时打印出对象被释放的信息，类似以下信息： 12Application is shutting down...DisposableOrderService Disposed:3165221 得出结论是：scope对象只会在根容器释放的时候才会被释放，即所有单例模式的对象都会被注册在根容器上面 避坑自己new服务开始有个结论：DI只负责释放其创建的对象实例，这里进行验证以下自己new一个对象然后注入到容器中，看看是否能释放。这里注入了一个singleton对象，需注释掉上面做测试的代码，代码如下 12var myOrderService &#x3D; new DisposableOrderService();services.AddSingleton&lt;IOrderService&gt;(myOrderService); 控制器代码不用改，运行项目，访问/WeatherForecast发现不会有对象被释放，访问/WeatherForecast?isStop=true时，应用程序被停止，但是也一样没有对象被释放的信息，所以这个对象最终还是没被释放 在跟容器获取Transient服务注释掉上面的测试代码，在Startup.ConfigureServices中注册一个瞬时服务，代码如下： 1services.AddTransient&lt;IOrderService, DisposableOrderService&gt;(); 在Startup.Configure中从根容器获取瞬时服务对象，代码如下： 123456789101112131415public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var s = app.ApplicationServices.GetService&lt;IOrderService&gt;(); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 将WeatherForecastController的Get方法修改为以下代码： 1234567891011[HttpGet]public int Get([FromServices] IHostApplicationLifetime hostApplicationLifetime, [FromQuery]bool isStop = false)&#123; if (isStop) &#123; hostApplicationLifetime.StopApplication(); &#125; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 运行项目，访问/WeatherForecast接口，发现并不会有对象被释放的信息，在带上isStop=true的参数的时候，应用程序被停止，这时才有对象被释放的信息，类似信息如下： 12Application is shutting down...DisposableOrderService Disposed:41149443 得出结论：由于根容器只会在应用程序整个退出时回收，这就意味着即使这是个瞬时服务，但是应用程序不退出，这些对象会一直积累在应用程序内不得释放","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(6) -- 命令行配置提供程序：最简单快捷的配置注入方法","slug":"ConfigurationCommandLine_document","date":"2020-03-30T16:00:00.000Z","updated":"2020-03-31T17:11:39.268Z","comments":true,"path":"2020/03/31/ConfigurationCommandLine_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/ConfigurationCommandLine_document/","excerpt":"","text":"命令行参数支持的格式 命令替换模式 代码示例 创建项目 测试支持命令行参数的三种格式 测试命令替换 命令行参数支持的格式 无前缀的key=value模式 双中横线--key=value或--key value模式 正斜杠/key=value或/key value模式 备注：等号分隔符和空格分隔符不能混用* 命令替换模式 必须以单横线-或双横线--开头 映射字典不能包含重复key 主要作用是命令缩写的作用 代码示例创建项目创建名字为ConfigurationCommandLineDemo的控制台应用，通过nuget引入以下三个包： 123Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.AbstractionsMicrosoft.Extensions.Configuration.CommandLine 测试支持命令行参数的三种格式修改Program.Main方法，代码如下： 1234567891011121314151617181920using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationCommandLineDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddCommandLine(args); var configurationRoot = builder.Build(); Console.WriteLine($\"CommandLineKey1:&#123;configurationRoot[\"CommandLineKey1\"]&#125;\"); Console.WriteLine($\"CommandLineKey2:&#123;configurationRoot[\"CommandLineKey2\"]&#125;\"); Console.WriteLine($\"CommandLineKey3:&#123;configurationRoot[\"CommandLineKey3\"]&#125;\"); Console.ReadKey(); &#125; &#125;&#125; 配置测试参数： 在Visual Studio 2019中，可以右键项目名称-&gt;属性-&gt;调试-&gt;应用程序参数中输入以下内容：1CommandLineKey1&#x3D;value1 --CommandLineKey2&#x3D;value2 &#x2F;CommandLineKey3&#x3D;value3 在Visual Studio Code中，可以编辑launchSettings.json文件，新增commandLineArgs字段，具体代码如下:12345678&#123; \"profiles\": &#123; \"ConfigurationCommandLineDemo\": &#123; \"commandName\": \"Project\", \"commandLineArgs\": \"CommandLineKey1=value1 --CommandLineKey2=value2 /CommandLineKey3=value3\" &#125; &#125;&#125; 运行项目，可以看到控制台打印出对应的键值对，类似以下信息： 123CommandLineKey1:value1CommandLineKey2:value2CommandLineKey3:value3 测试命令替换为Program.Main方法添加命令替换映射，代码如下： 123456789101112131415161718192021using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationCommandLineDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); var mapper = new Dictionary&lt;string, string&gt;() &#123;&#123;\"-k1\", \"CommandLineKey1\"&#125;&#125;; builder.AddCommandLine(args, mapper); var configurationRoot = builder.Build(); Console.WriteLine($\"CommandLineKey1:&#123;configurationRoot[\"CommandLineKey1\"]&#125;\"); Console.WriteLine($\"CommandLineKey2:&#123;configurationRoot[\"CommandLineKey2\"]&#125;\"); Console.WriteLine($\"CommandLineKey3:&#123;configurationRoot[\"CommandLineKey3\"]&#125;\"); Console.ReadKey(); &#125; &#125;&#125; mapper表示用-k1这个命令可以代替CommandLineKey1将应用参数修改为： 1CommandLineKey1&#x3D;value1 --CommandLineKey2&#x3D;value2 &#x2F;CommandLineKey3&#x3D;value3 -k1&#x3D;value4 运行项目会在控制台打印出以下信息： 123CommandLineKey1:value4CommandLineKey2:value2CommandLineKey3:value3 可以发现CommandLineKey1原本的值value1被后面的-k1的值value4所替换了，说明了替换规则生效","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(5) -- 配置框架：让服务无缝适应各种环境","slug":"Configuration_document","date":"2020-03-30T16:00:00.000Z","updated":"2020-03-31T17:11:39.269Z","comments":true,"path":"2020/03/31/Configuration_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/Configuration_document/","excerpt":"","text":"概念 配置框架的核心包 框架配置 配置框架核心类型 配置框架扩展点 代码实现 创建项目 完善代码 概念配置框架的核心包与依赖注入框架的核心包类似，使用的是接口实现分离的设计模式 12Microsoft.Extensions.Configuration &#x2F;&#x2F;实现包Microsoft.Extensions.Configuration.Abstractions &#x2F;&#x2F;抽象包 框架配置 以key-value字符串键值对的方式抽象了配置 支持从各种不同的数据源读取配置，比如从命令行读取、环境变量读取、从文件读取等 配置框架核心类型1234IConfigurationIConfigurationRootIConfigurationSectionIConfigurationBuilder 配置框架扩展点可以通过拓展点注入我们自己的配置源，也就是我们可以指定任意我们指定的配置源到我们的配置框架中去 12IConfigurationSourceIConfigurationProvider 代码实现创建项目创建名字为ConfigurationDemo的控制台应用，通过nuget引入以下两个包： 12Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.Abstractions 完善代码在Program.cs的Main完善测试代码，具体代码如下： 123456789101112131415161718192021222324using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddInMemoryCollection(new Dictionary&lt;string, string&gt;() &#123; &#123;\"key1\", \"value1\"&#125;, &#123;\"key2\", \"value2\"&#125;, &#123;\"sectionA:key4\", \"value4\"&#125; &#125;); var configurationRoot = builder.Build(); Console.WriteLine($\"key1=&#123;configurationRoot[\"key1\"]&#125;\"); Console.WriteLine($\"key2=&#123;configurationRoot[\"key2\"]&#125;\"); var sectionA = configurationRoot.GetSection(\"sectionA\"); Console.WriteLine($\"sectionA:key4=&#123;sectionA[\"key4\"]&#125;\"); &#125; &#125;&#125; 创建一个ConfigurationBuilder对象，添加内存配置源，然后调用Build方法来生成一个IConfigurationRoot对象，通过这个对象可以直接获取配置源的配置项，用:来区分多个层级，通过GetSetion可获取指定层级，可以依次推各个层级的键值对","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(3) -- 用Autofac增强容器能力","slug":"DependencyInjectionAutofac_document","date":"2020-03-30T16:00:00.000Z","updated":"2020-03-31T17:11:39.270Z","comments":true,"path":"2020/03/31/DependencyInjectionAutofac_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/DependencyInjectionAutofac_document/","excerpt":"","text":"引入Autofac增强什么能力 核心扩展点 集成Autofac 代码验证 项目与依赖 在代码中引入Autofac 创建测试服务 获取Autofac根容器 一般注册服务 基于名字注册服务 属性注入 AOP切面拦截器 创建子容器 引入Autofac增强什么能力 基于名称的注入：需要把一个服务按照名称来区分它的不同实现 属性注入：直接把服务注册到某个类的属性里面去，而不需要定义构造函数 子容器：类似原生的scope，但是功能更加丰富 基于动态代理的AOP：当我们需要在服务中注入我们额外的行为的时候 核心扩展点IServiceProviderFactory&lt;TContainerBuilder&gt;：第三方的依赖注入容器都是使用这个类来作为拓展点，把自己注入到整个框架里面来，也就是我们在使用依赖注入框架的时候，不需要关注谁家的特性谁家接口时怎么样的，我们直接使用官方核心的定义即可，不需要直接依赖这些框架 集成Autofac Autofac.Extensions.DependencyInjection Autofac.Extras.DynamicProxy 代码验证项目与依赖创建名字为DependencyInjectionAutofacDemo的ASP.NET Core项目，类型为API 通过nuget引入以下两个包 12Autofac.Extensions.DependencyInjectionAutofac.Extras.DynamicProxy 在代码中引入Autofac在Program.cs的CreateDefaultBuilder后面添加以下代码 1.UseServiceProviderFactory(new AutofacServiceProviderFactory()) UseServiceProviderFactory用来注册第三方容器的入口 在Startup中新增ConfigureContainer方法，代码如下： 123public void ConfigureContainer(ContainerBuilder builder)&#123;&#125; 至此Autofac框架引入完毕，下面要创建测试服务类 创建测试服务创建测试服务MyService.cs类，具体代码如下： 1234567891011121314151617181920212223242526using System;namespace DependencyInjectionAutofacDemo.Services&#123; public interface IMyService &#123; void ShowCode(); &#125; public class MyService : IMyService &#123; public void ShowCode() &#123; Console.WriteLine($\"MyService.ShowCode:&#123;GetHashCode()&#125;\"); &#125; &#125; public class MyServiceV2 : IMyService &#123; public MyNameService MyNameService &#123; get; set; &#125; public void ShowCode() &#123; Console.WriteLine($\"MyServiceV2.ShowCode:&#123;GetHashCode()&#125;,MyNameService是否为空:&#123;MyNameService==null&#125;\"); &#125; &#125; public class MyNameService &#123; &#125;&#125; 创建测试拦截器MyInterceptor.cs，代码如下： 123456789101112131415using System;using Castle.DynamicProxy;namespace DependencyInjectionAutofacDemo.Services&#123; public class MyInterceptor:IInterceptor &#123; public void Intercept(IInvocation invocation) &#123; Console.WriteLine($\"Intercept before,Method:&#123;invocation.Method.Name&#125;\"); invocation.Proceed(); Console.WriteLine($\"Intercept after,Method:&#123;invocation.Method.Name&#125;\"); &#125; &#125;&#125; IInterceptor 是Autofac面向切面最重要的一个接口，他可以把我们的逻辑注入到方法的切面里面去 invocation.Proceed()是指具体方法的执行，如果这句不执行，就相当于把切面方法拦截了，让具体类的方法不执行 获取Autofac根容器在Startup里新增类型为ILifetimeScope的AutofacContainer属性，然后在Configure方法中为这个属性复制为Autofac的根容器，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using Autofac;using Autofac.Extensions.DependencyInjection;using Autofac.Extras.DynamicProxy;using DependencyInjectionAutofacDemo.Services;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace DependencyInjectionAutofacDemo&#123; public class Startup &#123; public Startup(IConfiguration configuration) &#123; Configuration = configuration; &#125; public IConfiguration Configuration &#123; get; &#125; public void ConfigureServices(IServiceCollection services) &#123; services.AddControllers(); &#125; public void ConfigureContainer(ContainerBuilder builder) &#123; &#125; public ILifetimeScope AutofacContainer &#123; get; private set; &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; this.AutofacContainer = app.ApplicationServices.GetAutofacRoot(); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125; &#125;&#125; 一般注册服务在ConfigureContainer方法中进行服务注册，然后在Configure方法中获取服务实现对象，调用服务的ShowCode方法，具体代码如下: 123456789public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyService&gt;().As&lt;IMyService&gt;();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var serviceNoName = this.AutofacContainer.Resolve&lt;IMyService&gt;(); serviceNoName.ShowCode();&#125; Autofac注册服务与ASP.NET Core写法相反，先注册实现类，然后再标记这个实现类为哪种类型 运行项目会看到控制台打印了MyService对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyService.ShowCode:16336406 基于名字注册服务注释掉上一步的测试代码，一样是在ConfigureContainer方法中进行服务注册，然后在Configure方法中获取服务实现对象，调用服务的ShowCode方法，具体代码如下: 123456789public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyServiceV2&gt;().Named&lt;IMyService&gt;(\"service2\");&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.ResolveNamed&lt;IMyService&gt;(\"service2\"); service.ShowCode();&#125; 运行项目会看到控制台打印了MyServiceV2对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyServiceV2.ShowCode:16336406,MyNameService是否为空:True 属性注入注释掉上一步的测试代码，在ConfigureContainer方法中进行服务注册，注意需要先将属性的服务先进行注册，再进行调用方的服务注册，然后一样再Configure中获取对象，调用ShowCode方法 12345678910public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyNameService&gt;(); builder.RegisterType&lt;MyServiceV2&gt;().As&lt;IMyService&gt;().PropertiesAutowired();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.Resolve&lt;IMyService&gt;(); service.ShowCode();&#125; 运行项目会看到控制台打印了MyServiceV2对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyServiceV2.ShowCode:10309404,MyNameService是否为空:False 可以发现MyNameService属性已经不为空了，通过属性注入的操作注入到了服务对象中去，打断点进行调试，可以看出MyNameService类型就是上面注册的类型 AOP切面拦截器注释掉上一步的测试代码，先在ConfigureContainer方法中注册拦截器，然后在服务，并指定拦截器为刚刚所注册的拦截器，并且允许接口拦截器生效，获取服务与上一步操作一致 12345678910public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyInterceptor&gt;(); builder.RegisterType&lt;MyServiceV2&gt;().As&lt;IMyService&gt;().PropertiesAutowired().InterceptedBy(typeof(MyInterceptor)).EnableInterfaceInterceptors();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.Resolve&lt;IMyService&gt;(); service.ShowCode();&#125; 运行项目，可以看到控制台在打印出MyServiceV2的ShowCode方法所打印的信息前后，有拦截器打印出来的信息，类似信息如下： 123Intercept before,Method:ShowCodeMyServiceV2.ShowCode:25116876,MyNameService是否为空:TrueIntercept after,Method:ShowCode 创建子容器子容器主要适用于将服务注册进指定名字的容器里，这样只有在创建出指定名字的容器才可获取到服务对象，其他容器无法获得该服务对象，具体代码如下： 12345678910111213141516171819public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyNameService&gt;().InstancePerMatchingLifetimeScope(\"myScope\");&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; using (var myScope = this.AutofacContainer.BeginLifetimeScope(\"myScope\")) &#123; var service0 = myScope.Resolve&lt;MyNameService&gt;(); using (var scope = myScope.BeginLifetimeScope()) &#123; var service1 = scope.Resolve&lt;MyNameService&gt;(); var service2 = scope.Resolve&lt;MyNameService&gt;(); Console.WriteLine($\"service0=service1:&#123;service0==service1&#125;\"); Console.WriteLine($\"service1=service2:&#123;service1==service2&#125;\"); &#125; &#125;&#125; 运行代码可看到对象获取成功，并且获取到的对象在作用域内为同一个对象，类似信息如下： 12service0&#x3D;service1:Trueservice1&#x3D;service2:True 如果这时候不通过创建指定名字的容器来获得服务对象，会发现代码运行直接报错","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(3) -- 作用域与对象释放行为","slug":"DependencyInjectionScopeAndDisposable_document","date":"2020-03-30T16:00:00.000Z","updated":"2020-03-31T17:11:39.277Z","comments":true,"path":"2020/03/31/DependencyInjectionScopeAndDisposable_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/DependencyInjectionScopeAndDisposable_document/","excerpt":"","text":"实现IDisposable接口类型的释放 建议 代码验证 项目 创建测试服务 测试Transient服务的释放时机 测试Scope服务的释放时机 测试Singleton服务的释放时机 避坑 自己new服务 在跟容器获取Transient服务 实现IDisposable接口类型的释放 DI只负责释放其创建的对象实例 DI在容器或子容器释放时，释放尤其创建的对象实例 建议 避免在根容器获取实现了IDisposable接口的瞬时服务 避免手动创建实现了IDisposable对象，应该使用容器来管理其生命周期 代码验证项目创建名为DependencyInjectionScopeAndDisposableDemo的ASP.NET Core项目，类型为API 创建测试服务创建测试服务类OrderService.cs，代码如下： 123456789101112using System;namespace DependencyInjectionScopeAndDisposableDemo.Services&#123; public interface IOrderService &#123; &#125; public class DisposableOrderService : IOrderService, IDisposable &#123; public void Dispose() &#123; Console.WriteLine($\"DisposableOrderService Disposed:&#123;this.GetHashCode()&#125;\"); &#125; &#125;&#125; 测试Transient服务的释放时机在Startup.ConfigureServices里注册一个瞬时服务 1services.AddTransient&lt;IOrderService, DisposableOrderService&gt;(); 在WeatherForecastController里的Get方法通过方法参数的形式获取两个IOrderService接口对象，代码如下： 123456[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2)&#123; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 保存之后运行项目，可以看到在打印接口请求处理结束之后两个对象都被释放掉，类似以下信息 123&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:64923656DisposableOrderService Disposed:11404313 得出的结论是：transient对象会在使用后被释放 测试Scope服务的释放时机注释掉上一步注册瞬时服务的代码，重新注册一个scope服务，这里使用工厂模式，只是熟悉以下工厂模式的写法，没特殊意义 1services.AddScoped&lt;IOrderService&gt;(serviceProvider =&gt; new DisposableOrderService()); 这时运行项目，控制台会打印出一个对象被释放，因为scope服务在当前容器内为单例，下面就这个结论再次测试以下，用using创建一个服务容器出来，看是否能创建出新的服务对象，并且代码运行超过using范围，服务对象是否会被释放。在WeatherForecastController的Get方法新增创建容器和获取服务操作，代码如下： 12345678910111213[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2)&#123; Console.WriteLine(\"========1==========\"); using (var scope = HttpContext.RequestServices.CreateScope()) &#123; var service = scope.ServiceProvider.GetService&lt;IOrderService&gt;(); &#125; Console.WriteLine(\"========2==========\"); Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; HttpContext.RequestServices.CreateScope()表示从根容器中创建一个子容器出来，scope.ServiceProvider.GetService&lt;IOrderService&gt;()表示从创建出来的子容器获取IOrderService的服务实现对象，运行项目可以得到两个对象被释放的信息，类似以下信息： 12345&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:5568949&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:31307802 得出结论是：scope对象会在对象产生的容器被释放的时候同时一起释放 测试Singleton服务的释放时机注释掉上一步注册scope服务的代码，重新注册一个singleton服务，这里一样使用工厂模式 1services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt; new DisposableOrderService()); 将WeatherForecastController的Get方法修改为以下代码： 1234567891011[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2,[FromServices] IHostApplicationLifetime hostApplicationLifetime,[FromQuery]bool isStop=false)&#123; if (isStop) &#123; hostApplicationLifetime.StopApplication(); &#125; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 这里有获取了另一个服务IHostApplicationLifetime，这个服务对象控制了整个应用程序的生命周期，可以调用这个服务对象的StopApplication方法来停止应用程序，即停止整个站点，为了方便测试这里用了isStop这个参数来控制是否停止应用程序 运行项目，不管怎么刷新/WeatherForecast链接，都不会有对象被释放的信息打印出来，访问/WeatherForecast?isStop=true的时候，会看到应用程序被停止，同时打印出对象被释放的信息，类似以下信息： 12Application is shutting down...DisposableOrderService Disposed:3165221 得出结论是：scope对象只会在根容器释放的时候才会被释放，即所有单例模式的对象都会被注册在根容器上面 避坑自己new服务开始有个结论：DI只负责释放其创建的对象实例，这里进行验证以下自己new一个对象然后注入到容器中，看看是否能释放。这里注入了一个singleton对象，需注释掉上面做测试的代码，代码如下 12var myOrderService &#x3D; new DisposableOrderService();services.AddSingleton&lt;IOrderService&gt;(myOrderService); 控制器代码不用改，运行项目，访问/WeatherForecast发现不会有对象被释放，访问/WeatherForecast?isStop=true时，应用程序被停止，但是也一样没有对象被释放的信息，所以这个对象最终还是没被释放 在跟容器获取Transient服务注释掉上面的测试代码，在Startup.ConfigureServices中注册一个瞬时服务，代码如下： 1services.AddTransient&lt;IOrderService, DisposableOrderService&gt;(); 在Startup.Configure中从根容器获取瞬时服务对象，代码如下： 123456789101112131415public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var s = app.ApplicationServices.GetService&lt;IOrderService&gt;(); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 将WeatherForecastController的Get方法修改为以下代码： 1234567891011[HttpGet]public int Get([FromServices] IHostApplicationLifetime hostApplicationLifetime, [FromQuery]bool isStop = false)&#123; if (isStop) &#123; hostApplicationLifetime.StopApplication(); &#125; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 运行项目，访问/WeatherForecast接口，发现并不会有对象被释放的信息，在带上isStop=true的参数的时候，应用程序被停止，这时才有对象被释放的信息，类似信息如下： 12Application is shutting down...DisposableOrderService Disposed:41149443 得出结论：由于根容器只会在应用程序整个退出时回收，这就意味着即使这是个瞬时服务，但是应用程序不退出，这些对象会一直积累在应用程序内不得释放","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(2) -- 依赖注入：良好架构的起点","slug":"2.DependencyInjection_document","date":"2020-03-30T02:12:12.000Z","updated":"2020-04-01T09:04:05.594Z","comments":true,"path":"2020/03/30/2.DependencyInjection_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/30/2.DependencyInjection_document/","excerpt":"","text":"为什么要使用依赖注入框架(IoC框架) 依赖注入框架组件包 依赖注入框架核心类型 生命周期 代码演示 项目 示例服务类 验证不同生命周期的实现 注册不同生命周期的服务 在方法参数中获得服务进行验证 其他方式注册服务(以单例模式为例) 直接new对象 通过工厂模式注册对象 尝试注册服务 移除和替换服务 移除服务 替换服务 泛型服务注册 服务对象的获取 为什么要使用依赖注入框架(IoC框架) 借助依赖注入框架，我们可以轻松管理类之间的依赖，帮助我们在构建应用是遵循设计规则，确保代码的可维护性和可拓展性 ASP.NET Core的整个架构中，依赖注入框架提供了对象创建和生命周期管理的核心能力，各个组件相互写作，也是由依赖注入框架的能力来实现的 依赖注入框架组件包12Microsoft.Extensions.DependencyInjection.Abstractions &#x2F;&#x2F;抽象包Microsoft.Extensions.DependencyInjection &#x2F;&#x2F;具体实现 依赖注入框架核心类型1234IServiceCollection &#x2F;&#x2F;负责服务的注册ServiceDescriptor &#x2F;&#x2F;每个服务注册时的信息IServiceProvider &#x2F;&#x2F;具体的容器，也是由ServiceCollection Build出来IServiceScope &#x2F;&#x2F;表示一个容器的子容器的生命周期 生命周期123Singleton &#x2F;&#x2F;单例：在整个根容器的生命周期内获得的都是同一个单例对象Scoped &#x2F;&#x2F;作用域：在我的Scope的生命周期内，如果我的容器释放掉，则意味着我的对象释放掉，在这个生命周期范围内获得到的是一个单例对象Transient &#x2F;&#x2F;瞬时：每一次从容器里获取对象时都产生一个新的对象 代码演示项目创建名为DependencyInjectionDemo的ASP.NET Core项目，类型为API 示例服务类一共有5个示例服务类接口，分别为 1234567891011IGenericService&lt;T&gt; |-- GenericService&lt;T&gt; &#x2F;&#x2F;对应实现类IMyScopeService |-- MyScopeService &#x2F;&#x2F;对应实现类IMySingletonService |-- MySingletonService &#x2F;&#x2F;对应实现类IMyTransientService |-- MyTransientService &#x2F;&#x2F;对应实现类IOrderService |-- OrderService &#x2F;&#x2F;对应实现类 |-- OrderServiceEX &#x2F;&#x2F;对应实现类 因为是示例服务类，所以所有类和服务均没有属性和方法，纯粹为了验证服务注册和服务对象 验证不同生命周期的实现注册不同生命周期的服务在Startup.ConfigureServices方法中新增以下代码 123456// 注册Singleton服务services.AddSingleton&lt;IMySingletonService, MySingletonService&gt;();// 注册Scope服务services.AddScoped&lt;IMyScopeService, MyScopeService&gt;();// 注册Transient服务services.AddTransient&lt;IMyTransientService, MyTransientService&gt;(); 在方法参数中获得服务进行验证 修改WeatherForecastController类的Route标识为[Route(&quot;[controller]/[action]&quot;)]，方便进行测试 在WeatherForecastController新增GetService方法，代码如下：1234567891011121314151617[HttpGet]public int GetService([FromServices] IMySingletonService singletonService1, [FromServices] IMySingletonService singletonService2, [FromServices] IMyScopeService scopeService1, [FromServices] IMyScopeService scopeService2, [FromServices] IMyTransientService transientService1, [FromServices] IMyTransientService transientService2)&#123; Console.WriteLine($\"&#123;nameof(singletonService1)&#125;:&#123;singletonService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(singletonService2)&#125;:&#123;singletonService2.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(scopeService1)&#125;:&#123;scopeService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(scopeService2)&#125;:&#123;scopeService2.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(transientService1)&#125;:&#123;transientService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(transientService2)&#125;:&#123;transientService2.GetHashCode()&#125;\"); Console.WriteLine(\"=========请求结束========\"); return 1;&#125; 运行项目，访问/WeatherForecast/GetService，控制台会打印出类似以下信息1234567singletonService1:23488915singletonService2:23488915scopeService1:24854661scopeService2:24854661transientService1:38972574transientService2:14645893&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 可以看出IMySingletonService的实现对象属于同一个对象，IMyTransientService的实现对象有多个，目前看IMyScopeService的实现对象为同一个，但是再次访问/WeatherForecast/GetService接口，就可以发现IMyScopeService的实现对象为新的对象，而IMySingletonService的实现对象还是上次访问的那个，打印信息如下1234567singletonService1:23488915singletonService2:23488915scopeService1:6630602scopeService2:6630602transientService1:5024928transientService2:38414640&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 其他方式注册服务(以单例模式为例)直接new对象在Startup.ConfigureServices方法中新增以下代码 1services.AddSingleton&lt;IOrderService&gt;(new OrderService()); 通过工厂模式注册对象使用工厂模式注册对象，可以在委托中使用IServiceProvider参数，这也就意味着可以从容器里获取多个对象，然后进行组装，得到我们最终需要的实现实例，可以把工厂类设计的比较复杂，比如说我们的实现类依赖了容器里面的另外一个类的情况，或者我们期望用另外一个类来包装我们原有的实现的时候在Startup.ConfigureServices方法中新增以下代码 1234services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt;&#123; return new OrderServiceEx();&#125;); 尝试注册服务尝试注册服务有两种情况 当指定接口已有实现类，则不再注册服务，代码如下：1services.TryAddSingleton&lt;IOrderService, OrderServiceEx&gt;(); 当指定接口已有实现类，但是已注册的实现类不包含当前指定的实现类，则注册进去，如果已经包含当前的实现类，则不再注册服务，代码如下：1services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IOrderService,OrderService&gt;()); 在控制器里验证是否有多个实现类注册，可通过下面的方法验证(需要自行注释或修改Startup里面的服务注册情况)123456789[HttpGet]public int GetServiceList([FromServices] IEnumerable&lt;IOrderService&gt; orderServices)&#123; foreach (var item in orderServices) &#123; Console.WriteLine($\"获取到服务实例：&#123;item.ToString()&#125;:&#123;item.GetHashCode()&#125;\"); &#125; return 1;&#125; 移除和替换服务移除服务指的是直接从容器中移除指定接口的所有实现类，代码如下：1services.RemoveAll&lt;IOrderService&gt;(); 替换服务指的是替换指定接口的实现类，同时也会替换该服务的生命周期，代码如下：1services.Replace(ServiceDescriptor.Singleton&lt;IOrderService, OrderServiceEx&gt;()); 泛型服务注册即对泛型服务注册，代码如下： 1services.AddSingleton(typeof(IGenericService&lt;&gt;), typeof(GenericService&lt;&gt;)); 可以通过在控制器的构造函数中获取到服务对象，代码如下： 1234public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,IOrderService orderService,IGenericService&lt;IOrderService&gt; genericService)&#123; _logger = logger;&#125; 可以通过断点查看最终IGenericService的IOrderService为哪个实现类 服务对象的获取通过上面可以看出，服务对象有两种获取方式，一种是通过构造函数直接注入，一种是通过函数参数，使用[FromServices]标签来注入 一般按照使用情况来确定用哪种方式，如果整个类使用地方比较多，则使用构造函数注入，如果只有某一个方法使用，则一般使用函数参数来注入","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(1) -- 依赖注入：良好架构的起点","slug":"DependencyInjection_document","date":"2020-03-29T16:00:00.000Z","updated":"2020-03-31T17:11:39.278Z","comments":true,"path":"2020/03/30/DependencyInjection_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/30/DependencyInjection_document/","excerpt":"","text":"为什么要使用依赖注入框架(IoC框架) 依赖注入框架组件包 依赖注入框架核心类型 生命周期 代码演示 项目 示例服务类 验证不同生命周期的实现 注册不同生命周期的服务 在方法参数中获得服务进行验证 其他方式注册服务(以单例模式为例) 直接new对象 通过工厂模式注册对象 尝试注册服务 移除和替换服务 移除服务 替换服务 泛型服务注册 服务对象的获取 为什么要使用依赖注入框架(IoC框架) 借助依赖注入框架，我们可以轻松管理类之间的依赖，帮助我们在构建应用是遵循设计规则，确保代码的可维护性和可拓展性 ASP.NET Core的整个架构中，依赖注入框架提供了对象创建和生命周期管理的核心能力，各个组件相互写作，也是由依赖注入框架的能力来实现的 依赖注入框架组件包12Microsoft.Extensions.DependencyInjection.Abstractions &#x2F;&#x2F;抽象包Microsoft.Extensions.DependencyInjection &#x2F;&#x2F;具体实现 依赖注入框架核心类型1234IServiceCollection &#x2F;&#x2F;负责服务的注册ServiceDescriptor &#x2F;&#x2F;每个服务注册时的信息IServiceProvider &#x2F;&#x2F;具体的容器，也是由ServiceCollection Build出来IServiceScope &#x2F;&#x2F;表示一个容器的子容器的生命周期 生命周期123Singleton &#x2F;&#x2F;单例：在整个根容器的生命周期内获得的都是同一个单例对象Scoped &#x2F;&#x2F;作用域：在我的Scope的生命周期内，如果我的容器释放掉，则意味着我的对象释放掉，在这个生命周期范围内获得到的是一个单例对象Transient &#x2F;&#x2F;瞬时：每一次从容器里获取对象时都产生一个新的对象 代码演示项目创建名为DependencyInjectionDemo的ASP.NET Core项目，类型为API 示例服务类一共有5个示例服务类接口，分别为 1234567891011IGenericService&lt;T&gt; |-- GenericService&lt;T&gt; &#x2F;&#x2F;对应实现类IMyScopeService |-- MyScopeService &#x2F;&#x2F;对应实现类IMySingletonService |-- MySingletonService &#x2F;&#x2F;对应实现类IMyTransientService |-- MyTransientService &#x2F;&#x2F;对应实现类IOrderService |-- OrderService &#x2F;&#x2F;对应实现类 |-- OrderServiceEX &#x2F;&#x2F;对应实现类 因为是示例服务类，所以所有类和服务均没有属性和方法，纯粹为了验证服务注册和服务对象 验证不同生命周期的实现注册不同生命周期的服务在Startup.ConfigureServices方法中新增以下代码 123456// 注册Singleton服务services.AddSingleton&lt;IMySingletonService, MySingletonService&gt;();// 注册Scope服务services.AddScoped&lt;IMyScopeService, MyScopeService&gt;();// 注册Transient服务services.AddTransient&lt;IMyTransientService, MyTransientService&gt;(); 在方法参数中获得服务进行验证 修改WeatherForecastController类的Route标识为[Route(&quot;[controller]/[action]&quot;)]，方便进行测试 在WeatherForecastController新增GetService方法，代码如下：1234567891011121314151617[HttpGet]public int GetService([FromServices] IMySingletonService singletonService1, [FromServices] IMySingletonService singletonService2, [FromServices] IMyScopeService scopeService1, [FromServices] IMyScopeService scopeService2, [FromServices] IMyTransientService transientService1, [FromServices] IMyTransientService transientService2)&#123; Console.WriteLine($\"&#123;nameof(singletonService1)&#125;:&#123;singletonService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(singletonService2)&#125;:&#123;singletonService2.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(scopeService1)&#125;:&#123;scopeService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(scopeService2)&#125;:&#123;scopeService2.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(transientService1)&#125;:&#123;transientService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(transientService2)&#125;:&#123;transientService2.GetHashCode()&#125;\"); Console.WriteLine(\"=========请求结束========\"); return 1;&#125; 运行项目，访问/WeatherForecast/GetService，控制台会打印出类似以下信息1234567singletonService1:23488915singletonService2:23488915scopeService1:24854661scopeService2:24854661transientService1:38972574transientService2:14645893&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 可以看出IMySingletonService的实现对象属于同一个对象，IMyTransientService的实现对象有多个，目前看IMyScopeService的实现对象为同一个，但是再次访问/WeatherForecast/GetService接口，就可以发现IMyScopeService的实现对象为新的对象，而IMySingletonService的实现对象还是上次访问的那个，打印信息如下1234567singletonService1:23488915singletonService2:23488915scopeService1:6630602scopeService2:6630602transientService1:5024928transientService2:38414640&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 其他方式注册服务(以单例模式为例)直接new对象在Startup.ConfigureServices方法中新增以下代码 1services.AddSingleton&lt;IOrderService&gt;(new OrderService()); 通过工厂模式注册对象使用工厂模式注册对象，可以在委托中使用IServiceProvider参数，这也就意味着可以从容器里获取多个对象，然后进行组装，得到我们最终需要的实现实例，可以把工厂类设计的比较复杂，比如说我们的实现类依赖了容器里面的另外一个类的情况，或者我们期望用另外一个类来包装我们原有的实现的时候在Startup.ConfigureServices方法中新增以下代码 1234services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt;&#123; return new OrderServiceEx();&#125;); 尝试注册服务尝试注册服务有两种情况 当指定接口已有实现类，则不再注册服务，代码如下：1services.TryAddSingleton&lt;IOrderService, OrderServiceEx&gt;(); 当指定接口已有实现类，但是已注册的实现类不包含当前指定的实现类，则注册进去，如果已经包含当前的实现类，则不再注册服务，代码如下：1services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IOrderService,OrderService&gt;()); 在控制器里验证是否有多个实现类注册，可通过下面的方法验证(需要自行注释或修改Startup里面的服务注册情况)123456789[HttpGet]public int GetServiceList([FromServices] IEnumerable&lt;IOrderService&gt; orderServices)&#123; foreach (var item in orderServices) &#123; Console.WriteLine($\"获取到服务实例：&#123;item.ToString()&#125;:&#123;item.GetHashCode()&#125;\"); &#125; return 1;&#125; 移除和替换服务移除服务指的是直接从容器中移除指定接口的所有实现类，代码如下：1services.RemoveAll&lt;IOrderService&gt;(); 替换服务指的是替换指定接口的实现类，同时也会替换该服务的生命周期，代码如下：1services.Replace(ServiceDescriptor.Singleton&lt;IOrderService, OrderServiceEx&gt;()); 泛型服务注册即对泛型服务注册，代码如下： 1services.AddSingleton(typeof(IGenericService&lt;&gt;), typeof(GenericService&lt;&gt;)); 可以通过在控制器的构造函数中获取到服务对象，代码如下： 1234public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,IOrderService orderService,IGenericService&lt;IOrderService&gt; genericService)&#123; _logger = logger;&#125; 可以通过断点查看最终IGenericService的IOrderService为哪个实现类 服务对象的获取通过上面可以看出，服务对象有两种获取方式，一种是通过构造函数直接注入，一种是通过函数参数，使用[FromServices]标签来注入 一般按照使用情况来确定用哪种方式，如果整个类使用地方比较多，则使用构造函数注入，如果只有某一个方法使用，则一般使用函数参数来注入","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(1) -- ASP.NET Core的启动流程","slug":"StartupDemo_document","date":"2020-03-29T16:00:00.000Z","updated":"2020-03-31T17:11:39.279Z","comments":true,"path":"2020/03/30/StartupDemo_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/30/StartupDemo_document/","excerpt":"","text":"课程目标 创建项目 添加日志代码 运行结果 结论 另外 课程目标主要是掌握ASP.NET Core应用程序启动的流程，同时了解启动过程中哪些方法做了哪些操作 创建项目创建ASP.NET Core Web项目，项目类型选择API，直接创建即可 添加日志代码本实例不涉及任何业务代码，纯粹只是添加日志查看各个方法的调用流程 修改Program.cs，以下直接放修改后的代码 12345678910111213141516171819202122232425262728293031323334using System;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateHostBuilder(args).Build().Run(); &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; Console.WriteLine(\"ConfigureWebHostDefaults\"); webBuilder.UseStartup&lt;Startup&gt;(); &#125;) .ConfigureServices(service =&gt; &#123; Console.WriteLine(\"ConfigureServices\"); &#125;) .ConfigureAppConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureAppConfiguration\"); &#125;) .ConfigureHostConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureHostConfiguration\"); &#125;); &#125;&#125; 修改Startup.cs，以下直接放修改后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Startup &#123; public Startup(IConfiguration configuration) &#123; Console.WriteLine(\"Startup.Ctor\"); Configuration = configuration; &#125; public IConfiguration Configuration &#123; get; &#125; public void ConfigureServices(IServiceCollection services) &#123; Console.WriteLine(\"Startup.ConfigureServices\"); services.AddControllers(); &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; Console.WriteLine(\"Startup.Configure\"); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseStaticFiles(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125; &#125;&#125; 运行结果参照上面将代码修改完，直接运行代码，控制台将打印出以下信息 1234567ConfigureWebHostDefaultsConfigureHostConfigurationConfigureAppConfigurationStartup.CtorStartup.ConfigureServicesConfigureServicesStartup.Configure 结论以下为ASP.NET Core启动运行流程 ConfigureWebHostDefaults：注册了应用程序必要的几个组件，比如说配置的组件、容器的组件等 ConfigureHostConfiguration：配置程序启动时必要的配置，比如说程序启动时所需要监听的端口、需要监听的URL地址等，在这个过程可以嵌入我们自己的配置内容注入到配置的框架中去 ConfigureAppConfiguration：嵌入我们自己的配置文件，供应用程序来读取，这些配置将来会在后续的应用程序执行过程中每个组件读取 ConfigureServices/ConfigureLogging/Startup/Startup.ConfigureServices：这些都是往容器里面来注入我们的应用的组件 Startup.Configure：注入中间件，处理HttpContext整个的请求过程 另外从代码运行来看，Startup.cs这个类可以被整合到Program.cs里的ConfigureWebHostDefaults方法中，可以直接ConfigureWebHostDefaults方法中直接使用webBuilder调用ConfigureServices和Configure两个方法具体可以参考以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateHostBuilder(args).Build().Run(); &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; Console.WriteLine(\"ConfigureWebHostDefaults\"); webBuilder.ConfigureServices(services =&gt; &#123; Console.WriteLine(\"Program.ConfigureServices\"); services.AddControllers(); &#125;); webBuilder.Configure(app =&gt; &#123; Console.WriteLine(\"Program.Configure\"); app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseStaticFiles(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125;); &#125;) .ConfigureServices(service =&gt; &#123; Console.WriteLine(\"ConfigureServices\"); &#125;) .ConfigureAppConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureAppConfiguration\"); &#125;) .ConfigureHostConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureHostConfiguration\"); &#125;); &#125;&#125; 但是为了代码结构更加合理，还是需要用Startup这个类来分离变动比较大的代码 通常是在Startup.ConfigureServices的方法里做服务注册，一般是Addxxx 在Startup.Configure决定注册那些中间件到处理过程中去","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(1) -- ASP.NET Core的启动流程","slug":"1.StartupDemo_document","date":"2020-03-29T02:11:21.000Z","updated":"2020-04-01T09:03:58.277Z","comments":true,"path":"2020/03/29/1.StartupDemo_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/29/1.StartupDemo_document/","excerpt":"","text":"课程目标 创建项目 添加日志代码 运行结果 结论 另外 课程目标主要是掌握ASP.NET Core应用程序启动的流程，同时了解启动过程中哪些方法做了哪些操作 创建项目创建ASP.NET Core Web项目，项目类型选择API，直接创建即可 添加日志代码本实例不涉及任何业务代码，纯粹只是添加日志查看各个方法的调用流程 修改Program.cs，以下直接放修改后的代码 12345678910111213141516171819202122232425262728293031323334using System;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateHostBuilder(args).Build().Run(); &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; Console.WriteLine(\"ConfigureWebHostDefaults\"); webBuilder.UseStartup&lt;Startup&gt;(); &#125;) .ConfigureServices(service =&gt; &#123; Console.WriteLine(\"ConfigureServices\"); &#125;) .ConfigureAppConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureAppConfiguration\"); &#125;) .ConfigureHostConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureHostConfiguration\"); &#125;); &#125;&#125; 修改Startup.cs，以下直接放修改后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Startup &#123; public Startup(IConfiguration configuration) &#123; Console.WriteLine(\"Startup.Ctor\"); Configuration = configuration; &#125; public IConfiguration Configuration &#123; get; &#125; public void ConfigureServices(IServiceCollection services) &#123; Console.WriteLine(\"Startup.ConfigureServices\"); services.AddControllers(); &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; Console.WriteLine(\"Startup.Configure\"); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseStaticFiles(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125; &#125;&#125; 运行结果参照上面将代码修改完，直接运行代码，控制台将打印出以下信息 1234567ConfigureWebHostDefaultsConfigureHostConfigurationConfigureAppConfigurationStartup.CtorStartup.ConfigureServicesConfigureServicesStartup.Configure 结论以下为ASP.NET Core启动运行流程 ConfigureWebHostDefaults：注册了应用程序必要的几个组件，比如说配置的组件、容器的组件等 ConfigureHostConfiguration：配置程序启动时必要的配置，比如说程序启动时所需要监听的端口、需要监听的URL地址等，在这个过程可以嵌入我们自己的配置内容注入到配置的框架中去 ConfigureAppConfiguration：嵌入我们自己的配置文件，供应用程序来读取，这些配置将来会在后续的应用程序执行过程中每个组件读取 ConfigureServices/ConfigureLogging/Startup/Startup.ConfigureServices：这些都是往容器里面来注入我们的应用的组件 Startup.Configure：注入中间件，处理HttpContext整个的请求过程 另外从代码运行来看，Startup.cs这个类可以被整合到Program.cs里的ConfigureWebHostDefaults方法中，可以直接ConfigureWebHostDefaults方法中直接使用webBuilder调用ConfigureServices和Configure两个方法具体可以参考以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateHostBuilder(args).Build().Run(); &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; Console.WriteLine(\"ConfigureWebHostDefaults\"); webBuilder.ConfigureServices(services =&gt; &#123; Console.WriteLine(\"Program.ConfigureServices\"); services.AddControllers(); &#125;); webBuilder.Configure(app =&gt; &#123; Console.WriteLine(\"Program.Configure\"); app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseStaticFiles(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125;); &#125;) .ConfigureServices(service =&gt; &#123; Console.WriteLine(\"ConfigureServices\"); &#125;) .ConfigureAppConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureAppConfiguration\"); &#125;) .ConfigureHostConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureHostConfiguration\"); &#125;); &#125;&#125; 但是为了代码结构更加合理，还是需要用Startup这个类来分离变动比较大的代码 通常是在Startup.ConfigureServices的方法里做服务注册，一般是Addxxx 在Startup.Configure决定注册那些中间件到处理过程中去","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core使用Cap","slug":"dotnet-core-cap","date":"2020-03-27T05:13:13.000Z","updated":"2020-04-01T09:05:51.498Z","comments":true,"path":"2020/03/27/dotnet-core-cap/","link":"","permalink":"http://www.dimsum.fun/2020/03/27/dotnet-core-cap/","excerpt":"","text":"准备工作 项目设定 创建ServiceA 创建ServiceB 准备工作CAP需要依赖消息队列和数据存储，支持情况如下：消息队列 123KafkaRabbitMQAzureServiceBus 数据存储 1234SqlServerMySqlPostgreSqlMongoDB 两者自行搭配选择即可，其中SqlServer和RabbitMQ在docker中的安装可参照我另一篇备忘开发常用的docker镜像 项目设定 两个服务，分别为ServiceA,ServiceB SqlServer使用CapDemo数据库，默认sa账号，密码为Today_is_20200328，端口为默认的1433端口 RabbitMQ安装地址为本机，默认端口，账号密码为admin/admin 创建ServiceA 在Visual Studio 2019中创建空白解决方案，取名为Jiamiao.x.CapDemo 在解决方案中新建Asp.net core项目，名字为Jiamiao.x.CapDemo.ServiceA，.net core版本为3.1 nuget安装以下4个包 1234DotNetCore.CAPDotNetCore.CAP.DashboardDotNetCore.CAP.RabbitMQDotNetCore.CAP.SqlServer 在Startup.cs的ConfigureServices方法中加入以下代码 1234567891011services.AddCap(options =&gt;&#123; options.UseSqlServer(\"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1\"); options.UseRabbitMQ(r =&gt; &#123; r.HostName = \"127.0.0.1\"; r.UserName = \"admin\"; r.Password = \"admin\"; &#125;); options.UseDashboard();&#125;); 此时直接运行项目，如果数据库与消息队列均能正常连接，则会在数据库中生成以下两张表 12cap.Publishedcap.Received 在Controllers/WeatherForecastController.cs中编写消息发布代码 6.1 通过构造函数依赖注入ICapPublisher对象 6.2 发布消息只需要调用ICapPublisher对象的PublishAsync或Publish方法，传入参数为队列名和消息值，全部代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace Jiamiao.x.CapDemo.ServiceA.Controllers&#123; [ApiController] [Route(\"[controller]\")] public class WeatherForecastController : ControllerBase &#123; private static readonly string[] Summaries = new[] &#123; \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\" &#125;; private readonly ILogger&lt;WeatherForecastController&gt; _logger; private readonly ICapPublisher _capPublisher; public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,ICapPublisher capPublisher) &#123; _logger = logger; _capPublisher = capPublisher; &#125; [HttpGet] public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; Get() &#123; await _capPublisher.PublishAsync(\"jiamiao.x.cap.demo.show.time\", DateTime.Now); var rng = new Random(); return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast &#123; Date = DateTime.Now.AddDays(index), TemperatureC = rng.Next(-20, 55), Summary = Summaries[rng.Next(Summaries.Length)] &#125;) .ToArray(); &#125; &#125;&#125; 编写接收消息代码，接收消息有两种方式，一种在控制器中，即代码写在***Controller.cs中，另一种是在非控制器中，一般为***Service.cs中，以下分两步执行，因为CAP在默认情况下一个服务多个地方进行订阅，只会进行一次接收，除非进行分组(后面介绍)，所以8/9两个步骤在测试时需要注释其中一个，只保留另一个 编写在控制器中接收消息的代码，直接在控制器中写对应方法，方法参数为发送消息时传入的消息值类型，方法无返回值，再加上方法标签CapSubscribe即可，具体代码如下: 123456789101112131415161718using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;using Microsoft.AspNetCore.Mvc;namespace Jiamiao.x.CapDemo.ServiceA.Controllers&#123; public class SubController : Controller &#123; [CapSubscribe(\"jiamiao.x.cap.demo.show.time\")] public void ShowTime(DateTime value) &#123; Console.WriteLine($\"接受方：SubController.ShowTime 接收到值：&#123;value&#125;\"); &#125; &#125;&#125; 做到这步可以进行一次测试，就可以发现访问/WeatherForecast这个接口，会发送一条当前时间的消息出去，同时接收方也会在控制台打印出接收到的消息 编写服务中接收消息的代码，需要注意接收消息的类需要继承ICapSubscribe接口，同时这里为了方便进行依赖注入，这里我们也自己定义了一个ISubscriberService接口，同时服务需要在Startup.cs的ConfigureServices方法中进行注册 9.1 ISubscriberService.cs代码如下 123456789101112using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;namespace Jiamiao.x.CapDemo.ServiceA.Services&#123; public interface ISubscriberService &#123; void ReceivedShowTimeMessage(DateTime value); &#125;&#125; 9.2 SubscriberService.cs代码如下 1234567891011121314151617using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;namespace Jiamiao.x.CapDemo.ServiceA.Services&#123; public class SubscriberService: ISubscriberService, ICapSubscribe &#123; [CapSubscribe(\"jiamiao.x.cap.demo.show.time\")] public void ReceivedShowTimeMessage(DateTime value) &#123; Console.WriteLine($\"接受方：SubscriberService.ReceivedShowTimeMessage 接收到值：&#123;value&#125;\"); &#125; &#125;&#125; 9.3 服务注册代码如下 1services.AddScoped&lt;ISubscriberService, SubscriberService&gt;(); 注意：这行服务注册代码需要在services.AddCap这个方法之前注册，否则CAP在进行接口扫描的时候找不到对应已经实现了ICapSubscribe接口的实现类，则无法进行订阅者注册 注释掉第8步，进行第9步的测试，效果应该与第8步一致 有时候一个消息需要多个消费者同时消费，则可以使用Group概念，消息发送代码不变，在标记CapSubscribe的时候，使用Group参数，多个Group订阅同个消息Id，消息则会对应分发到多个Group中，同个Group只能消费一次，即一个Group对一个消息Id订阅多次，也会只接收一次，具体代码如下SubscriberService.cs中新增Group参数1[CapSubscribe(\"jiamiao.x.cap.demo.show.time\",Group = \"SubscriberService\")] SubController.cs中新增Group参数1[CapSubscribe(\"jiamiao.x.cap.demo.show.time\",Group = \"SubController\")] 测试Group功能，将项目跑起来，此时再访问发送消息的api，会在控制台中打印出两条消息接收记录 创建ServiceBServiceB使用EFCore来进行配置，找ServiceA步骤2创建Jiamiao.x.CapDemo.ServiceB项目，因为.Net Core 3.1没有自带EFCore，所以这里除了CAP的4个包之外，还需要nuget安装EFCore的两个包，汇总起来需要nuget安装的包如下： 123456DotNetCore.CAPDotNetCore.CAP.DashboardDotNetCore.CAP.RabbitMQDotNetCore.CAP.SqlServerMicrosoft.EntityFrameworkCoreMicrosoft.EntityFrameworkCore.SqlServer创建ServiceDbContext.cs文件，代码如下 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using Microsoft.EntityFrameworkCore;namespace Jiamiao.x.CapDemo.ServiceB.Infrastructure&#123; public class ServiceDbContext: DbContext &#123; public ServiceDbContext(DbContextOptions&lt;ServiceDbContext&gt; options):base(options) &#123; &#125; &#125;&#125;在Startup.cs中配置EFCore和CAP，具体代码如下： 1234567891011121314151617services.AddDbContext&lt;ServiceDbContext&gt;(options =&gt;&#123; options.UseSqlServer( \"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1\");&#125;);services.AddCap(options =&gt;&#123; options.UseEntityFramework&lt;ServiceDbContext&gt;(); options.UseRabbitMQ(r =&gt; &#123; r.HostName = \"127.0.0.1\"; r.UserName = \"admin\"; r.Password = \"admin\"; &#125;); options.UseDashboard();&#125;);后续操作与ServiceA类似，需要注意：多个站点订阅同个消息Id，消息会往多个站点进行发送 附上CAP的Github地址:https://github.com/dotnetcore/CAP 还有一些配合EF的操作还没来得及写，有空再说吧","categories":[{"name":".NET","slug":"NET","permalink":"http://www.dimsum.fun/categories/NET/"}],"tags":[{"name":".NET Core","slug":"NET-Core","permalink":"http://www.dimsum.fun/tags/NET-Core/"},{"name":"CAP","slug":"CAP","permalink":"http://www.dimsum.fun/tags/CAP/"},{"name":"MicroServices","slug":"MicroServices","permalink":"http://www.dimsum.fun/tags/MicroServices/"}]},{"title":"开发常用的docker镜像","slug":"chang-yong-docker","date":"2020-03-27T04:12:12.000Z","updated":"2020-04-01T09:05:19.348Z","comments":true,"path":"2020/03/27/chang-yong-docker/","link":"","permalink":"http://www.dimsum.fun/2020/03/27/chang-yong-docker/","excerpt":"","text":"Redis Elasticsearch(集群) RabbitMq SqlServer 2017 主要用于开发阶段，不涉及生产环境配置，无权限自行添加sudo Redis 获取镜像1docker pull redis 运行Redis1docker run -p 6379:6379 -d redis:lastes redis-server Elasticsearch(集群) 说明： 这里这里使用的是Elasticsearch 7.3.0版本 集群一共有3个Container，一个Master，两个Slave 配置文件中的192.168.2.58为对应节点的IP地址 具体配置:12345678910111213141516Elasticsearch集群 |------ Master |--- 端口：9500 |--- TCP端口：9300 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data |------ Slave1 |--- 端口：9600 |--- TCP端口：9301 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data |------ Slave2 |--- 端口：9700 |--- TCP端口：9302 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data 获取镜像1docker pull elasticsearch:7.3.0 在宿主机创建各个节点的elasticsearch.yml配置文件，具体内容如下: Master节点，配置文件路径：~/var/elasticsearch/config/master/elasticsearch.yml12345678910111213141516171819# 设置支持Elasticsearch-Headhttp.cors.enabled: truehttp.cors.allow-origin: \"*\"# 设置集群Master配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: master# 节点是否为Master，设置为true的话，说明此节点为Master节点node.master: true# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9500# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9300# 手动指定可以成为Master的所有节点的Name或者IP，这些配置将会在第一次选举中进行计算cluster.initial_master_nodes: [\"master\"]# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9301\", \"192.168.2.58:9302\"] Slave1节点，配置文件路径：~/var/elasticsearch/config/slave1/elasticsearch.yml1234567891011121314# 设置集群Slave配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: slave1# 节点是否为Master，设置为true的话，说明此节点为master节点node.master: false# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9600# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9301# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9300\", \"192.168.2.58:9302\"] Slave2节点，配置文件路径：~/var/elasticsearch/config/slave2/elasticsearch.yml1234567891011121314# 设置集群Slave配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: slave2# 节点是否为Master，设置为true的话，说明此节点为master节点node.master: false# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9700# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9302# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9300\", \"192.168.2.58:9301\"] 创建3个节点的data文件夹 123~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data 运行节点 运行Master节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/master/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/master/data:/usr/share/elasticsearch/data --name esMaster -p 9500:9500 -p 9300:9300 elasticsearch:7.3.0 运行Slave1节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/slave1/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave1/data:/usr/share/elasticsearch/data --name esSlave1 -p 9600:9600 -p 9301:9301 elasticsearch:7.3.0 运行Slave2节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/slave2/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave2/data:/usr/share/elasticsearch/data --name esSlave2 -p 9700:9700 -p 9302:9302 elasticsearch:7.3.0 检查运行状态 运行docker ps查看正在运行的Container，确保以上3个容器正常运行 访问http://127.0.0.1:9500/_cat/nodes?v查看是否有3个节点信息，如果节点运行正常，应该有如下信息1234ip heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name172.17.0.2 32 96 70 3.03 0.82 0.28 di - slave1172.17.0.3 30 96 70 3.03 0.82 0.28 di - slave2172.17.0.4 33 96 70 3.03 0.82 0.28 dim * master 安装Elasticsearch-Head1docker run -d --name es-head -p 9100:9100 mobz/elasticsearch-head:5 运行成功后浏览器访问链接:http://127.0.0.1:9100，将里面的连接地址修改为:http://localhost:9500，保存即可看到3个节点的集群信息 安装IK分词软件 这部分操作3个节点均需要操作一边 ElasticSearch版本为7.3.0，对应IK分词版本为7.3,下载链接IK分词 具体操作就是将下载下来的包放在各个节点的共享卷里，然后进入ES容器内命令行，解压并将文件拷贝到plugins文件夹中，重启容器 RabbitMq 获取镜像1docker pull rabbitmq:management 运行镜像，设置用户名密码(admin/admin)1docker run -dit --name Myrabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:managemen 进入管理界面 http://localhost:15672 SqlServer 2017 获取镜像1docker pull mcr.microsoft.com/mssql/server:2017-latest 运行镜像，设置SA密码为Today_is_202003281docker run -e \"ACCEPT_EULA=Y\" -e \"SA_PASSWORD=Today_is_20200328\" -p 1433:1433 --name mssql -d mcr.microsoft.com/mssql/server:2017-latest","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.dimsum.fun/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.dimsum.fun/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://www.dimsum.fun/tags/elasticsearch/"}]}],"categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/categories/ASP-NET-Core/"},{"name":"Docker","slug":"Docker","permalink":"http://www.dimsum.fun/categories/Docker/"},{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"},{"name":"StepByStep","slug":"StepByStep","permalink":"http://www.dimsum.fun/categories/StepByStep/"},{"name":".NET","slug":"NET","permalink":"http://www.dimsum.fun/categories/NET/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"gRPC","slug":"gRPC","permalink":"http://www.dimsum.fun/tags/gRPC/"},{"name":"DDD","slug":"DDD","permalink":"http://www.dimsum.fun/tags/DDD/"},{"name":"CQRS","slug":"CQRS","permalink":"http://www.dimsum.fun/tags/CQRS/"},{"name":"MediatR","slug":"MediatR","permalink":"http://www.dimsum.fun/tags/MediatR/"},{"name":"EntityFramework Core","slug":"EntityFramework-Core","permalink":"http://www.dimsum.fun/tags/EntityFramework-Core/"},{"name":"ORM","slug":"ORM","permalink":"http://www.dimsum.fun/tags/ORM/"},{"name":"Docker","slug":"Docker","permalink":"http://www.dimsum.fun/tags/Docker/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"},{"name":"微服务","slug":"微服务","permalink":"http://www.dimsum.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://www.dimsum.fun/tags/Visual-Studio-Code/"},{"name":"特基础","slug":"特基础","permalink":"http://www.dimsum.fun/tags/%E7%89%B9%E5%9F%BA%E7%A1%80/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://www.dimsum.fun/tags/NET-Core/"},{"name":"CAP","slug":"CAP","permalink":"http://www.dimsum.fun/tags/CAP/"},{"name":"MicroServices","slug":"MicroServices","permalink":"http://www.dimsum.fun/tags/MicroServices/"},{"name":"docker","slug":"docker","permalink":"http://www.dimsum.fun/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://www.dimsum.fun/tags/elasticsearch/"}]}