{"meta":{"title":"dimsum","subtitle":"","description":"","author":"Jiamiao.x","url":"http://doc.dimsum.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-27T07:39:01.629Z","updated":"2020-03-27T07:22:15.606Z","comments":false,"path":"/404.html","permalink":"http://doc.dimsum.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2020-03-27T07:39:01.578Z","updated":"2020-03-27T07:22:15.608Z","comments":false,"path":"books/index.html","permalink":"http://doc.dimsum.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-27T07:39:01.549Z","updated":"2020-03-27T07:22:15.609Z","comments":false,"path":"categories/index.html","permalink":"http://doc.dimsum.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-03-27T07:39:01.525Z","updated":"2020-03-27T07:22:15.609Z","comments":true,"path":"links/index.html","permalink":"http://doc.dimsum.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-27T07:39:01.501Z","updated":"2020-03-27T07:22:15.609Z","comments":false,"path":"repository/index.html","permalink":"http://doc.dimsum.com/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-27T07:39:01.605Z","updated":"2020-03-27T07:22:15.608Z","comments":false,"path":"about/index.html","permalink":"http://doc.dimsum.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2020-03-27T07:39:01.476Z","updated":"2020-03-27T07:22:15.610Z","comments":false,"path":"tags/index.html","permalink":"http://doc.dimsum.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":".NET Core开发实战课程备忘(3) -- 作用域与对象释放行为","slug":"DependencyInjectionScopeAndDisposable_document","date":"2020-03-30T16:00:00.000Z","updated":"2020-03-31T04:28:11.520Z","comments":true,"path":"2020/03/31/DependencyInjectionScopeAndDisposable_document/","link":"","permalink":"http://doc.dimsum.com/2020/03/31/DependencyInjectionScopeAndDisposable_document/","excerpt":"","text":"实现IDisposable接口类型的释放 建议 代码验证 项目 创建测试服务 测试Transient服务的释放时机 测试Scope服务的释放时机 测试Singleton服务的释放时机 避坑 自己new服务 在跟容器获取Transient服务 实现IDisposable接口类型的释放 DI只负责释放其创建的对象实例 DI在容器或子容器释放时，释放尤其创建的对象实例 建议 避免在根容器获取实现了IDisposable接口的瞬时服务 避免手动创建实现了IDisposable对象，应该使用容器来管理其生命周期 代码验证项目创建名为DependencyInjectionScopeAndDisposableDemo的ASP.NET Core项目，类型为API 创建测试服务创建测试服务类OrderService.cs，代码如下： 123456789101112using System;namespace DependencyInjectionScopeAndDisposableDemo.Services&#123; public interface IOrderService &#123; &#125; public class DisposableOrderService : IOrderService, IDisposable &#123; public void Dispose() &#123; Console.WriteLine($\"DisposableOrderService Disposed:&#123;this.GetHashCode()&#125;\"); &#125; &#125;&#125; 测试Transient服务的释放时机在Startup.ConfigureServices里注册一个瞬时服务 1services.AddTransient&lt;IOrderService, DisposableOrderService&gt;(); 在WeatherForecastController里的Get方法通过方法参数的形式获取两个IOrderService接口对象，代码如下： 123456[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2)&#123; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 保存之后运行项目，可以看到在打印接口请求处理结束之后两个对象都被释放掉，类似以下信息 123&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:64923656DisposableOrderService Disposed:11404313 得出的结论是：transient对象会在使用后被释放 测试Scope服务的释放时机注释掉上一步注册瞬时服务的代码，重新注册一个scope服务，这里使用工厂模式，只是熟悉以下工厂模式的写法，没特殊意义 1services.AddScoped&lt;IOrderService&gt;(serviceProvider =&gt; new DisposableOrderService()); 这时运行项目，控制台会打印出一个对象被释放，因为scope服务在当前容器内为单例，下面就这个结论再次测试以下，用using创建一个服务容器出来，看是否能创建出新的服务对象，并且代码运行超过using范围，服务对象是否会被释放。在WeatherForecastController的Get方法新增创建容器和获取服务操作，代码如下： 12345678910111213[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2)&#123; Console.WriteLine(\"========1==========\"); using (var scope = HttpContext.RequestServices.CreateScope()) &#123; var service = scope.ServiceProvider.GetService&lt;IOrderService&gt;(); &#125; Console.WriteLine(\"========2==========\"); Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; HttpContext.RequestServices.CreateScope()表示从根容器中创建一个子容器出来，scope.ServiceProvider.GetService&lt;IOrderService&gt;()表示从创建出来的子容器获取IOrderService的服务实现对象，运行项目可以得到两个对象被释放的信息，类似以下信息： 12345&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:5568949&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:31307802 得出结论是：scope对象会在对象产生的容器被释放的时候同时一起释放 测试Singleton服务的释放时机注释掉上一步注册scope服务的代码，重新注册一个singleton服务，这里一样使用工厂模式 1services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt; new DisposableOrderService()); 将WeatherForecastController的Get方法修改为以下代码： 1234567891011[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2,[FromServices] IHostApplicationLifetime hostApplicationLifetime,[FromQuery]bool isStop=false)&#123; if (isStop) &#123; hostApplicationLifetime.StopApplication(); &#125; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 这里有获取了另一个服务IHostApplicationLifetime，这个服务对象控制了整个应用程序的生命周期，可以调用这个服务对象的StopApplication方法来停止应用程序，即停止整个站点，为了方便测试这里用了isStop这个参数来控制是否停止应用程序 运行项目，不管怎么刷新/WeatherForecast链接，都不会有对象被释放的信息打印出来，访问/WeatherForecast?isStop=true的时候，会看到应用程序被停止，同时打印出对象被释放的信息，类似以下信息： 12Application is shutting down...DisposableOrderService Disposed:3165221 得出结论是：scope对象只会在根容器释放的时候才会被释放，即所有单例模式的对象都会被注册在根容器上面 避坑自己new服务开始有个结论：DI只负责释放其创建的对象实例，这里进行验证以下自己new一个对象然后注入到容器中，看看是否能释放。这里注入了一个singleton对象，需注释掉上面做测试的代码，代码如下 12var myOrderService &#x3D; new DisposableOrderService();services.AddSingleton&lt;IOrderService&gt;(myOrderService); 控制器代码不用改，运行项目，访问/WeatherForecast发现不会有对象被释放，访问/WeatherForecast?isStop=true时，应用程序被停止，但是也一样没有对象被释放的信息，所以这个对象最终还是没被释放 在跟容器获取Transient服务注释掉上面的测试代码，在Startup.ConfigureServices中注册一个瞬时服务，代码如下： 1services.AddTransient&lt;IOrderService, DisposableOrderService&gt;(); 在Startup.Configure中从根容器获取瞬时服务对象，代码如下： 123456789101112131415public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var s = app.ApplicationServices.GetService&lt;IOrderService&gt;(); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 将WeatherForecastController的Get方法修改为以下代码： 1234567891011[HttpGet]public int Get([FromServices] IHostApplicationLifetime hostApplicationLifetime, [FromQuery]bool isStop = false)&#123; if (isStop) &#123; hostApplicationLifetime.StopApplication(); &#125; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 运行项目，访问/WeatherForecast接口，发现并不会有对象被释放的信息，在带上isStop=true的参数的时候，应用程序被停止，这时才有对象被释放的信息，类似信息如下： 12Application is shutting down...DisposableOrderService Disposed:41149443 得出结论：由于根容器只会在应用程序整个退出时回收，这就意味着即使这是个瞬时服务，但是应用程序不退出，这些对象会一直积累在应用程序内不得释放","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(2) -- 依赖注入：良好架构的起点","slug":"DependencyInjection_document","date":"2020-03-29T16:00:00.000Z","updated":"2020-03-30T16:34:23.805Z","comments":true,"path":"2020/03/30/DependencyInjection_document/","link":"","permalink":"http://doc.dimsum.com/2020/03/30/DependencyInjection_document/","excerpt":"","text":"为什么要使用依赖注入框架(IoC框架) 依赖注入框架组件包 依赖注入框架核心类型 生命周期 代码演示 项目 示例服务类 验证不同生命周期的实现 注册不同生命周期的服务 在方法参数中获得服务进行验证 其他方式注册服务(以单例模式为例) 直接new对象 通过工厂模式注册对象 尝试注册服务 移除和替换服务 移除服务 替换服务 泛型服务注册 服务对象的获取 为什么要使用依赖注入框架(IoC框架) 借助依赖注入框架，我们可以轻松管理类之间的依赖，帮助我们在构建应用是遵循设计规则，确保代码的可维护性和可拓展性 ASP.NET Core的整个架构中，依赖注入框架提供了对象创建和生命周期管理的核心能力，各个组件相互写作，也是由依赖注入框架的能力来实现的 依赖注入框架组件包12Microsoft.Extensions.DependencyInjection.Abstractions &#x2F;&#x2F;抽象包Microsoft.Extensions.DependencyInjection &#x2F;&#x2F;具体实现 依赖注入框架核心类型1234IServiceCollection &#x2F;&#x2F;负责服务的注册ServiceDescriptor &#x2F;&#x2F;每个服务注册时的信息IServiceProvider &#x2F;&#x2F;具体的容器，也是由ServiceCollection Build出来IServiceScope &#x2F;&#x2F;表示一个容器的子容器的生命周期 生命周期123Singleton &#x2F;&#x2F;单例：在整个根容器的生命周期内获得的都是同一个单例对象Scoped &#x2F;&#x2F;作用域：在我的Scope的生命周期内，如果我的容器释放掉，则意味着我的对象释放掉，在这个生命周期范围内获得到的是一个单例对象Transient &#x2F;&#x2F;瞬时：每一次从容器里获取对象时都产生一个新的对象 代码演示项目创建名为DependencyInjectionDemo的ASP.NET Core项目，类型为API 示例服务类一共有5个示例服务类接口，分别为 1234567891011IGenericService&lt;T&gt; |-- GenericService&lt;T&gt; &#x2F;&#x2F;对应实现类IMyScopeService |-- MyScopeService &#x2F;&#x2F;对应实现类IMySingletonService |-- MySingletonService &#x2F;&#x2F;对应实现类IMyTransientService |-- MyTransientService &#x2F;&#x2F;对应实现类IOrderService |-- OrderService &#x2F;&#x2F;对应实现类 |-- OrderServiceEX &#x2F;&#x2F;对应实现类 因为是示例服务类，所以所有类和服务均没有属性和方法，纯粹为了验证服务注册和服务对象 验证不同生命周期的实现注册不同生命周期的服务在Startup.ConfigureServices方法中新增以下代码 123456// 注册Singleton服务services.AddSingleton&lt;IMySingletonService, MySingletonService&gt;();// 注册Scope服务services.AddScoped&lt;IMyScopeService, MyScopeService&gt;();// 注册Transient服务services.AddTransient&lt;IMyTransientService, MyTransientService&gt;(); 在方法参数中获得服务进行验证 修改WeatherForecastController类的Route标识为[Route(&quot;[controller]/[action]&quot;)]，方便进行测试 在WeatherForecastController新增GetService方法，代码如下：1234567891011121314151617[HttpGet]public int GetService([FromServices] IMySingletonService singletonService1, [FromServices] IMySingletonService singletonService2, [FromServices] IMyScopeService scopeService1, [FromServices] IMyScopeService scopeService2, [FromServices] IMyTransientService transientService1, [FromServices] IMyTransientService transientService2)&#123; Console.WriteLine($\"&#123;nameof(singletonService1)&#125;:&#123;singletonService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(singletonService2)&#125;:&#123;singletonService2.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(scopeService1)&#125;:&#123;scopeService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(scopeService2)&#125;:&#123;scopeService2.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(transientService1)&#125;:&#123;transientService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(transientService2)&#125;:&#123;transientService2.GetHashCode()&#125;\"); Console.WriteLine(\"=========请求结束========\"); return 1;&#125; 运行项目，访问/WeatherForecast/GetService，控制台会打印出类似以下信息1234567singletonService1:23488915singletonService2:23488915scopeService1:24854661scopeService2:24854661transientService1:38972574transientService2:14645893&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 可以看出IMySingletonService的实现对象属于同一个对象，IMyTransientService的实现对象有多个，目前看IMyScopeService的实现对象为同一个，但是再次访问/WeatherForecast/GetService接口，就可以发现IMyScopeService的实现对象为新的对象，而IMySingletonService的实现对象还是上次访问的那个，打印信息如下1234567singletonService1:23488915singletonService2:23488915scopeService1:6630602scopeService2:6630602transientService1:5024928transientService2:38414640&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 其他方式注册服务(以单例模式为例)直接new对象在Startup.ConfigureServices方法中新增以下代码 1services.AddSingleton&lt;IOrderService&gt;(new OrderService()); 通过工厂模式注册对象使用工厂模式注册对象，可以在委托中使用IServiceProvider参数，这也就意味着可以从容器里获取多个对象，然后进行组装，得到我们最终需要的实现实例，可以把工厂类设计的比较复杂，比如说我们的实现类依赖了容器里面的另外一个类的情况，或者我们期望用另外一个类来包装我们原有的实现的时候在Startup.ConfigureServices方法中新增以下代码 1234services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt;&#123; return new OrderServiceEx();&#125;); 尝试注册服务尝试注册服务有两种情况 当指定接口已有实现类，则不再注册服务，代码如下：1services.TryAddSingleton&lt;IOrderService, OrderServiceEx&gt;(); 当指定接口已有实现类，但是已注册的实现类不包含当前指定的实现类，则注册进去，如果已经包含当前的实现类，则不再注册服务，代码如下：1services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IOrderService,OrderService&gt;()); 在控制器里验证是否有多个实现类注册，可通过下面的方法验证(需要自行注释或修改Startup里面的服务注册情况)123456789[HttpGet]public int GetServiceList([FromServices] IEnumerable&lt;IOrderService&gt; orderServices)&#123; foreach (var item in orderServices) &#123; Console.WriteLine($\"获取到服务实例：&#123;item.ToString()&#125;:&#123;item.GetHashCode()&#125;\"); &#125; return 1;&#125; 移除和替换服务移除服务指的是直接从容器中移除指定接口的所有实现类，代码如下：1services.RemoveAll&lt;IOrderService&gt;(); 替换服务指的是替换指定接口的实现类，同时也会替换该服务的生命周期，代码如下：1services.Replace(ServiceDescriptor.Singleton&lt;IOrderService, OrderServiceEx&gt;()); 泛型服务注册即对泛型服务注册，代码如下： 1services.AddSingleton(typeof(IGenericService&lt;&gt;), typeof(GenericService&lt;&gt;)); 可以通过在控制器的构造函数中获取到服务对象，代码如下： 1234public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,IOrderService orderService,IGenericService&lt;IOrderService&gt; genericService)&#123; _logger = logger;&#125; 可以通过断点查看最终IGenericService的IOrderService为哪个实现类 服务对象的获取通过上面可以看出，服务对象有两种获取方式，一种是通过构造函数直接注入，一种是通过函数参数，使用[FromServices]标签来注入 一般按照使用情况来确定用哪种方式，如果整个类使用地方比较多，则使用构造函数注入，如果只有某一个方法使用，则一般使用函数参数来注入","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(1) -- ASP.NET Core的启动流程","slug":"StartupDemo_document","date":"2020-03-29T16:00:00.000Z","updated":"2020-03-30T16:33:21.980Z","comments":true,"path":"2020/03/30/StartupDemo_document/","link":"","permalink":"http://doc.dimsum.com/2020/03/30/StartupDemo_document/","excerpt":"","text":"课程目标 创建项目 添加日志代码 运行结果 结论 另外 课程目标主要是掌握ASP.NET Core应用程序启动的流程，同时了解启动过程中哪些方法做了哪些操作 创建项目创建ASP.NET Core Web项目，项目类型选择API，直接创建即可 添加日志代码本实例不涉及任何业务代码，纯粹只是添加日志查看各个方法的调用流程 修改Program.cs，以下直接放修改后的代码 12345678910111213141516171819202122232425262728293031323334using System;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateHostBuilder(args).Build().Run(); &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; Console.WriteLine(\"ConfigureWebHostDefaults\"); webBuilder.UseStartup&lt;Startup&gt;(); &#125;) .ConfigureServices(service =&gt; &#123; Console.WriteLine(\"ConfigureServices\"); &#125;) .ConfigureAppConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureAppConfiguration\"); &#125;) .ConfigureHostConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureHostConfiguration\"); &#125;); &#125;&#125; 修改Startup.cs，以下直接放修改后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Startup &#123; public Startup(IConfiguration configuration) &#123; Console.WriteLine(\"Startup.Ctor\"); Configuration = configuration; &#125; public IConfiguration Configuration &#123; get; &#125; public void ConfigureServices(IServiceCollection services) &#123; Console.WriteLine(\"Startup.ConfigureServices\"); services.AddControllers(); &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; Console.WriteLine(\"Startup.Configure\"); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseStaticFiles(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125; &#125;&#125; 运行结果参照上面将代码修改完，直接运行代码，控制台将打印出以下信息 1234567ConfigureWebHostDefaultsConfigureHostConfigurationConfigureAppConfigurationStartup.CtorStartup.ConfigureServicesConfigureServicesStartup.Configure 结论以下为ASP.NET Core启动运行流程 ConfigureWebHostDefaults：注册了应用程序必要的几个组件，比如说配置的组件、容器的组件等 ConfigureHostConfiguration：配置程序启动时必要的配置，比如说程序启动时所需要监听的端口、需要监听的URL地址等，在这个过程可以嵌入我们自己的配置内容注入到配置的框架中去 ConfigureAppConfiguration：嵌入我们自己的配置文件，供应用程序来读取，这些配置将来会在后续的应用程序执行过程中每个组件读取 ConfigureServices/ConfigureLogging/Startup/Startup.ConfigureServices：这些都是往容器里面来注入我们的应用的组件 Startup.Configure：注入中间件，处理HttpContext整个的请求过程 另外从代码运行来看，Startup.cs这个类可以被整合到Program.cs里的ConfigureWebHostDefaults方法中，可以直接ConfigureWebHostDefaults方法中直接使用webBuilder调用ConfigureServices和Configure两个方法具体可以参考以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateHostBuilder(args).Build().Run(); &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; Console.WriteLine(\"ConfigureWebHostDefaults\"); webBuilder.ConfigureServices(services =&gt; &#123; Console.WriteLine(\"Program.ConfigureServices\"); services.AddControllers(); &#125;); webBuilder.Configure(app =&gt; &#123; Console.WriteLine(\"Program.Configure\"); app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseStaticFiles(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125;); &#125;) .ConfigureServices(service =&gt; &#123; Console.WriteLine(\"ConfigureServices\"); &#125;) .ConfigureAppConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureAppConfiguration\"); &#125;) .ConfigureHostConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureHostConfiguration\"); &#125;); &#125;&#125; 但是为了代码结构更加合理，还是需要用Startup这个类来分离变动比较大的代码 通常是在Startup.ConfigureServices的方法里做服务注册，一般是Addxxx 在Startup.Configure决定注册那些中间件到处理过程中去","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":"开发常用的docker镜像","slug":"chang-yong-docker","date":"2020-03-26T16:00:00.000Z","updated":"2020-03-28T16:58:35.771Z","comments":true,"path":"2020/03/27/chang-yong-docker/","link":"","permalink":"http://doc.dimsum.com/2020/03/27/chang-yong-docker/","excerpt":"","text":"Redis Elasticsearch(集群) RabbitMq SqlServer 2017 主要用于开发阶段，不涉及生产环境配置，无权限自行添加sudo Redis 获取镜像1docker pull redis 运行Redis1docker run -p 6379:6379 -d redis:lastes redis-server Elasticsearch(集群) 说明： 这里这里使用的是Elasticsearch 7.3.0版本 集群一共有3个Container，一个Master，两个Slave 配置文件中的192.168.2.58为对应节点的IP地址 具体配置:12345678910111213141516Elasticsearch集群 |------ Master |--- 端口：9500 |--- TCP端口：9300 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data |------ Slave1 |--- 端口：9600 |--- TCP端口：9301 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data |------ Slave2 |--- 端口：9700 |--- TCP端口：9302 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data 获取镜像1docker pull elasticsearch:7.3.0 在宿主机创建各个节点的elasticsearch.yml配置文件，具体内容如下: Master节点，配置文件路径：~/var/elasticsearch/config/master/elasticsearch.yml12345678910111213141516171819# 设置支持Elasticsearch-Headhttp.cors.enabled: truehttp.cors.allow-origin: \"*\"# 设置集群Master配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: master# 节点是否为Master，设置为true的话，说明此节点为Master节点node.master: true# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9500# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9300# 手动指定可以成为Master的所有节点的Name或者IP，这些配置将会在第一次选举中进行计算cluster.initial_master_nodes: [\"master\"]# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9301\", \"192.168.2.58:9302\"] Slave1节点，配置文件路径：~/var/elasticsearch/config/slave1/elasticsearch.yml1234567891011121314# 设置集群Slave配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: slave1# 节点是否为Master，设置为true的话，说明此节点为master节点node.master: false# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9600# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9301# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9300\", \"192.168.2.58:9302\"] Slave2节点，配置文件路径：~/var/elasticsearch/config/slave2/elasticsearch.yml1234567891011121314# 设置集群Slave配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: slave2# 节点是否为Master，设置为true的话，说明此节点为master节点node.master: false# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9700# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9302# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9300\", \"192.168.2.58:9301\"] 创建3个节点的data文件夹 123~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data 运行节点 运行Master节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/master/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/master/data:/usr/share/elasticsearch/data --name esMaster -p 9500:9500 -p 9300:9300 elasticsearch:7.3.0 运行Slave1节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/slave1/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave1/data:/usr/share/elasticsearch/data --name esSlave1 -p 9600:9600 -p 9301:9301 elasticsearch:7.3.0 运行Slave2节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/slave2/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave2/data:/usr/share/elasticsearch/data --name esSlave2 -p 9700:9700 -p 9302:9302 elasticsearch:7.3.0 检查运行状态 运行docker ps查看正在运行的Container，确保以上3个容器正常运行 访问http://127.0.0.1:9500/_cat/nodes?v查看是否有3个节点信息，如果节点运行正常，应该有如下信息1234ip heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name172.17.0.2 32 96 70 3.03 0.82 0.28 di - slave1172.17.0.3 30 96 70 3.03 0.82 0.28 di - slave2172.17.0.4 33 96 70 3.03 0.82 0.28 dim * master 安装Elasticsearch-Head1docker run -d --name es-head -p 9100:9100 mobz/elasticsearch-head:5 运行成功后浏览器访问链接:http://127.0.0.1:9100，将里面的连接地址修改为:http://localhost:9500，保存即可看到3个节点的集群信息 安装IK分词软件 这部分操作3个节点均需要操作一边 ElasticSearch版本为7.3.0，对应IK分词版本为7.3,下载链接IK分词 具体操作就是将下载下来的包放在各个节点的共享卷里，然后进入ES容器内命令行，解压并将文件拷贝到plugins文件夹中，重启容器 RabbitMq 获取镜像1docker pull rabbitmq:management 运行镜像，设置用户名密码(admin/admin)1docker run -dit --name Myrabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:managemen 进入管理界面 http://localhost:15672 SqlServer 2017 获取镜像1docker pull mcr.microsoft.com/mssql/server:2017-latest 运行镜像，设置SA密码为Today_is_202003281docker run -e \"ACCEPT_EULA=Y\" -e \"SA_PASSWORD=Today_is_20200328\" -p 1433:1433 --name mssql -d mcr.microsoft.com/mssql/server:2017-latest","categories":[{"name":"Docker","slug":"Docker","permalink":"http://doc.dimsum.com/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://doc.dimsum.com/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://doc.dimsum.com/tags/elasticsearch/"}]},{"title":".NET Core使用Cap","slug":"dotnet-core-cap","date":"2020-03-26T16:00:00.000Z","updated":"2020-03-28T17:05:59.262Z","comments":true,"path":"2020/03/27/dotnet-core-cap/","link":"","permalink":"http://doc.dimsum.com/2020/03/27/dotnet-core-cap/","excerpt":"","text":"准备工作 项目设定 创建ServiceA 创建ServiceB 准备工作CAP需要依赖消息队列和数据存储，支持情况如下：消息队列 123KafkaRabbitMQAzureServiceBus 数据存储 1234SqlServerMySqlPostgreSqlMongoDB 两者自行搭配选择即可，其中SqlServer和RabbitMQ在docker中的安装可参照我另一篇备忘开发常用的docker镜像 项目设定 两个服务，分别为ServiceA,ServiceB SqlServer使用CapDemo数据库，默认sa账号，密码为Today_is_20200328，端口为默认的1433端口 RabbitMQ安装地址为本机，默认端口，账号密码为admin/admin 创建ServiceA 在Visual Studio 2019中创建空白解决方案，取名为Jiamiao.x.CapDemo 在解决方案中新建Asp.net core项目，名字为Jiamiao.x.CapDemo.ServiceA，.net core版本为3.1 nuget安装以下4个包 1234DotNetCore.CAPDotNetCore.CAP.DashboardDotNetCore.CAP.RabbitMQDotNetCore.CAP.SqlServer 在Startup.cs的ConfigureServices方法中加入以下代码 1234567891011services.AddCap(options =&gt;&#123; options.UseSqlServer(\"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1\"); options.UseRabbitMQ(r =&gt; &#123; r.HostName = \"127.0.0.1\"; r.UserName = \"admin\"; r.Password = \"admin\"; &#125;); options.UseDashboard();&#125;); 此时直接运行项目，如果数据库与消息队列均能正常连接，则会在数据库中生成以下两张表 12cap.Publishedcap.Received 在Controllers/WeatherForecastController.cs中编写消息发布代码 6.1 通过构造函数依赖注入ICapPublisher对象 6.2 发布消息只需要调用ICapPublisher对象的PublishAsync或Publish方法，传入参数为队列名和消息值，全部代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace Jiamiao.x.CapDemo.ServiceA.Controllers&#123; [ApiController] [Route(\"[controller]\")] public class WeatherForecastController : ControllerBase &#123; private static readonly string[] Summaries = new[] &#123; \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\" &#125;; private readonly ILogger&lt;WeatherForecastController&gt; _logger; private readonly ICapPublisher _capPublisher; public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,ICapPublisher capPublisher) &#123; _logger = logger; _capPublisher = capPublisher; &#125; [HttpGet] public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; Get() &#123; await _capPublisher.PublishAsync(\"jiamiao.x.cap.demo.show.time\", DateTime.Now); var rng = new Random(); return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast &#123; Date = DateTime.Now.AddDays(index), TemperatureC = rng.Next(-20, 55), Summary = Summaries[rng.Next(Summaries.Length)] &#125;) .ToArray(); &#125; &#125;&#125; 编写接收消息代码，接收消息有两种方式，一种在控制器中，即代码写在***Controller.cs中，另一种是在非控制器中，一般为***Service.cs中，以下分两步执行，因为CAP在默认情况下一个服务多个地方进行订阅，只会进行一次接收，除非进行分组(后面介绍)，所以8/9两个步骤在测试时需要注释其中一个，只保留另一个 编写在控制器中接收消息的代码，直接在控制器中写对应方法，方法参数为发送消息时传入的消息值类型，方法无返回值，再加上方法标签CapSubscribe即可，具体代码如下: 123456789101112131415161718using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;using Microsoft.AspNetCore.Mvc;namespace Jiamiao.x.CapDemo.ServiceA.Controllers&#123; public class SubController : Controller &#123; [CapSubscribe(\"jiamiao.x.cap.demo.show.time\")] public void ShowTime(DateTime value) &#123; Console.WriteLine($\"接受方：SubController.ShowTime 接收到值：&#123;value&#125;\"); &#125; &#125;&#125; 做到这步可以进行一次测试，就可以发现访问/WeatherForecast这个接口，会发送一条当前时间的消息出去，同时接收方也会在控制台打印出接收到的消息 编写服务中接收消息的代码，需要注意接收消息的类需要继承ICapSubscribe接口，同时这里为了方便进行依赖注入，这里我们也自己定义了一个ISubscriberService接口，同时服务需要在Startup.cs的ConfigureServices方法中进行注册 9.1 ISubscriberService.cs代码如下 123456789101112using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;namespace Jiamiao.x.CapDemo.ServiceA.Services&#123; public interface ISubscriberService &#123; void ReceivedShowTimeMessage(DateTime value); &#125;&#125; 9.2 SubscriberService.cs代码如下 1234567891011121314151617using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;namespace Jiamiao.x.CapDemo.ServiceA.Services&#123; public class SubscriberService: ISubscriberService, ICapSubscribe &#123; [CapSubscribe(\"jiamiao.x.cap.demo.show.time\")] public void ReceivedShowTimeMessage(DateTime value) &#123; Console.WriteLine($\"接受方：SubscriberService.ReceivedShowTimeMessage 接收到值：&#123;value&#125;\"); &#125; &#125;&#125; 9.3 服务注册代码如下 1services.AddScoped&lt;ISubscriberService, SubscriberService&gt;(); 注意：这行服务注册代码需要在services.AddCap这个方法之前注册，否则CAP在进行接口扫描的时候找不到对应已经实现了ICapSubscribe接口的实现类，则无法进行订阅者注册 注释掉第8步，进行第9步的测试，效果应该与第8步一致 有时候一个消息需要多个消费者同时消费，则可以使用Group概念，消息发送代码不变，在标记CapSubscribe的时候，使用Group参数，多个Group订阅同个消息Id，消息则会对应分发到多个Group中，同个Group只能消费一次，即一个Group对一个消息Id订阅多次，也会只接收一次，具体代码如下SubscriberService.cs中新增Group参数1[CapSubscribe(\"jiamiao.x.cap.demo.show.time\",Group = \"SubscriberService\")] SubController.cs中新增Group参数1[CapSubscribe(\"jiamiao.x.cap.demo.show.time\",Group = \"SubController\")] 测试Group功能，将项目跑起来，此时再访问发送消息的api，会在控制台中打印出两条消息接收记录 创建ServiceBServiceB使用EFCore来进行配置，找ServiceA步骤2创建Jiamiao.x.CapDemo.ServiceB项目，因为.Net Core 3.1没有自带EFCore，所以这里除了CAP的4个包之外，还需要nuget安装EFCore的两个包，汇总起来需要nuget安装的包如下： 123456DotNetCore.CAPDotNetCore.CAP.DashboardDotNetCore.CAP.RabbitMQDotNetCore.CAP.SqlServerMicrosoft.EntityFrameworkCoreMicrosoft.EntityFrameworkCore.SqlServer创建ServiceDbContext.cs文件，代码如下 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using Microsoft.EntityFrameworkCore;namespace Jiamiao.x.CapDemo.ServiceB.Infrastructure&#123; public class ServiceDbContext: DbContext &#123; public ServiceDbContext(DbContextOptions&lt;ServiceDbContext&gt; options):base(options) &#123; &#125; &#125;&#125;在Startup.cs中配置EFCore和CAP，具体代码如下： 1234567891011121314151617services.AddDbContext&lt;ServiceDbContext&gt;(options =&gt;&#123; options.UseSqlServer( \"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1\");&#125;);services.AddCap(options =&gt;&#123; options.UseEntityFramework&lt;ServiceDbContext&gt;(); options.UseRabbitMQ(r =&gt; &#123; r.HostName = \"127.0.0.1\"; r.UserName = \"admin\"; r.Password = \"admin\"; &#125;); options.UseDashboard();&#125;);后续操作与ServiceA类似，需要注意：多个站点订阅同个消息Id，消息会往多个站点进行发送 附上CAP的Github地址:https://github.com/dotnetcore/CAP 还有一些配合EF的操作还没来得及写，有空再说吧","categories":[{"name":".NET","slug":"NET","permalink":"http://doc.dimsum.com/categories/NET/"}],"tags":[{"name":".NET Core","slug":"NET-Core","permalink":"http://doc.dimsum.com/tags/NET-Core/"},{"name":"CAP","slug":"CAP","permalink":"http://doc.dimsum.com/tags/CAP/"},{"name":"MicroServices","slug":"MicroServices","permalink":"http://doc.dimsum.com/tags/MicroServices/"}]}],"categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"},{"name":"Docker","slug":"Docker","permalink":"http://doc.dimsum.com/categories/Docker/"},{"name":".NET","slug":"NET","permalink":"http://doc.dimsum.com/categories/NET/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"},{"name":"docker","slug":"docker","permalink":"http://doc.dimsum.com/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://doc.dimsum.com/tags/elasticsearch/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://doc.dimsum.com/tags/NET-Core/"},{"name":"CAP","slug":"CAP","permalink":"http://doc.dimsum.com/tags/CAP/"},{"name":"MicroServices","slug":"MicroServices","permalink":"http://doc.dimsum.com/tags/MicroServices/"}]}