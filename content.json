{"meta":{"title":"dimsum","subtitle":"","description":"","author":"Jiamiao.x","url":"http://www.dimsum.fun","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-27T07:39:01.629Z","updated":"2020-03-27T07:22:15.606Z","comments":false,"path":"/404.html","permalink":"http://www.dimsum.fun/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-27T07:39:01.605Z","updated":"2020-03-27T07:22:15.608Z","comments":false,"path":"about/index.html","permalink":"http://www.dimsum.fun/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-03-27T07:39:01.578Z","updated":"2020-03-27T07:22:15.608Z","comments":false,"path":"books/index.html","permalink":"http://www.dimsum.fun/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-27T07:39:01.549Z","updated":"2020-03-27T07:22:15.609Z","comments":false,"path":"categories/index.html","permalink":"http://www.dimsum.fun/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-03-27T07:39:01.525Z","updated":"2020-03-27T07:22:15.609Z","comments":true,"path":"links/index.html","permalink":"http://www.dimsum.fun/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-27T07:39:01.501Z","updated":"2020-03-27T07:22:15.609Z","comments":false,"path":"repository/index.html","permalink":"http://www.dimsum.fun/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-27T07:39:01.476Z","updated":"2020-03-27T07:22:15.610Z","comments":false,"path":"tags/index.html","permalink":"http://www.dimsum.fun/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git常用命令备忘","slug":"50.Git_document","date":"2020-06-03T08:02:00.000Z","updated":"2020-06-04T16:43:59.913Z","comments":true,"path":"2020/06/03/50.Git_document/","link":"","permalink":"http://www.dimsum.fun/2020/06/03/50.Git_document/","excerpt":"","text":"本地仓库版本切换 查询当前本版以前的所有提交记录：git log --pretty=oneline 查询所有版本记录：git reflog 代码切换到指定目录：git reset --hard 版本号 远程仓库操作 推送本地仓库代码到远程仓库：git push 拉取远程仓库代码：git pull 分支常用命令 查看分支：git branch 创建分支：git branch 分支名 切换分支：git checkout 分支名 创建再切换到新建的分支：git checkout -b 分支名 删除分支：git branch -d 分支名 不能删除当前正在使用的分支 合并分支：git merge 被合并的分支名 测试一下","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://www.dimsum.fun/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.dimsum.fun/tags/Git/"}]},{"title":"事务","slug":"49.Transaction01","date":"2020-06-03T01:55:00.000Z","updated":"2020-06-04T16:43:59.912Z","comments":true,"path":"2020/06/03/49.Transaction01/","link":"","permalink":"http://www.dimsum.fun/2020/06/03/49.Transaction01/","excerpt":"","text":"概念 定义 组成 目的 特性 原子性(Actomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability) 事务隔离 事务并发导致的异常 回滚丢失(Update Lost) 覆盖丢失(Second Uupdate Lost) 脏读 不可重复读 幻读 事务隔离级别 读未提交 读已提交 可重复读 串行化 事务隔离级别与并发异常 MySql操作 常用命令 概念定义数据库事务是访问并可能更新数据库中各种数据项的一个程序执行单元(unit) 组成一个数据库事务通常包含对数据库进行读或写的一个操作序列 目的 为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作相互干扰 总结：事务的目的就是要提供3种方法：1.失败恢复方法，2.保持一致性的方法，3.操作隔离的方法 成功情况下 能将数据从一种状态变为另一种状态，并能够持久化 异常情况下 能将数据恢复到正常状态 要能保证一致性，包含数据的一致性和约束的一致性 并发情况下 并发的操作之间不能产生相互影响 特性原子性(Actomicity)事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行 一致性(Consistency)事务应确保数据库的状态从一个一致状态转变为另一个一致状态，一致状态的含义时数据库中数据应满足完整性约束 隔离性(Isolation)多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性(Durability)一个事务一旦提交，他对数据库的修改应该永久保存在数据库中 事务隔离事务并发导致的异常回滚丢失(Update Lost)第一类更新丢失，此种更新丢失时因为回滚的原因，所以也叫回滚丢失|事务A|事务B||—|—||查询数据得到初始值10|查询数据得到初始值提交||更新为10+1=11|更新为10+2=12||提交|失败回滚|||数据回到初始状态10，导致事务A的更新丢失了，由于回滚导致丢失，所以也叫回滚丢失| 覆盖丢失(Second Uupdate Lost)第二类更新丢失，此种更新丢失时因为更新被其他事务给覆盖了，也可以叫覆盖丢失|事务A|事务B||—|—||查询数据得到初始值10|查询数据得到初始值10||更新为10+1=11|更新为10+2=12||提交|提交|||最终结果变为12，由于事务B是从10开始计算，并不知道数据已经发生了变化，所以导致事务A的更新结果被覆盖了，所以也叫覆盖更新| 脏读此种异常是因为一个事务读取了另一个事务修改了但是未提交的数据|事务A|事务B||—|—||查询数据得到初始值10|||更新为10+1=11|查询数据得到数据11|||更新数据11+1=12||回滚|提交|||数据最终变为12，由于读到的数据11被回滚了，结果是错误的，读取到了脏数据| 不可重复读这种异常时一个事务对同一行数据执行了两次或更多次查询，但是却得到了不同的结果| 事务A | 事务B ||—|—|| 查询数据得到初始值10 | 查询数据得到初始值10 ||更新为10+1=11|再次读取数据得到11|||在一个事务内两次对统一数据查询，得到的结果是不同的，因此叫做不可重复读| 幻读幻读和不可重复读有点像，只是针对的不是数据的值而是数据的数量|事务A|事务B||—|—||查询数据有10条|||更新全部数据|插入一条数据||查询结果发现有一条没备更新，比原来多了一条|||仿佛全表更新语句不正常，自己出现了幻觉，因此叫幻读|| 事务隔离级别由低到高分成以下级别： 读未提交该隔离级别指即使一个事务的更新语句未提交，但是别的事务可以读到这个改变 读已提交该隔离级别指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新，消除了脏读和回滚丢失(第一类更新丢失)，这时大多数数据库的默认隔离级别，如Oracle、SqlServer 可重复读该隔离级别指一个事务中进行两次或多次同样的对数据库内容的查询，得到的结果是一样的，但是不保证对数据条数的查询是一样的，指要存在读改行数据就禁止写，消除了不可重复读和覆盖丢失(第二类更新丢失)，这是MySql数据库的默认隔离级别 串行化事务执行的时候不允许别的事务并行执行，完全串行化的读，指要存在读就禁止写，但是可以同时读，消除了幻读。这是事务隔离的最高级别，虽然最安全最省心，但是效率太低，一般不会用 事务隔离级别与并发异常各种隔离级别解决哪些并发异常|隔离级别\\并发异常|回滚丢失|覆盖丢失|脏读|不可重复读|幻读||—|—|—|—|—|—||读未提交|×|×|×|×|×||读已提交|√|√|×|×|×||可重复读|√|√|√|√|×||串行化|√|√|√|√|√| MySql操作常用命令 查询当前数据库版本1select version(); 查看当前会话事务隔离级别1SELECT @@session.tx_isolation; 查询全局事务隔离级别1SELECT @@global.tx_isolation; 修改隔离级别(以当前会话为例)：123456set @@session.tx_isolation&#x3D;&#39;会话级别&#39; --会话级别可选值： READ-UNCOMMITTED 读未提交 READ-COMMITTED 读已提交 REPEATABLE-READ 可重复读 SERIALIZABLE 串行化 开启事务1start transaction; 提交事务1commit 回滚1rollback","categories":[{"name":"事务","slug":"事务","permalink":"http://www.dimsum.fun/categories/%E4%BA%8B%E5%8A%A1/"}],"tags":[{"name":"事务","slug":"事务","permalink":"http://www.dimsum.fun/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"Redis企业级解决方案","slug":"48.Redis4_document","date":"2020-06-02T07:48:00.000Z","updated":"2020-06-02T09:20:42.836Z","comments":true,"path":"2020/06/02/48.Redis4_document/","link":"","permalink":"http://www.dimsum.fun/2020/06/02/48.Redis4_document/","excerpt":"","text":"缓存预热 现象 问题排查 解决方案 前置准备工作 准备工作 实施 缓存雪崩 现象 问题排查 解决方案（道） 解决方案（术） 总结 缓存击穿 现象 问题排查 问题分析 解决方案（术） 总结 缓存穿透 现象 问题排查 问题分析 解决方案（术） 总结 性能指标监控 性能指标：Performance 内存指标：Memory 基本活动指标：Basic activity 持久性指标：Persistence 错误指标：Error 监控方式 工具 命令 缓存预热现象宕机：服务器启动之后迅速宕机 问题排查 请求数量较高 主从之间数据吞吐量较大，数据同步操作频度较高解决方案前置准备工作 日常理性统计数据访问记录，统计访问频度较高的热点数据 利用LRU数据删除策略，构建数据留存队列 例如：storm与kafka配合准备工作 将统计结果中的数据分类，根据级别，redis有限加载级别较高的热点数据 利用分布式多服务器同时进行数据读取，提速数据加载过程实施 使用脚本程序固定触发数据预热过程 如果有条件，使用CDN，效果会更好 缓存雪崩现象 系统平稳运行过程中，忽然数据库连接量激增 应用服务器无法及时处理请求 大量408、500错误 客户反复刷新页面获取数据 数据库崩溃 应用服务器崩溃 重启应用服务器无效 Redis服务器崩溃 Redis集群崩溃 重启数据库后再次被瞬间流量放倒问题排查 在一个较短的时间内，缓存中较多的key集中过期 此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据 数据库同时接收到大量的请求无法及时处理 Redis大量请求被积压，开始出现超时现象 数据库流量激增，数据库崩溃 重启后仍然面对缓存中无数据可用 Redis服务器资源被严重占用，Redis服务器崩溃 Redis集群呈现崩塌，集群瓦解 应用服务器无法即使得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃 应用服务器、Redis、数据库全部重启，效果不理想解决方案（道） 更多的页面静态化处理 构建多级缓存架构：nginx缓存+redis缓存+ehcache缓存 检测MySql严重耗时业务进行优化，对数据库的瓶颈排查，例如超时查询、耗时较高事务等 灾难预警机制，监控redis服务器性能指标： CPU占用、CPU使用率 内存容量 查询平均响应时间 线程数 限流、降级：短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问解决方案（术） LRU与LFU切换 数据有效期策略调整 根据业务数据有效期进行分类错峰，A类90分钟、B类80分钟、C类70分钟 过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量 超热数据使用永久key 定期维护（自动+人工）：对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时 加锁：慎用！！！总结缓存雪崩就是顺接过期数据量太大，导致对数据库服务器造成压力，如果能够避免过期时间集中，可以有效解决雪崩现象的出现(40%)，配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整 缓存击穿现象 系统平稳运行过程中 数据库连接量瞬间激增 Redis服务器无大量key过期 Redis内存平稳，无波动 Redis服务器CPU正常 数据库崩溃问题排查 Redis中某个key过期，该key访问量巨大 多个数据请求从服务器直接压倒Redis后，均为命中 Redis在短时间内发起了大量对数据库中同一数据的访问问题分析 单个key高热数据 key过期解决方案（术） 预先设定：以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长。注意：购物街不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的去式 现场调整：监控访问量，对自然流量激增的数据演唱过期时间或设置未永久性key 后台刷新数据：启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失 二级缓存：设置不同的过期时间，保障不会被同时淘汰就行 枷锁：分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎用！！！总结缓存击穿就是单个高热数据过期的瞬间，数据量访问较大，未命中Redis后，发起了大量对统一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该是在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。 缓存穿透现象 系统平稳运行过程中 应用服务器流量随时间增量较大 Redis服务器命中率随时间逐步降低 Redis内存平稳，内存无压力 Redis服务器CPU占用激增 数据库服务器压力激增 数据库崩溃 问题排查 Redis中大面积出现未命中 出现非正常URL访问 问题分析 获取的数据在数据库中也不存在，数据库查询未得到对应数据 Redis获得到null数据未进行持久化，直接返回 下次此类数据达到重复上述过程 出现黑客攻击服务器 解决方案（术） 缓存null：对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30~60秒，最高5分钟 白名单策略 提前预热各种分类数据id对应的bitmaps，id作为bitmap的offset，相当于设置了数据白名单，当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低） 使用布隆过滤器（有关布隆过滤器的命中问题对当前状态可以忽略） 实时监控：实时监控Redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比 非活动时段波动：通常检测3~5倍，超过5倍纳入重点排查对象 活动时段波动：通常检测10~50倍，超过50倍纳入重点排查对象 根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控 key加密：问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验 例如每天随机分配60个加密串，挑选2~3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问 总结缓存击穿访问了不存在的数据，跳过了合法数据的Redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力，通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警，应对策略应该在临时预案方面多做文章 无论时黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除 性能指标监控性能指标：Performance Name Description latency Redis平均响应一个请求的时间 instantaneous_ops_per_sec 平均每秒处理请求总数（QPS） hit rate(calculated) 缓存命中率(计算出来的) 内存指标：Memory Name Description used_memory 已使用内存 mem_fragmentation_ratio 内存碎片率 evicted_key 由于最大内存限制被移除的key的数量 block_clients 由于BLPOP、BRPOP、BRPOPLPUSH而被阻塞的客户端 基本活动指标：Basic activity Name Description connected_clients 客户端连接数 connected_slaves slave数量 master_last_io_seconds_ago 最近一次主从交互之后的秒数 keyspace 数据库中的key值总数 持久性指标：Persistence Name Description rdb_last_save_time 最后一次持久化保存到磁盘的时间戳 rdb_changes_since_last_save 自最后一次持久化以来数据库的更改数 错误指标：Error Name Description rejected_connections 由于达到maxclient限制而被拒绝的连接数 keyspace_misses key值查找失败（没有命中）次数 master_link_down_since_seconds 主从断开的持续时间（以秒为单位） 监控方式工具 Cloud Insight Redis Prometheus Redis-stat Redis-faina RedisLive zabbix命令 benchmark redis-benchmark：50个连接，10000次请求对应的性能 redis-benchmark -c 100 -n 5000：100个连接，5000次请求对应的性能 redis-cli monitor slowlog slowlog get：获取慢查询日志 slowlog len：获取慢查询日志条目数 slowlog reset：重置慢查询日志 相关配置： slow-log-slower-than 1000：设置慢查询的时间下限，单位：毫秒 slowlog-max-len 100：设置慢查询命令对应的日志显示长度，单位：命令数","categories":[{"name":"Redis","slug":"Redis","permalink":"http://www.dimsum.fun/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.dimsum.fun/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://www.dimsum.fun/tags/NOSQL/"}]},{"title":"Redis集群","slug":"47.Redis3_document","date":"2020-06-01T07:28:00.000Z","updated":"2020-06-02T09:20:42.835Z","comments":true,"path":"2020/06/01/47.Redis3_document/","link":"","permalink":"http://www.dimsum.fun/2020/06/01/47.Redis3_document/","excerpt":"","text":"主从复制 简介 单机Redis的风险与问题 解决方案 解析 主从复制的作用 工作流程 建立连接阶段 连接阶段(slave连master) 授权阶段(master没密码可省略) 数据同步阶段 同步阶段master说明 同步阶段slave说明 命令传播阶段 命令传播阶段的部分复制 数据同步+命令传播阶段工作流程 心跳机制 master心跳任务 slave心跳任务 心跳阶段注意事项 主从复制的完整工作流程图 常见问题 频繁的全量复制(1) 频繁的全量复制(2) 频繁的网络中断(1) 频繁的网络中断(2) 数据不一致 哨兵模式 哨兵 启动哨兵 sentinel.conf 工作原理 监控 通知 故障转移 集群 现状问题 集群架构 集群的数据存储 集群的内部通讯设计 集群搭建 Cluster节点操作命令 主从复制简介互联网”三高”架构：高并发、高性能、高可用 高可用：业界可用性目标5个9，即*99.999%，即全年服务器宕机时长低于315秒，约5.25分钟*** 单机Redis的风险与问题 问题1：机器故障 现象：硬盘故障、系统崩溃 本质：数据丢失，很可能对业务造成灾难性打击 结论：基本上会放弃使用Redis 问题2：容量瓶颈 现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存 本质：穷！硬件条件跟不上 结论：放弃使用Redis 结论：为了避免单点Redis服务器故障，准备多台服务器，互相连通，将数据复制从多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的，即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份 解决方案 提供数据方：master 主服务器、主节点、主库 主客户端 接受数据方：slave 从服务器、从节点、从库 从客户端 需要解决的问题：数据同步 核心工作：master的数据复制到slave中 解析主从复制即将master中的数据即时、有效的复制到slave中 特征：一个master可以拥有多个slave，一个slave只对应一个master 职责： master： 写数据 执行写操作时，将出现变化的数据自动同步到slave 读数据（可忽略） slave 读数据 写数据（禁止） 主从复制的作用 读写分离：master写、slave读，提高服务器的读写负载能力 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量 故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 高可用基石：基于主从复制，构建哨兵与集群，实现Redis的高可用方案 工作流程 主从复制过程大体可以分为3个阶段 建立连接阶段（即准备阶段） 数据同步阶段 命令传播阶段 建立连接阶段建立slave到master的连接，使master能够识别slave，并保存slave端口号 [slave]设置master的地址和端口，保存master信息 [slave]建立socket连接 [slave]发送ping命令(定时器任务) [slave]身份验证 [slave]发送slave端口信息 至此主从连接成功 达到了以下状态： slave：保存master的地址与端口 master：保存slave的端口 总体：master与slave之间创建了连接的socket 连接阶段(slave连master) 方式一：客户端发送命令：slaveof &lt;masterip&gt; &lt;masterport&gt; 方式二：启动服务器参数：redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt; 方式三：服务器配置：slaveof &lt;masterip&gt; &lt;masterport&gt; slave系统信息 master_link_down_since_seconds masterhost masterport master系统信息 slave_listening_port（多个） 授权阶段(master没密码可省略) master配置文件设置密码1requirepass &lt;password&gt; master客户端发送命令设置密码12config get requirepass &lt;password&gt;config get requirepass slave客户端发送命令设置密码1auth &lt;password&gt; slave配置文件设置密码1masterauth &lt;password&gt; 启动客户端设置密码1redis-cli -a &lt;password&gt; 数据同步阶段 [slave]请求同步数据 [master]创建RDB同步数据 [slave]恢复RDB同步数据 [slave]请求部分同步数据 [slave]恢复部分同步数据 至此数据同步工作完成 达到了以下状态 slave：具有master端全部数据，包含RDB过程接受的数据 master：保存slave当前数据同步的位置 总体：master与slave之间完成了数据克隆 同步阶段master说明 如果master数据量巨大，数据同步阶段应避免流量高峰期，避免造成master阻塞，影响业务正常执行 复制缓冲区大小设定不合理，会导致数据溢出，如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态1repl-backlog-size 1mb master单机内存占用主机内存的比例不应过大，建议使用50%70%的内存，留下30%50%的内存用于执行bgsave命令和创建复制缓冲区 同步阶段slave说明 为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务1slave-serve-stable-data yes|no 数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令 多个slave同时向master请求数据同步，master发送的RDB文件增多，如果master带宽不足，会对带宽造成巨大冲击，因此数据同步需要根据业务需求，适量错峰 slave过多时，建议调整拓扑结构，由一主多从从结构变成树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择 命令传播阶段 当master数据库状态被修改时，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播 master将接收到的数据变更命令发送给slave，slave接受命令后执行命令 命令传播阶段的部分复制 命令传播阶段出现断网现象： 网络闪断闪联 –&gt; 忽略 短时间网络中断 –&gt; 部分复制 长时间网络中断 –&gt; 全量复制 部分复制的三个核心要素 服务器的运行id(runid) 概念：服务器运行Id，是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id 组成：运行id由40位字符组成，是一个随机的十六进制字符 作用：运行id被用于在服务器间进行传输，识别身份。如果想两次操作均同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别 实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行id发送给slave，slave保存此id，通过info server命令，可以查看节点的runid 主服务器的复制积压缓冲区 概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出(FIFO)的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区 复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列 由来：每台服务器启动时，如果开启有AOF或被连接成位master节点，即创建复制缓冲区 作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set、select） 数据来源：当master接收到主客户端的指令时，除了将指令执行，还会将指令存储到缓冲区中 组成：偏移量和字节值 工作原理 通过offset区分不同的slave当前数据传播的差异 master记录已发送的信息对应的offset slave记录已接受的信息对应的offset 主从服务器的复制偏移量 概念：一个数字，描述复制缓冲区中的指令字节位置 分类： master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个） slave复制偏移量：记录slave接受master发送过来的指令字节对应的位置（一个） 数据来源： master端：发送一次记录一次 slave端：接受一次记录一次 作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用 数据同步+命令传播阶段工作流程 心跳机制进入命令传播阶段，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线 master心跳任务 指令：PING 周期：由repl-ping-slave-period决定，默认10秒 作用：判断slave是否在线 查询：info replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常slave心跳任务 指令：REPLCONF ACK {offset} 周期：1秒 作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令 作用2：判断master是否在线 心跳阶段注意事项 当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作12min-slave-to-write 2min-slave-max-lag 8 slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步 slave数量由slave发送REPLCONF ACK命令做确认 slave延迟由slave发送REPLCONF ACK命令做确认 主从复制的完整工作流程图 常见问题频繁的全量复制(1)伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作 内部优化调整方案（redis自己操作的） master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave 在master关闭时执行命令shutdown save，进行RDB持久化，将runid与offset保存到RDB文件中 repl-id repl-offset 通过redis-check-rdb命令可以查看该信息 master重启后加载RDB文件，恢复数据，重启后RDB文件将保存的repl-id与repl-offset加载到内存中 master_repl_id = repl master_repl_offset = repl-offset 通过info命令可以查看该信息 作用：本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master 频繁的全量复制(2) 问题现象：网络环境不佳，出现网络中断，slave不提供服务 问题原因：复制缓冲区过小，断网后slave的offset越界，触发全量复制 最终结果：slave反复进行全量复制 解决方案：修复复制缓冲区大小 建议设置如下： 测算从master到slave的重连平均时长second 获取master平均每秒产生写命令数据总量write_size_per_second 最有复制缓冲区空间 = 2 * second * write_size_per_second 频繁的网络中断(1) 问题现象：master的CPU占用过高或slave频繁断开联系 问题原因： slave每1秒发送REPLCONF ACK命令到master 当slave接到了慢查询时（keys *、hgetall等），会大量占用CPU性能 master每1秒调用复制定时函数replicationCron()，会对slave发现长时间没有进行响应 最终结果： master各种资源（输出缓冲区、带宽、连接等）被严重占用 解决方案：通过设置合理的超时时间，确认是否释放slave1repl-timeout 该参数定义了超时时间的阙值（默认60秒），超过该值，释放slave 频繁的网络中断(2) 问题现象：slave与master连接断开 问题原因： master发送ping指令频度较低 master设定超时时间较短 ping指令在网络中存在丢包 解决方案：提高ping指令发送的频度1repl-ping-slave-period 超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时 数据不一致 问题现象：多个slave获取相同数据不同步 问题原因：网络信息不同步，数据发送有延迟 解决方案： 优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器要注意此现象 监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问1slave-serve-stable-data yes|no 开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高） 哨兵模式主从复制模式中，如果master宕机了，需要做以下操作： 将宕机的master下线 找一个slave作为master 通知所有的slave连接新的master 启动新的master与slave 哨兵哨兵是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master 哨兵的作用： 监控 不断的检查master和slave是否正常运行 master存活检测、master与slave运行情况检测 通知（提醒）：当被监控的服务器出现问题后，向其他（哨兵间、客户端）发送通知 自动故障转移：断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址 哨兵也是一台redis服务器，只是不提供数据服务，通常哨兵配置数量为单数 启动哨兵 配置一拖二的主从结构 配置三个哨兵（配置相同，端口不同） 参看sentinel.conf 启动哨兵1redis-sentinel sentinel-端口号.conf 启动顺序 启动master 启动slave 启动哨兵 sentinel.conf port 26379：哨兵对外的端口 dir /tmp：哨兵的工作信息存储位置 sentinel monitor mymaster 127.0.0.1 6379 2 设置哨兵监控的Master，其中mymaster是自己给master起的名字，可以自定义，后面使用的时候保持一致即可，最后面的2表示有多少个哨兵认为master挂了，就认定为挂了，一般设置(哨兵数量/2+1) sentinel down-after-milliseconds mymaster 30000 master连接多长时间没响应就认为挂了 sentinel parallel-syncs mymaster 1 进行新的master切换的时候，一次有多少个slave来进行同步数据，这个值越小，对服务器性能压力越小，速度越慢，相反，这个值越大，对服务器性能压力就越大，与之对应的速度就越快 sentinel failover-timeout mymaster 1800000 在进行同步的时候，超过多长的时间算超时 工作原理监控用于同步各个节点的状态信息 获取各个sentinel的状态（是否在线） 获取master的状态 master属性 runid role：master 各个slave的详细信息 runid role：slave master_host、master_port offset … sentinelA在启动的时候，会先连接master，建立CMD连接，获取master信息，并在master的配置里新增自己的信息 sentinelA在获取到master信息后，通过master信息得到master的slave信息，然后连接slave，获取slave信息 sentinelB启动时连接master，获取master信息，这时候发现master已经有sentinelA连接过的记录，便与sentinelA建立起一条pub/sub通道(发布订阅通道)，再连接master对应的slave 再有其他的sentinel启动连到master，一样执行的是sentinelB的步骤，就这样，每个sentinel都与其他的sentinel建立连接，形成一个小型组网 通知多个sentinel中的其中一个向master和slave发送一条hello信息，确定是否在线，并将这个是否在线的结果发布到sentinel自己的组网里，通知其他sentinel这个结果 故障转移 当通知阶段中有一个sentinelA发送了hello信息给master，但是master没做反应，这时候这个sentinelA就认为这个master出现故障，便将这个master的状态标记为sdown(主观下线)，并将这个消息发布到sentinel的pub/sub的通道中，通知其他sentinel 其他sentinel街道sentinelA发布的消息，作为吃瓜群众赶紧也去发送hello信息给master，看看是不是真挂了。这时如果达到了sentinel.conf里配置的数量的sentinel认为master挂了，那所有的sentinel就都认为master是真挂了，便将这个master的状态标记为odown(客观下线) 出现odown之后，所有sentinel就开会讨论谁去做故障转移这件事，sentinel发起投票，确定谁去做故障转移 挑选出来做故障处理的sentinel要依照下面的规则挑选备选master 在线的（排除掉下线的） 响应快的（排除掉响应慢的） 与原master沟通密切的（排除掉与原master断开时间久的） 有限原则 优先级 offset runid 挑选出备选master之后，便向新的master发送slaveof no one的指令，将它升级到master，然后再向其他slave发送slaveof 新masterIP 端口，让其他slave全部指向新master 原master重新上线之后，会变成slave去连接现在的master 集群现状问题 redis提供的服务OPS可以达到10w/秒，当前业务OPS已经达到20w/秒 内存单机容量达到256G，当前业务需求内存容量1T 这时候就需要集群来解决上面的问题了 集群架构集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果 集群作用： 分散单台服务器的访问压力，实现负载均衡 分散单台服务器的存储压力，实现可扩展性 降低单台服务器宕机带来的业务灾难 集群的数据存储 通过算法设计，计算出key应该保存的位置 通过CRC16(key)得到一个数值，然后与16384取模，得到这个key最终应该保存的位置 也就是说将所有的存储空间计划切割成16384份，每台主机保存一部分 每份代表的是一个存储空间，不是存储一个key的保存空间 将key按照计算出的结果放到对应的存储空间 增强可扩展性 集群的内部通讯设计 各个数据库相互通信，保存各个库中槽的编号数据 一次命中，直接返回 一次未命中，告知具体位置 集群搭建 搭建一个三主三从的集群 cluster配置： 123cluster-enabled yescluster-config-file nodes-6379.confcluster-node-timeout 100000 大概的redis.conf配置如下： 1234567891011121314port 6379daemonize yesdir &#x2F;redis-all-in&#x2F;datadbfilename dump-6379.rdbrdbcompression yesrdbchecksum yessave 10 2appendonly yesappendfsync alwaysappendfilename appendonly-6379.aofdatabases 16cluster-enabled yescluster-config-file nodes-6379.confcluster-node-timeout 10000 启动命令（redis 5.0以后的启动方式）： 1redis-cli --cluster create 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 --cluster-replicas 1 输入上面命令之后redis会自动分配槽位置与主从节点，确定没问题之后输入yes即可自动创建cluster集群 --cluster-replicas表示1个master连1个slave Cluster节点操作命令 查看集群节点信息：cluster nodes 进入一个从节点，切换其主节点：cluster replicate &lt;master-id&gt; 发现一个新节点，新增主节点：cluster meet ip:port 忽略一个没有slot的节点：cluster forget &lt;id&gt; 手动故障转移：cluster failover","categories":[{"name":"Redis","slug":"Redis","permalink":"http://www.dimsum.fun/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.dimsum.fun/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://www.dimsum.fun/tags/NOSQL/"}]},{"title":"Redis进阶","slug":"46.Redis2_document","date":"2020-05-30T04:08:00.000Z","updated":"2020-06-01T10:59:44.327Z","comments":true,"path":"2020/05/30/46.Redis2_document/","link":"","permalink":"http://www.dimsum.fun/2020/05/30/46.Redis2_document/","excerpt":"","text":".NET Core操作Redis 持久化 持久化过程保存什么 RDB RDB持久化的配置 注意 bgsave 自动执行RDB 自动执行RDB注意 三种方案对比 RDB特殊启动形式 RDB优点 RDB缺点 AOF RDB存储的弊端 解决思路 概念 AOF写数据三种策略(appendfsync) AOF配置 AOF重写 AOF重写作用 AOF重写规则 AOF重写方式 AOF自动重写方式 AOF非重写流程 AOF重写流程 RDB与AOF区别 RDB与AOF怎么选 事务 简介 基本操作 事务的工作流程 事务的注意事项 锁 – 基于特定条件的事务执行 乐观锁 业务分析 解决方案 分布式锁 业务分析 解决方案 死锁 业务分析 解决方案 删除策略 Redis中的数据特征 定时删除 惰性删除 定期删除 删除策略比对 逐出算法 新数据进入检测 影响数据逐出的相关设置 数据逐出策略配置依据 Redis.Conf 服务器基础配置 日志配置 客户端配置 多服务器快捷配置 高级数据类型 Bitmaps HyperLogLog 说明 GEO 基本操作 .NET Core操作Redis创建控制台应用RedisSample01，通过nuget引入CSRedisCore 具体示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Linq;using System.Threading.Tasks;using CSRedis;namespace RedisSample01&#123; class Program &#123; static async Task Main(string[] args) &#123; var redis &#x3D; new CSRedisClient(&quot;127.0.0.1:6379,defaultDatabase&#x3D;0,prefix&#x3D;ds_&quot;); RedisHelper.Initialization(redis); Console.WriteLine(&quot;↓↓↓↓↓ String Sample ↓↓↓↓↓&quot;); await RedisHelper.SetAsync(&quot;name&quot;, &quot;dimsum&quot;); var name &#x3D; await RedisHelper.GetAsync&lt;string&gt;(&quot;name&quot;); Console.WriteLine($&quot;name &#x3D; &#123;name&#125;&quot;); Console.WriteLine(&quot;↑↑↑↑↑ Sample End ↑↑↑↑↑↑&quot;); Console.WriteLine(); Console.WriteLine(&quot;↓↓↓↓↓ List Sample ↓↓↓↓↓&quot;); await RedisHelper.DelAsync(&quot;list1&quot;); await RedisHelper.LPushAsync(&quot;list1&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;); await RedisHelper.RPushAsync(&quot;list1&quot;, &quot;x&quot;); var list1 &#x3D;await RedisHelper.LRangeAsync(&quot;list1&quot;, 0, -1); Console.WriteLine($&quot;list1 &#x3D; &#123;String.Join(&#39;,&#39;,list1)&#125;&quot;); var list1Length &#x3D; await redis.LLenAsync(&quot;list1&quot;); Console.WriteLine($&quot;list1.length &#x3D; &#123;list1Length&#125;&quot;); Console.WriteLine(&quot;↑↑↑↑↑ Sample End ↑↑↑↑↑↑&quot;); Console.WriteLine(&quot;↓↓↓↓↓ Hash Sample ↓↓↓↓↓&quot;); await RedisHelper.HSetAsync(&quot;hash1&quot;, &quot;name&quot;, &quot;张三&quot;); await RedisHelper.HSetAsync(&quot;hash1&quot;, &quot;age&quot;, 19); await RedisHelper.HSetAsync(&quot;hash1&quot;, &quot;job&quot;, &quot;C#&quot;); var hash1 &#x3D; await RedisHelper.HGetAllAsync(&quot;hash1&quot;); Console.WriteLine($&quot;hash1 &#x3D; &#123;string.Join(&#39;,&#39;, hash1.Select(x &#x3D;&gt; $&quot;&#123;x.Key&#125;:&#123;x.Value&#125;&quot;).ToArray())&#125;&quot;); Console.WriteLine(&quot;↑↑↑↑↑ Sample End ↑↑↑↑↑↑&quot;); Console.WriteLine(); Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); Console.WriteLine(&quot;Sample done&quot;); &#125; &#125;&#125; 持久化 持久化：利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制 为什么要持久化？防止数据的意外丢失，确保数据安全 持久化过程保存什么 RDB：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据 AOF：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程 RDB 操作命令：save 作用：手动执行一次保存操作 RDB持久化的配置在配置文件中修改 dbfilename dump.rdb 说明：设置本地数据库文件名，默认为dump.rdb 经验：通常设置为dump-端口号.rdb dir 说明：设置存储.rdb文件的路径 经验：通常设置成存储空间较大的目录中，目录名称data rdbcompression yes 说明：设置存储至本地数据库时是否压缩数据，默认为yes，采用LZF压缩 经验：通常默认为开启状态，如果设置为no，可以节省CPU运行时间，但会使存储的文件变大(巨大) rdbchecksum yes 说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行 经验：通常默认为开启状态，如果设置为no，可以节约读写行过程约10%时间消耗，但是存储一定的数据损坏风险 stop-writes-on-bgsave-error yes 说明：后台存储过程中如果出现错误现象，是否停止保存操作(这个配置项针对bgsave操作) 经验：通常默认为开启状态注意 save指令的执行会阻塞当前Redis服务器，知道当前RDB过程完成位置，有可能会造成长时间阻塞，线上环境不建议使用*bgsave 操作命令：bgsave 作用：手动启动后台保存操作，但不是立即执行 注意：bgsave命令是针对save阻塞问题做的优化，redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用 自动执行RDB 配置：save second changes 作用：满足限定时间范围内key的变化数量达到指定数量，即进行持久化 参数： second：监控时间范围 changes：监控key的变化量 位置：在conf文件中进行配置 示例： save 900 1 -&gt; 900秒内变化1个即触发RDB save 300 10 -&gt; 300秒内变化10个即触发RDB save 60 10000 -&gt; 60秒内变化10000个即触发RDB 经验：一般监控时间大，变化时间小 自动执行RDB注意 save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的 save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含行关系 save配置启动后执行的是bgsave操作 三种方案对比 方式 save指令 bgsave指令 save配置 读写 同步 异步 阻塞客户端指令 是 否 额外内存消耗 否 是 启动新进程 否 是 RDB特殊启动形式 全量复制：（主从复制再说） 服务器运行过程中重启：debug reload 关闭服务器时指定保存数据：shutdown save RDB优点 RDB是一个紧凑压缩的二进制文件，存储效率较高 RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景 RDB恢复数据的速度要比AOF快很多 应用：服务器中每N小时执行bgsave备份，并将RDB文件拷贝到远程服务器中，用于灾难恢复 RDB缺点 RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据 bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能 Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象 AOFRDB存储的弊端 存储数据量较大，效率较低。基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低 大数据量下的IO性能较低 基于fork创建子进程，内存产生额外消耗 宕机带来的数据丢失风险解决思路 不写全数据，仅记录部分数据 改记录数据为记录操作过程 对所有数据操作均进行记录，排除丢失数据的风险 概念 AOP(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令，以达到恢复数据的目的，与RDB相比可以简单描述为改记录数据为记录数据产生的过程 AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式 AOF写数据三种策略(appendfsync) always(每次)：每次写入操作均同步到AOF文件中，数据零误差，性能较差 everysec(每秒)：每秒将缓冲区的指令同步到AOF文件中，数据准确性较高，性能较高，在系统突然宕机的情况下丢失1秒内的数据。建议使用，也是默认配置项 no(系统控制)：由操作系统控制每次同步到AOF文件的周期，整体过程不可控 AOF配置 配置：appendonly yes|no 作用：是否开启AOF持久化功能，默认为不开启状态 经验：开启 配置：appendfsync always|everysec|no 作用：AOF写数据策略 经验：everysec 配置：appendfilename filename 作用：AOF持久化文件名，默认文件名为appendonly.aof 经验：建议配置为appendonly-端口号.aof 配置：dir 作用：AOF持久化文件保存路径 经验：与RDB持久化文件保持一致即可 AOF重写随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为些命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干条命令执行结果转化成最终结果数据对应的指令进行记录。 AOF重写作用 降低磁盘占用量，提高磁盘利用率 提高持久化效率，降低持久化写时间，提升IO性能 降低数据恢复用时，提高数据恢复效率 AOF重写规则 进程内已超时的数据不再写入文件 忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令 如：del key1、hdel key2、srem key3、set key4 111、set key4 222 对同一数据的多条写命令合并为同一条命令 如：push list1 a、lpush list1 b、lpush list1 c可以转为：lpush list1 a b c 为了防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素 AOF重写方式 手动重写：bgrewriteaof 自动重写 12auto-aof-rewrite-min-size sizeauto-aof-rewrite-percentage percentage AOF自动重写方式 自动重写触发条件设置 12auto-aof-rewrite-min-size size --自动AOF的重写尺寸(默认值比较大)auto-aof-rewrite-percentage percent --自动重写的百分比 自动重写触发对比参数（运行指令info persistence获取具体信息） 12aof_current_sizeaof_base_size 自动重写触发条件 12aof_current_size &gt; auto_aof_rewrite_min_sizeaof_current_size - aof_base_size &#x2F; aof_base_size &gt;&#x3D; auto-aof-rewrite-percentage AOF非重写流程 AOF重写流程 RDB与AOF区别 持久方式 RDB AOF 占用存储空间 小（数据级：压缩） 大（指令集：重写） 存储速度 慢 快 恢复速度 快 慢 数据安全性 会丢失数据 依据策略决定 消耗资源 高/重量级 低/轻量级 启动优先级 低 高 RDB与AOF怎么选 对数据非常敏感，建议使用默认的AOF持久化方案 AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍然可以保持很好的性能，当出现问题时，最多丢失0-1秒钟的数据 注意：AOF文件存储体积较大，且恢复速度较慢 数据呈现具有有效性，建议使用RDB持久化方案 数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度快，阶段点数据恢复通常采用RDB方案 注意：利用RDB实现紧凑的数据持久化会使Redis性能降得很低 综合比对 RDB与AOF的选择实际上是在做一种权衡，每种都有利弊 如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF 如能承受数分钟以内的数据丢失，且追求大数据的恢复速度，选用RDB 灾难恢复选用AOF 双保险策略，同时开启RDB和AOF，重启后，Redis优先使用AOF来恢复数据，降低丢失数据的量 事务简介为什么要有事务：Redis执行指令过程中，多条连续执行的指令被干扰、打断、插队 Redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或干扰。 一个队伍中，一次性、顺序性、排他性的执行一系列命令 基本操作 开启事务：multi 作用：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中 执行事务：exec 作用：设定事务的结束位置，同时执行事务。与multi成对出现，成对使用 取消事务：discard 作用：终止当前事务的定义，发生在multi之后，exex之前 注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行 事务的工作流程 事务的注意事项 定义事务的过程中，命令格式输入错误怎么办？ 语法错误：指命令书写格式有误 处理结果：如果定义的事务中所包含存在语法错误，整体事务中所有命令均不会执行，包括那些语法正确的命令 定义事务的过程中，命令执行出现错误怎么办？ 运行错误：指命令格式正确，但是无法正确的执行，例如对list进行incr操作 处理结果：能够正确运行的命令会执行，运行错误的命令不会执行 注意：已经执行的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚 手动进行事务回滚（无奈之举才用） 记录操作过程中被影响的数据之前的状态 单数据：string 多数据：hash、list、set、zset 设置指令恢复所有的被修改的项 单数据：直接set（注意周边属性，例如时效） 多数据：修改对应值或整体克隆复制 锁 – 基于特定条件的事务执行乐观锁业务分析 多个客户端都有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作 在操作之前锁定要操作的数据，一旦发生变化，终止当前操作解决方案 对key添加监视锁，在执行exec前如果key发生了变化，终止事务执行：watch key1 [key2...] 取消对所有key的监视：unwatch watch命令在事务开启之前，然后在执行事务的exec的时候，会判断watch的值是否已经发生变化，如果没有则正常事务执行，如果发生了变化，则操作watch的命令失败 分布式锁业务分析 使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据 虽然Redis是单线程，但是多个客户对同一个数据同时进行操作时，如何避免不被同时修改解决方案 设置setnx设置一个公共锁：setnx lock-key value 利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功 对于返回设置成功的，拥有控制权，进行下一步的具体业务操作 对于返回设置失败的，不具有控制权，排队或等待 操作完毕通过del操作释放锁 死锁业务分析 由于锁操作由用户控制加锁解锁，必定会存在加所有未解锁的风险 需要解锁操作不能仅依赖用户控制，系统级别要能给出对应的保底处理方案解决方案 使用expire为锁key添加时间限定，到时不释放锁，放弃锁 12expire lock-key secondpexpire lock-key milliseconds 由于操作通常都是微妙或毫秒级，因此该锁定时间不宜设置过长，具体时间需要业务测试后确定 例如：持有锁的操作最长执行时间127ms，最短执行时间7ms 测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时 锁时间设定推荐：最大耗时*120% + 平均网络延迟*100% 如果业务最大耗时&lt;&lt;网络平均耗时，通常为2个数量级，取其中单个耗时较长即可 删除策略Redis中的数据特征 Redis是一种内存及数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态 XX：具有时效性的数据 -1：永久有效的数据 -2：已经过期的数据 或 被删除的数据 或 未定义的数据 数据删除策略的目的：在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体Redis性能的下降，甚至引发服务器宕机或内存泄露 定时删除创建一个定时器，当key设置由过期时间，且过期时间到达时，由定时器立即执行对键的删除操作 优点：解决内存，到时就删除，快速释放掉不必要的内存占用 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响Redis服务器响应时间和指令吞吐量 总结：用处理器性能换存储空间（拿时间换空间） 惰性删除数据到达过期时间，不做处理，等下次访问该数据时再进行删除，并返回不存在 优点：节约CPU性能，发现必须删除的时候才删除 缺点：内存压力很大，出现长期占用内存的数据 总结：用存储空间换取处理器性能（拿空间换时间） 定期删除 Redis启动服务器初始化时，读取配置server.hz的值，默认为10 每秒执行server.hz次serverCron()-&gt;databaseCron()-&gt;activeExpireCycle() activeExpireCycle()对每个expires[*]逐一进行检测，每次执行250ms/server.hz 对某个expires[*]检测时，随机挑选W个key检测 如果key超时，删除key 如果一轮中删除的key的数量 &gt; W*25%，则循环该过程 如果一轮中删除的key的数量 &lt;= W25%，检查下一个`expires[]`，db0-db15循环 W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值 参数current_db用来记录activeExpireCycle()进入那个expires[*]执行 周期性轮询Redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 特点1：CPU性能占用设置由峰值，检测频度可自定义设置 特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 总结：周期性抽查检查空间（随机抽查，重点抽查） 删除策略比对 删除策略 特点1 特点2 总结 定期删除 节约内存，无占用 部分时段占用CPU资源，频度高 拿时间换空间 惰性删除 内存占用严重 延时执行，CPU利用率高 拿空间换时间 定期删除 内存定期随机清理 每秒花费固定的CPU资源维护内存 随机抽查，重点抽查 逐出算法新数据进入检测 当新数据进入Redis时，如果内存不足怎么办？ Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足，如果内存不满足新加入数据的最低存储要求，Redis要临时删除一些数据为当前指令清除存储空间。清理数据的策略称为逐出算法 注意：逐出算法的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息影响数据逐出的相关设置 最大可使用内存 1maxmemory 占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。 每次选取待删除数据的个数 1maxmemory-samples 选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据 删除策略 1maxmemory-policy 达到最大内存后的，对被挑选出来的数据进行删除的策略 检测易失数据（可能会过期的数据集server.db[i].expires） volatile-lru：挑选最近最少使用的数据淘汰（推荐） volatile-lfu：挑选最近使用次数最少的数据淘汰 volatile-ttl：挑选将要过期的数据淘汰 volatile-random：任意选择数据淘汰 检测全库数据（所有数据集server.db[i].dict) allkeys-lru：挑选最近最少使用的数据淘汰 allkeys-lfu：挑选最近使用次数最少的数据淘汰 allkeys-random：任意选择数据淘汰 不使用数据驱逐 no-enviction(不驱逐)：禁止驱逐数据(redis4.0中默认策略)，会引发错误OOM(Out Of Memory) 配置方式 1maxmemory-policy volatile-lru 数据逐出策略配置依据 使用INFO命令输出监控信息，查询缓存hit和miss的次数，根据业务需求调优Redis配置 Redis.Conf服务器基础配置 设置服务器以守护进程的方式运行：daemonize yes|no 绑定主机地址：bind 127.0.0.1 设置服务器端口号：port 6379 设置数据库数量：databases 16 日志配置 设置服务器以指定日志记录级别：loglevel debug|verbose|notice|warning 日志记录文件名：logfile 端口号.log 注意：日志级别开发期设置为verbose，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度 客户端配置 设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接 1maxclient 0 客户端限制等待最长时长，达到最大值后关闭连接，如需要关闭该功能，设置为0 1timeout 300 多服务器快捷配置 导入并加载指定配置文件信息，用于快速创建Redis公共配置较多的Redis实例配置文件，便于维护 1include &#x2F;path&#x2F;server-端口号.conf 高级数据类型Bitmaps 获取指定key对应偏移量上的bit值 1getbit key offset 设置指定key对应偏移量上的bit值，value只能时1或0 1setbit key offset value 对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中 12345bitop op destKey key1 [key2...]&#x2F;&#x2F; and：交&#x2F;&#x2F; or：并&#x2F;&#x2F; not：非&#x2F;&#x2F; xor：异或 统计指定key中1的数量 1bitcount key [start end] HyperLogLog 基数：数据集去重后元素个数 HyperLogLog是用来做基数统计的，运用了LogLog的算法 添加数据：pfadd key element [element...] 统计数据：pfcount key [key...] 合并数据：pfmerge destKey sourceKey [sourceKey...] 说明 只用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数量 核心是基数估计算法，最终数值存在一定误差 误差范围：基数估计的结果是一个带有0.81%标准错误的近似值 耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数 pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存主键增大 pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多大 GEO 存放地理位置的数据类型基本操作 添加坐标点：geoadd key longitude latitude member [longitude latitude member...] 获取坐标点：geopos key member [member...] 计算坐标点距离：getdist key member1 member2 [unit](unit是单位，m=米 km=千米) 根据坐标求范围内的数据 1georadius key longitude latitude redius m|km|ft|mi [withcoord] [withdist] [withhash] [count count] 根据点求范围内的数据 1georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count] 获取指定点对应的坐标hash值 1geohash key member [member...]","categories":[{"name":"Redis","slug":"Redis","permalink":"http://www.dimsum.fun/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.dimsum.fun/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://www.dimsum.fun/tags/NOSQL/"}]},{"title":"Redis基础","slug":"45.Redis1_document","date":"2020-05-29T02:19:00.000Z","updated":"2020-05-31T15:58:31.056Z","comments":true,"path":"2020/05/29/45.Redis1_document/","link":"","permalink":"http://www.dimsum.fun/2020/05/29/45.Redis1_document/","excerpt":"","text":"概念 简介 特征 应用 数据类型 string 基本操作 set与mset 扩展操作 业务场景A 业务场景B 业务场景C key的设置约定 注意事项 hash 基本操作 扩展操作 注意事项 应用场景 业务场景A 业务场景B string存对象(json)和hash寸对象 list 基础操作 扩展操作 应用场景 业务场景A 注意事项 比较典型的业务场景 set 基本操作 扩展操作 应用场景 业务场景A 业务场景B 业务场景C 业务场景D 业务场景E 注意事项 sorted_set 基础操作 应用场景 业务场景A 业务场景B 业务场景C 注意事项 实践案例 业务场景A 业务场景B key通用操作 key基本操作 key的时效性控制 key的查询模式 key的其他操作 数据库通用操作 key的重复问题 基本操作 其他操作 概念简介Redis：Remote Dictionary Server，使用C语言开发的一个开源的高性能键值对(key-value)数据库 特征 数据间没有必然的关联关系 内部采用单线程机制进行工作 高性能。官方提供测试数据，50个并发执行100000个请求，读的速度是110000次/秒，写的速度是81000次/秒 多数据类型支持 字符串类型 string 列表类型 list 散列类型 hash 集合类型 set 有序集合类型 sorted_set 持久化支持，可以进行数据灾难恢复 应用 为热点数据加速查询(主要场景)，如热点商品、热点新闻、热点资讯、推广类高访问量信息等 任务队列，如秒杀、抢购、购票排队等 即时信息查询，如排行榜、各类网站访问统计、公交到站信息、在线人数信息、设备信号等 分布式数据共享，如分布式集群架构中的session分离 消息队列 分布式锁 数据类型string 存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型 存储数据的格式：一个存储空间保存一个数据 存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用基本操作 添加/修改数据：set key value 获取数据：get key 删除数据：del key 添加/修改多个数据：mset key1 value1 key2 value2 ... 获取多个数据：mge key1 key2 ... 获取数据字符串个数(字符串长度)：strlen key 追加信息到原始信息候补(如果原始信息存在就追加，否则新建)：append key value set与mset需要考虑以下几个点： set是一条指令条操作一条数据，mset是一条指令操作多条记录。指令的传输和响应都需要耗时 redis是单线程执行指令，在执行指令的时候需要耗时，如果mset包含的数据太多，会阻塞redis 所以：一般少量数据两者影响不大，大量数据分割成合适的大小，再多次使用mset，这样能减少指令传输耗时和减少redis阻塞时间 扩展操作业务场景A大型企业级应用中，分表操作时基本操作，使用多张表存储同类型数据，但是对应的主键id必须保证统一性，不能重复。Oracle数据库具有sequence设定，可以解决该问题，但是MySql数据库并不具有类似的机制，怎么解决？ 解决方案 设置数值数据增加指定范围的值123incr keyincrby key incrementincrbyfloat ket increment 设置数值数据减少指定范围的值12decr keydecr key increment string作为数值操作 string在redis内部存储默认就是一个字符串，当遇到增减类操作incr、decr时会转成数值型进行计算 redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响 注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis数值上线范围，将报错 业务场景B活动海选投票，只能通过微信投票，每个微信号每4小时只能投1票。 电商商家开启热门商品推荐，热门商品不能一直处于热门期，每个商品热门期持续3天，3天后自动取消热门 新闻网站会出现热点新闻，热点新闻最大的特征就是时效性，如何自动控制热点新闻的时效性 解决方案 设置数据具有指定的生命周期12setex key seconds valuepsetex key milliseconds value redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 业务场景C主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数和微博数量 解决方案 在redis中为大V用户设定用户信息，以用户主键和属性值为key，后台设定定时刷新策略即可123eg -&gt; user:id:544935942:fans -&gt; 120658eg -&gt; user:id:544935942:blogs -&gt; 6164eg -&gt; user:id:544935942:focuss -&gt; 100 在redis中以json格式存储大V用户信息，定时刷新(也可以使用hash类型)1eg -&gt; user:id:544935942 -&gt; &#123;id:544935942,name:张三,fans:120658,blogs:6164,focuss:100&#125; redis应用于各种结构性和非结构性高热度数据访问加速* key的设置约定数据库中的热点数据key命名惯例，以:拼接 表名 主键名 主键值 字段名 eg1： order id 20200415 name eg2： equip id 82295157 type eg3： news id 544935942 title 注意事项 数据操作不成功的反馈与数据正常操作之间的差异 表示运行结果是否成功 (integer)0 -&gt; false -&gt; 失败 (integer)1 -&gt; true -&gt; 成功 表示运行结果值 (integer)3 -&gt; 表示3个 (integer)1 -&gt; 表示1个 数据未获取到 (nill) -&gt; null 数据最大存储量 512MB 数值计算有最大范围 hash 新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息 需要的存储结构：一个存储空间保存多个键值对数据 hash存储结构优化 如果field数量较少，存储结构优化为类数组结构 如果field数量较多，存储结构使用HashMap结构 基本操作 添加/修改单条数据：hset key field value 获取指定field数据：hget key field 获取全部field数据：hgetall key 删除数据：hdel key field1 field2 ... 添加/修改多条数据：hmset key field1 value1 field2 value2 ... 获取多条数据：hmget key field1 field2 ... 获取hash表中字段的数量：hlen key 获取hash表中是否存在指定的字段：hexists key field 扩展操作 获取hash表中所有的字段或字段值12hkeys keyhvals key 设置指定字段的数值数据增加指定范围的值12hincrby key field incrementhincrbyfloat key field increment 注意事项 hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象，如果数据未获取到，对应值为nil 每个hash可以存储2的32次方-1个键值对 hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性，但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用 应用场景业务场景A电商网站购物车设计与实现 解决方案： 仅分析购物车的redis存储模型：添加、浏览、更改数量、删除、清空12345678910用户Id -&gt; Key购物车商品Id&#x2F;SkuId -&gt; field购物车商品数量 -&gt; value添加商品 -&gt; hset修改数量 -&gt; hset&#x2F;hincrby删除商品 -&gt; hdel商品条目数 -&gt; hlen商品总数 -&gt; sum(hvals)浏览商品 -&gt; hgetall 按照上述的操作方式，可以发现redis中只存储了购物车的商品id和商品数量，并未存储商品信息，这样在查询整个购物车的时候，还需要二次查询商品信息，所以还需要做改进，可以将商品提取到单独一个hash中12345key -&gt; shoppingcart:product.infofield -&gt; 商品Id:infovalue -&gt; 商品信息当用户添加商品到购物车的时候，通过 hsetnx key field value将商品存入shoppingcart:product.info，这样做可以避免重复添加商品到hash中 业务场景B销售手机充值卡的商家对移动、联通、电信的30元、50元、100元的商品退出抢购活动，每种商品抢购上线1000长 解决方案： 以商家id作为key 将参与抢购的商品id作为field 将参与抢购的商品数量作为对应的value 抢购时使用降值得方式控制产品数量 string存对象(json)和hash寸对象 string存对象讲究整体性，一次性存一次性取，讲究读为主 hash存对象，用field把属性隔离开，主要讲究得是更新操作比较有灵活性，讲究写为主 说通俗一点，当一个对象不需要频繁修改，只是存储之后查出来展示，那么用string来存是可以的，如果一个对象经常需要对各个属性进行修改，那么就使用hash，hash可以修改指定field的值 list 数据存储需求：存储多个数据，并对数据进行存储空间的顺粗进行区分 需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序 list类型：保存多个数据，底层使用双向链表存储结构实现 顺序表（查询快，增删慢），链表（查询慢，增删快），双向链表 基础操作 添加/修改数据12lpush key value1 value2 ...rpush key value1 value2 ... 获取数据123lrange key start stop (lrange key 0 -1 表示查询整个列表)lindex key indexllen key 获取并移除数据12lpop keyrpop key 扩展操作 规定时间内获取并移除数据12blpop key1 key2 ... timeoutbrpop key1 key2 ... timeout 就是当list没数据的时候，执行上面的命令会阻塞，等有其他客户端往上面监听的list添加数据，随后被取出，timeout为超时时间，单位为秒 应用场景业务场景A微信朋友圈点赞，要求按点赞顺序显示点赞好友信息，如果取消点赞，则移除对应好友信息 解决方案： 1234朋友圈Id -&gt; key -&gt; 举例 -&gt; a01用户点赞 -&gt; rpush -&gt; 举例 -&gt; rpush a01 zhangsan lisi wangwu展示 -&gt; lrange key start stop -&gt; 举例 -&gt; lrang a01 0 -1取消点赞 -&gt; lrem key count value -&gt; 举例 -&gt; lrem a01 1 lisi 注意事项 list中保存的数据都是string类型，数据总容量也是有限的，最多2的32次方-1个元素 list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作 获取全部数据操作结束索引设置为-1 list可以对数据进行分页操作，通常第一页的信息来自list，第2页及更多的信息通过数据库的形式加载 比较典型的业务场景 twitter、微博中个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面 新闻、资讯类网站将最新的新闻或咨询按照发生的时间顺序展示 企业运营过程中，系统将产出大量的运营数据，保障堕胎服务器操作日志的统一顺序输出 上面的解决方案 依赖list的数据具有顺序的特征对信息进行管理 使用栈模型解决最新消息的问题 使用队列模式解决多路信息汇总合并的问题 set 存储需求：存储大量的数据，在查询方便提供更高的效率 需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询 set类型：与hash存储结构完全相同，仅存储键，不存储值(nil)，并且值时不允许重复的 基本操作 添加数据：sadd key member1 member2 ... 获取全部数据：smembers key 删除数据：srem key member1 member2 ... 获取集合数据总量：scard key 判断集合中是否包含指定数据：sismember key member 随机获取集合中指定数量的数据：srandmember key [count] 随机获取集合中某个数据并将该数据移出集合：spop key ... 扩展操作 求两个集合的交、并、差集123sinter key1 key2sunion key1 key2sdiff key1 key2 求两个集合的交、并、差集并存储到指定集合中123sinterstore destination key1 key2sunionstore destination key1 key2sdiffstore destination key1 key2 将指定数据从原始集合中移动到目标集合中1smove source destination member 应用场景业务场景A每位用户首次使用今日头条会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户对其他信息类别主键产生兴趣，增加客户留存都，该如何实现？ 业务分析 系统分析出各个分类的最新或最热点信息条目并组织成set集合 随机挑选其中部分信息 配合用户关注信息分类中的热点信息组成展示的全信息集合 redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热点旅游线路，应用APP推荐，大V推荐等 业务场景B脉脉之类的APP中共同好友的功能，这里通过两个set进行交并差集的运算可以满足需求 redis应用于同类信息的关联搜索，二度关联搜索，深度关联搜索 显示共同关注（交集）（一度） 显示共同好友（交集）（一度） 由用户A出发，获取到好友用户B的好友信息列表（一度） 由用户A出发，获取到好友用户B的购物清单列表（二度） 由用户A出发，获取到好友用户B的游戏充值列表（二度） 业务场景C集团公司共具有12000名员工，内部OA系统中具有700多个角色，3000多个业务操作，23000多中数据，每个员工具有一个或多个角色，如何快速进行业务操作的权限校验？ 解决思路： 依赖set集合数据不重复的特征，依赖set集合hash存储结构特征完成数据过滤与快速查询 根据用户id获取用户所有角色 根据用户所有角色获取用户所有操作权限放入set集合 根据用户所有角色获取用户所有数据权限放入set集合 业务场景D统计网站的PV、UV、IP 解决思路： 利用set集合的数据去重特转增，记录各种访问数据 建立string类型数据，利用incr统计日访问量 建立set模型，记录不同cookie数量(UV) 建立set模型，记录不同IP数量(IP) 业务场景E黑白名单 解决思路： 基于经营战略设定问题用户发现、鉴别规则 周期性更新满足规则的用户黑名单，加入set集合 用户行为信息达到后于黑名单进行比对，确认行为去向 黑名单过滤IP地址：应用于开放游客访问权限的信息源 黑名单过滤设备信息：应用于限定访问设备的信息源 黑名单过滤用户：应用于基于访问权限的信息源 注意事项 set类型不允许数据重复，如果添加的数据在set中已经存在，将只保留一份 set虽然于hash的存储结构相同，但是无法启用hash中存储值的空间 sorted_set 存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式 需要的存储结构：新的存储模型，可以保存可排序的数据 sorted_set类型：在set的存储结构上添加可排序字段 基础操作 添加数据1zadd key score1 member [score2 member] ... 获取全部数据12zrang key start stop [WITHSCORES]zrevrange key start stop [WITHSCORES] 删除数据1zrem key member [member ...] 按条件获取数据12zrangebyscore key min max [WITHSCORES] [LIMIT]zrevrangebyscore key max min [WITHSCORES] 按条件删除数据12zremrangebyrank key start stopzremrangebyscore key min max 获取集合数据总量12zcard keyzcard key min max 集合交、并操作12zinterstore destination numkeys key [key ...]zunionstore destination numkeys key [key ...] 获取数据对应的索引(排名)12zrank key memeberzrevrank key member score值获取与修改12zscore key memberzincrby key increment member 注意： min与max用于限定搜索查询的条件 start与stop用于限定查询访问，作用于索引，表示开始和结束索引 offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量 应用场景业务场景A海选投票、各种TopN排行榜、聊天室活跃度统计、游戏好友亲密度 解决方案：通过获取索引 业务场景B体验VIP功能，当体验VIP到期后，如何有效管理此类信息，即便对于正式VIP用户也应该存在对应的管理方式。网站定期开启投票、讨论、限期进行，逾期作废，如何有效管理此类过期信息 解决方案： 对基于时间线限定的任务处理，将处理时间记录为score值，利用顺序功能分区处理的先后顺序 记录下一个要处理的时间，当到期后处理对应任务，移除redis中的记录，并记录下一个要处理的时间 当新任务加入时，判断并更新当前下一个要处理的任务时间 为提升sorted_set的性能，通常将任务根据特征存储成若干个sorted_set，例如1小时内、1天内、周内、月内、季内、年内等，操作时逐级提升，将即将操作的若干任务纳入到1小时内处理的队伍中 业务场景C任务/消息权重设定应用：当任务或消息待处理，形成了任务队列或消息队列时，对于高优先级的任务要保障对其优先处理 解决方案： 对于带权重的任务，优先处理权重高的任务，采用score记录权重即可 注意事项 score保存的数据存储空间是64位 score保存的数据也可以是个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时要慎重 sorted_set底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果 实践案例业务场景A人工智能领域的语义识别与自动对话将是未来服务业机器人应答呼叫体系中的重要技术，百度自研用户评价语义识别服务，免费开放给企业试用，同时训练百度自己的模型。现对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用 解决方案： 设计计数器，记录调用次数，用于控制业务执行次数，以用户id作为key，使用次数为value 在调用前获取次数，判断是否超过限定次数 不超过次数的情况下，每次调用技术+1 超过次数则业务调用失败，计数-1 为计时器设置生命周期为指定周期，例如1秒/分钟，自动清空周期内使用次数 解决方案改良： 取消最大值的判断，利用incr操作超过最大值抛出异常的形式替代每次判断是否大于最大值 判断值是否为nil 如果是，设置为数值的Max-次数 如果不是，计数+1 业务调用失败，计数-1 遇到异常即+操作超过上限，视为使用达到上限 业务场景B使用微信的过程中，当微信接收消息后，会默认将最近接受的消息置顶，当多个好友及关注的订阅号同时发送消息时，该顺序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户里离线后，再次打开微信时，消息该按照什么样的顺序显示？ 解决方案： 依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用 对指定与普通会话分别创建独立的list分别管理 当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list(此处设定左侧) 多个消息id发出的消息反复入栈会出现问题，在入栈前无论是否具有当前id对应的消息，先删除对应id 推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据 消息的数量，也就是微信用户对话数量采用计数器的思路另行记录，伴随list操作同步更新 key通用操作key基本操作 删除指定key：del key 获取key是否存在：exists key 获取key的类型：type key key的时效性控制 为指定key设置有效期 1234expire key secondspexpire key millisecondsexpireat key timestamppexpireat key milliseconds-timestamp 获取key的有效实践 12ttl keypttl key 切换key从时效性转换为永久性 1persist key key的查询模式 查询key：keys parttern，查询模式规则： *：匹配任意数量的任意符号 ?：匹配一个任意字符 []：匹配一个指定符号 举例： 123456keys * -&gt; 查询所有keys it* -&gt; 查询所有以it开头keys *save -&gt; 查询所有以save结尾keys ??user -&gt; 查询所有前面两个任意字符，后面以user结尾keys user:&quot; -&gt; 查询所有以user:开头，后面一个任意字符keys u[st]er:1 -&gt;查询所有以u开头，以er:1结尾，中间包含字符s或t key的其他操作 为key改名12rename key newkeyrenamenx key newkey 对所有key排序1sort 其他key通用操作1help @generic 数据库通用操作key的重复问题 key是由程序员定义的 redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key 数据不区分种类、类别混在在一起，极易出现重复或冲突 解决方案： redis为每个服务提供有16个数据库，编号从0到15 每个数据库之间的数据相互独立 基本操作 切换数据库1select index 其他操作123quitpingecho message 其他操作 数据移动1move key db 数据清除123dbsize --库里有多少个keyflushdb --清空当前数据库flushall --清空有数据库","categories":[{"name":"Redis","slug":"Redis","permalink":"http://www.dimsum.fun/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.dimsum.fun/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://www.dimsum.fun/tags/NOSQL/"}]},{"title":"RabbitMQ进阶","slug":"44.RabbitMq2_document","date":"2020-05-29T01:32:00.000Z","updated":"2020-05-31T15:58:31.056Z","comments":true,"path":"2020/05/29/44.RabbitMq2_document/","link":"","permalink":"http://www.dimsum.fun/2020/05/29/44.RabbitMq2_document/","excerpt":"","text":"消息是如何保障100%的投递成功 生产端的可靠性投递 具体解决方案 幂等性/怎么避免重复消费 消费端-幂等性保障 具体解决方案 Confirm确认消息 代码示例 创建项目 具体代码 Return返回消息 代码示例 创建项目 具体代码 自定义消费者 代码示例 创建项目 具体代码 消息的ACK与重回队列 消费端的手工ACK和NACK 消费端的重回队列 代码示例 创建项目 具体代码 源码：https://github.com/xiejiamiao/AllSamples 消息是如何保障100%的投递成功生产端的可靠性投递 保障消息的成功发出 保障MQ节点的成功接受 发送端收到MQ节点(Broker)确认应答 完善的消息进行补偿机制 具体解决方案 消息落库，对消息状态进行达标。即在发送消息的时候将消息持久化到数据库中，然后进行状态维护 缺陷：需要对消息做持久化，这样在遇到高并发的场景，数据库压力大 消息的延迟投递，做二次确认，回调检查 幂等性/怎么避免重复消费幂等性：通俗的讲就是一个操作不管做多少次，结果永远都一样 消费端-幂等性保障消费端实现幂等性，就意味着消费端永远不会消费多次，即使消费端收到多条一样的消息 具体解决方案 唯一ID+指纹码机制 唯一ID+指纹码 机制，利用数据库主键去重 SELECT COUNT(1) FROM T_ORDER WHERE ID=(唯一ID+指纹码) 好处：实现简单 坏处：高并发下有数据库写入的性能瓶颈 解决方案：跟进ID进行分库分表进行算法路由 利用Redis的原子性去实现 数据是否需要进行数据落库，如果落库的话，关键解决的问题是数据库和缓存如何做到原子性 如果数据不落库，那么都存在缓存中，如何设置定时同步的策略 Confirm确认消息 消息的确定，是指生产者投递消息后，如果Broker收到消息，则会给生产者一个应答 生产者进行接受应答，用来确定这条消息是否正常的发送给Broker，这种方法也是消息的可靠性投递的核心保障 代码示例创建项目创建两个控制台应用程序 12ComfirmSample.ConsumerComfirmSample.Producer 再分别通过nuget引入RabbitMQ.Client 具体代码ComfirmSample.Producer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Text;using RabbitMQ.Client;namespace ComfirmSample.Producer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;****** Confirm Sample Producer ******&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); &#x2F;&#x2F; 指定消息投递模式&#x3D;Confirm channel.ConfirmSelect(); var exchangeName &#x3D; &quot;test_confirm_exchange&quot;; var routingKey &#x3D; &quot;confirm.save&quot;; var message &#x3D; &quot;Hello RabbitMQ For Confirm Message&quot;; var body &#x3D; Encoding.UTF8.GetBytes(message); channel.BasicPublish(exchangeName, routingKey, null, body); &#x2F;&#x2F; 添加确认监听 channel.BasicAcks +&#x3D; (sender, ea) &#x3D;&gt; &#123; Console.WriteLine($&quot;消息确认被MQ收到 DeliveryTag&#x3D;&#123;ea.DeliveryTag&#125;&quot;); &#125;; &#x2F;&#x2F; no ack-ed channel.BasicNacks +&#x3D; (sender, ea) &#x3D;&gt; &#123; Console.WriteLine($&quot;消息发送失败 DeliveryTag&#x3D;&#123;ea.DeliveryTag&#125;&quot;); &#125;; Console.WriteLine(&quot;消息发送完成&quot;); Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; ComfirmSample.Consumer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System;using System.Text;using RabbitMQ.Client;using RabbitMQ.Client.Events;namespace ComfirmSample.Consumer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;****** Confirm Sample Consumer ******&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;test_confirm_exchange&quot;; var queueName &#x3D; &quot;test_confirm_queue&quot;; var routingKey &#x3D; &quot;confirm.save&quot;; channel.ExchangeDeclare(exchangeName,ExchangeType.Direct,true,false,null); channel.QueueDeclare(queueName, true, false, false, null); channel.QueueBind(queueName, exchangeName, routingKey, null); var consumer &#x3D; new EventingBasicConsumer(channel); channel.BasicConsume(queueName, true, consumer); consumer.Received +&#x3D; (model, ea) &#x3D;&gt; &#123; var body &#x3D; ea.Body; var message &#x3D; Encoding.UTF8.GetString(body.ToArray()); Console.WriteLine($&quot;接收到消息：&#123;message&#125;&quot;); &#125;; Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; Return返回消息 Return Listener用于处理一些不可路由的消息 消息生产者通过指定一个Exchange和RoutingKey，把消息送达到某一个队列中去，然后消息监听者监听队列，进行消费处理操作 但是在某些情况下，如果我们在发送消息的时候，当前的Exchange不存在或者指定的路由key路由不到，这个时候如果我们需要监听这种不可达的消息，就要使用Return Listener Mandatory：如果为true，则监听器会接受到路由不可达的消息，然后进行后续处理，如果为false，那么broker端会自动删除该消息 代码示例创建项目创建两个控制台应用程序 12ReturnListenerSample.ConsumerReturnListenerSample.Producer 再分别通过nuget引入RabbitMQ.Client 具体代码ReturnListenerSample.Producer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Text;using RabbitMQ.Client;namespace ReturnListenerSample.Producer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;****** Return Listener Producer ******&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;return_listener_exchange&quot;; var routingKey &#x3D; &quot;order.save&quot;; var routingKeyError &#x3D; &quot;abc.save&quot;; var message &#x3D; &quot;Hello RabbitMQ For ReturnListener&quot;; var body &#x3D; Encoding.UTF8.GetBytes(message); channel.BasicPublish(exchangeName,routingKey,mandatory:true,null,body); channel.BasicPublish(exchangeName, routingKeyError, mandatory: true, null, body); channel.BasicReturn +&#x3D; (model, ea) &#x3D;&gt; &#123; Console.WriteLine(&quot;---------- 消息发送失败 ----------&quot;); Console.WriteLine($&quot;ReplyCode &#x3D; &#123;ea.ReplyCode&#125;&quot;); Console.WriteLine($&quot;ReplyText &#x3D;&#123;ea.ReplyText&#125;&quot;); Console.WriteLine($&quot;Exchange &#x3D; &#123;ea.Exchange&#125;&quot;); Console.WriteLine($&quot;RoutingKey &#x3D; &#123;ea.RoutingKey&#125;&quot;); &#125;; Console.WriteLine(&quot;消息发送完成&quot;); Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; ReturnListenerSample.Consumer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;using System.Text;using RabbitMQ.Client;using RabbitMQ.Client.Events;namespace ReturnListenerSample.Consumer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;****** Return Listener Consumer ******&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;return_listener_exchange&quot;; var routingKey &#x3D; &quot;order.#&quot;; var queueName &#x3D; &quot;return_listener_queue&quot;; channel.ExchangeDeclare(exchangeName,ExchangeType.Topic,true,false,null); channel.QueueDeclare(queueName, true, false, false, null); channel.QueueBind(queueName,exchangeName,routingKey,null); var consumer &#x3D; new EventingBasicConsumer(channel); channel.BasicConsume(queueName, true, consumer); consumer.Received +&#x3D; (model, ea) &#x3D;&gt; &#123; var body &#x3D; ea.Body; var message &#x3D; Encoding.UTF8.GetString(body.ToArray()); Console.WriteLine($&quot;接收到消息 &#123;message&#125;&quot;); &#125;; Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; 自定义消费者自定义Consumer在日常工作中更常用，主要就是继承DefaultBasicConsumer这个类，然后override HandleBasicDeliver()这个方法即可 代码示例创建项目创建两个控制台应用程序 12CustomerConsumer.ConsumerCustomerConsumer.Producer 再分别通过nuget引入RabbitMQ.Client 在CustomerConsumer.Consumer中创建类MyConsumer.cs 具体代码CustomerConsumer.Producer.Program.cs 12345678910111213141516171819202122232425262728293031323334353637383940using System;using System.Text;using RabbitMQ.Client;namespace CustomerConsumer.Producer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;****** Customer Consumer Producer ******&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;customer_consumer_exchange&quot;; var routingKey &#x3D; &quot;customer.save&quot;; var message &#x3D; &quot;Hello RabbitMQ For Customer_Consumer&quot;; var body &#x3D; Encoding.UTF8.GetBytes(message); for (int i &#x3D; 0; i &lt; 5; i++) &#123; channel.BasicPublish(exchangeName, routingKey, true, null, body); &#125; Console.WriteLine(&quot;消息发送完成&quot;); &#125; &#125;&#125; CustomerConsumer.Consumer.MyConsumer.cs 1234567891011121314151617181920212223242526272829using System;using System.Text;using RabbitMQ.Client;namespace CustomerConsumer.Consumer&#123; public class MyConsumer : DefaultBasicConsumer &#123; private readonly IModel _model; public MyConsumer(IModel model):base(model) &#123; _model &#x3D; model; &#125; public override void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory&lt;byte&gt; body) &#123; Console.WriteLine($&quot;consumerTag &#x3D; &#123;consumerTag&#125;&quot;); Console.WriteLine($&quot;deliveryTag &#x3D; &#123;deliveryTag&#125;&quot;); Console.WriteLine($&quot;redelivered &#x3D; &#123;redelivered&#125;&quot;); Console.WriteLine($&quot;exchange &#x3D; &#123;exchange&#125;&quot;); Console.WriteLine($&quot;routingKey &#x3D; &#123;routingKey&#125;&quot;); var message &#x3D; Encoding.UTF8.GetString(body.ToArray()); Console.WriteLine($&quot;Message &#x3D; &#123;message&#125;&quot;); Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125; &#125;&#125; CustomerConsumer.Consumer.Program.cs 12345678910111213141516171819202122232425262728293031323334353637using System;using RabbitMQ.Client;namespace CustomerConsumer.Consumer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;****** Customer Consumer Producer ******&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;customer_consumer_exchange&quot;; var routingKey &#x3D; &quot;customer.#&quot;; var queueName &#x3D; &quot;customer_consumer_queue&quot;; channel.ExchangeDeclare(exchangeName,ExchangeType.Topic,true,false,null); channel.QueueDeclare(queueName, true, false, false, null); channel.QueueBind(queueName, exchangeName, routingKey); channel.BasicConsume(queueName, true, new MyConsumer(channel)); Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; 消息的限流为什么需要消费端限流：当消费端处理能力达不到生产端的生产速度，或当Broker中囤积了巨量消息，当消费端启动之后，巨量消息同一时间全部推送到消费端，会直接导致消费端崩溃， RabbitMQ提供了一种Qos(服务质量保证)功能，即在非自动确认消息的前提下，如果一定数目的消息(通过基于consumer或者channel设置Qos的值)未被确认之前，不进行消费新的消息 主要操作方式就是调用channel上的BasicQos方法设置，其中参数意思如下： prefetchSize：表示单挑消息的最大限制，一般设置为0表示对单挑消息的体积大小不做限制 prefetchCount：表示Broker最多同时给一个消费者推送多少条消息，一旦有这么多条消息没有ack，则该consumer将block掉，知道有消息ack，Broker才会继续推消息 global：true/false，是否将上面的设置应用于channel，简单点说就是上面限制是channel级别还是consumer级别 注意：这里的设置一定是在调用channel.BasicConsume()的时候设置consumer的autoAck=false才有效，并且一般开发中都是将autoAck设置为false，然后在业务逻辑处理完之后再手动ack* 代码示例创建项目 创建两个控制台应用程序 12ConsumerLimit.ConsumerConsumerLimit.Producer 再分别通过nuget引入RabbitMQ.Client 在ConsumerLimit.Consumer中创建类MyConsumer.cs 具体代码ConsumerLimit.Producer.Program 1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Text;using RabbitMQ.Client;namespace ConsumerLimit.Producer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;********** Consumer Limit Producer **********&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;consumer_limit_exchange&quot;; var routingKey &#x3D; &quot;order.saved&quot;; var random &#x3D; new Random(); for (var i &#x3D; 0; i &lt; 10; i++) &#123; var message &#x3D; $&quot;Hello RabbitMQ For Consumer Limit &#123;random.Next(1,100)&#125;&quot;; var body &#x3D; Encoding.UTF8.GetBytes(message); channel.BasicPublish(exchangeName, routingKey, null, body); &#125; Console.WriteLine(&quot;消息发送完成&quot;); Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; ConsumerLimit.Consumer.MyConsumer 12345678910111213141516171819202122232425262728293031323334353637using System;using System.Collections.Generic;using System.Text;using System.Threading;using RabbitMQ.Client;namespace ConsumerLimit.Consumer&#123; public class MyConsumer:DefaultBasicConsumer &#123; private readonly IModel _channel; public MyConsumer(IModel channel):base(channel) &#123; _channel &#x3D; channel; &#125; public override void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory&lt;byte&gt; body) &#123; Console.WriteLine(); Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); Console.WriteLine($&quot;接收到消息：&#123;Encoding.UTF8.GetString(body.ToArray())&#125;&quot;); Console.WriteLine($&quot;consumerTag &#x3D; &#123;consumerTag&#125;&quot;); Console.WriteLine($&quot;deliveryTag &#x3D; &#123;deliveryTag&#125;&quot;); Console.WriteLine($&quot;redelivered &#x3D; &#123;redelivered&#125;&quot;); Console.WriteLine($&quot;exchange &#x3D; &#123;exchange&#125;&quot;); Console.WriteLine($&quot;routingKey &#x3D; &#123;routingKey&#125;&quot;); Console.WriteLine($&quot;正在模拟业务操作...&quot;); Thread.Sleep(2000); Console.WriteLine(&quot;业务处理完毕&quot;); _channel.BasicAck(deliveryTag,false); Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); Console.WriteLine(); &#125; &#125;&#125; ConsumerLimit.Consumer.Program 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Text;using System.Threading;using RabbitMQ.Client;using RabbitMQ.Client.Events;namespace ConsumerLimit.Consumer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;********** Consumer Limit Consumer **********&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;consumer_limit_exchange&quot;; var routingKey &#x3D; &quot;order.#&quot;; var queueName &#x3D; &quot;consumer_limit_queue&quot;; channel.ExchangeDeclare(exchangeName, ExchangeType.Topic, true, false, null); channel.QueueDeclare(queueName, true, false, false, null); channel.QueueBind(queueName, exchangeName, routingKey, null); channel.BasicConsume(queueName, false, new MyConsumer(channel)); channel.BasicQos(prefetchSize:0,prefetchCount:1,global:false); Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; 消息的ACK与重回队列消费端的手工ACK和NACK ACK=消息已经成功处理了 NACK=消息我处理失败了(Broker会进行重新投递) 使用场景： 消费端进行消费的时候，如果由于业务异常可以进行NACK，当尝试到足够的次数都一直处理失败，则返回记录日志后续做补偿，然后返回ACK 由于服务器宕机等严重问题，Broker即没收到ACK也没有收到NACK，那么Broker也会进行重新推送消息，这时如果处理完消息，返回ACK可以保障Broker知道消费端已经成功消费 消费端的重回队列 消费端重回队列是为了对没有处理成功的消息，把消息重新会递给Broker 一般在实际应用中，都会关闭重回队列，也就是设置为False 代码示例创建项目 创建两个控制台应用程序 12AckSample.ConsumerAckSample.Producer 再分别通过nuget引入RabbitMQ.Client 在AckSample.Consumer中创建类MyConsumer.cs 具体代码AckSample.Producer.Program 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;using System.Collections.Generic;using System.Text;using RabbitMQ.Client;namespace AckSample.Producer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;********** ACK Sample Producer **********&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;ack_sample_exchange&quot;; var routingKey &#x3D; &quot;order.saved&quot;; var random &#x3D;new Random(); for (var i &#x3D; 0; i &lt; 10; i++) &#123; var properties &#x3D; channel.CreateBasicProperties(); properties.DeliveryMode &#x3D; 2; properties.ContentEncoding &#x3D; &quot;UTF-8&quot;; properties.Headers &#x3D; new Dictionary&lt;string, object&gt;() &#123;&#123;&quot;num&quot;, random.Next(0, 10).ToString()&#125;&#125;; var message &#x3D; $&quot;Hello RabbitMQ For ACK -&gt; &#123;i&#125;&quot;; var body &#x3D; Encoding.UTF8.GetBytes(message); channel.BasicPublish(exchangeName, routingKey, properties, body); &#125; Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; AckSample.Consumer.MyConsumer 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Text;using System.Threading;using RabbitMQ.Client;using Console &#x3D; System.Console;namespace AckSample.Consumer&#123; public class MyConsumer:DefaultBasicConsumer &#123; private readonly IModel _channel; public MyConsumer(IModel channel):base(channel) &#123; _channel &#x3D; channel; &#125; public override void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory&lt;byte&gt; body) &#123; Console.WriteLine(); Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); var stringNum &#x3D; properties.Headers[&quot;num&quot;]; var byteNum &#x3D; stringNum as byte[]; Console.WriteLine($&quot;接收到消息 num&#x3D;&#123;Encoding.UTF8.GetString(byteNum)&#125; &#123;Encoding.UTF8.GetString(body.ToArray())&#125;&quot;); Console.WriteLine(&quot;......模拟业务操作......&quot;); var num &#x3D; int.Parse(Encoding.UTF8.GetString(byteNum)); if (num % 2 &#x3D;&#x3D; 0) &#123; Console.WriteLine(&quot;......业务处理失败......&quot;); _channel.BasicNack(deliveryTag, false, true); &#125; else &#123; Console.WriteLine(&quot;......业务处理成功......&quot;); _channel.BasicAck(deliveryTag,false); &#125; Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); Console.WriteLine(); Thread.Sleep(2000); &#125; &#125;&#125; AckSample.Consumer.Program 1234567891011121314151617181920212223242526272829303132333435363738using System;using RabbitMQ.Client;namespace AckSample.Consumer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;********** ACK Sample Consumer **********&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;ack_sample_exchange&quot;; var queueName &#x3D; &quot;ack_sample_queue&quot;; var routingKey &#x3D; &quot;order.saved&quot;; channel.ExchangeDeclare(exchangeName, ExchangeType.Topic, true, false, null); channel.QueueDeclare(queueName, true, false, false, null); channel.QueueBind(queueName,exchangeName,routingKey); channel.BasicConsume(queueName, false, new MyConsumer(channel)); Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; TTL消息主要就是两点，TTL可以针对消息本身也可以针对消息队列 消息本身通过消息的Properties中设置Expiration属性来设置过期时间 Queue通过声明的时候在arguments字典参数里添加x-message-ttl这个键值对来设置进入该消息队列的消息有效期 DLX–死信队列(Dead-Letter-Exchange)利用DLX，当消息在一个队列变成死信(dead message)之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX 消息编程死信的情况： 消息被拒绝(basic.reject/basic.nack)，并且requeue=false(不再重回队列) 消息TTL过期 队列达到最大长度 死信队列 DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在仍和的队列上被指定，实际上就是设置某个队列的属性 当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列 可以监听这个队列中消息做相应的处理，这个特性可以弥补RabbitMQ以前支持的immediate参数的功能 死信队列设置： 首先需要设置死信队列的exchange和queue，然后进行绑定 Exchange：dlx.exchange Queue：dlx.queue RoutingKey：# 然后进行正常声明交换机、队列、绑定，只不过需要在队列上的arguments字典上加一个键值对：x-dead-letter-exchange:dlx.exchange ASP.NET Core做消费者主要思路：创建一个HostedService服务类，继承BackgroundService，override ExecuteAsync方法，然后在里面做消息监听，最后在Startup.ConfigureServices中注册这个HostedService 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475using System;using System.Collections.Generic;using System.Linq;using System.Threading;using System.Threading.Tasks;using Microsoft.Extensions.Hosting;using Microsoft.Extensions.Logging;using RabbitMQ.Client;using WebSiteConsumerSample.Consumers;&#x2F;&#x2F; ReSharper disable UnusedMember.Global&#x2F;&#x2F; ReSharper disable InconsistentNamingnamespace WebSiteConsumerSample.BackgroundServices&#123; public class ConsumeRabbitMQHostedService : BackgroundService &#123; private readonly ILogger&lt;ConsumeRabbitMQHostedService&gt; _logger; private readonly ILogger&lt;SolutionMessageConsumer&gt; _consumerLogger; private IConnection _connection; private IModel _channel; private string _exchangeName; private string _queueName; private string _routingKey; public ConsumeRabbitMQHostedService(ILogger&lt;ConsumeRabbitMQHostedService&gt; logger,ILogger&lt;SolutionMessageConsumer&gt; consumerLogger) &#123; _logger &#x3D; logger; _consumerLogger &#x3D; consumerLogger; InitRabbitMq(); &#125; private void InitRabbitMq() &#123; var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; _connection &#x3D; connectionFactory.CreateConnection(); _channel &#x3D; _connection.CreateModel(); var exchangeName &#x3D; &quot;dimsum_solution_exchange&quot;; var queueName &#x3D; &quot;dimsum_solution_queue&quot;; var routingKey &#x3D; &quot;solution.#&quot;; _exchangeName &#x3D; exchangeName; _queueName &#x3D; queueName; _routingKey &#x3D; routingKey; _channel.ExchangeDeclare(exchangeName, ExchangeType.Topic, true, false, null); _channel.QueueDeclare(queueName, true, false, false, null); _channel.QueueBind(queueName, exchangeName, routingKey, null); &#125; protected override async Task ExecuteAsync(CancellationToken stoppingToken) &#123; await Task.CompletedTask; stoppingToken.ThrowIfCancellationRequested(); _channel.BasicConsume(_queueName, false, new SolutionMessageConsumer(_channel, _consumerLogger)); &#125; public override void Dispose() &#123; _channel.Dispose(); _connection.Dispose(); base.Dispose(); &#125; &#125;&#125; 在Startup.ConfigureServices中添加 1services.AddHostedService&lt;ConsumeRabbitMQHostedService&gt;();","categories":[{"name":"消息队列","slug":"消息队列","permalink":"http://www.dimsum.fun/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://www.dimsum.fun/tags/RabbitMQ/"},{"name":"消息队列","slug":"消息队列","permalink":"http://www.dimsum.fun/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}]},{"title":"RabbitMQ基础","slug":"43.RabbitMq1_document","date":"2020-05-26T14:36:00.000Z","updated":"2020-05-31T15:58:31.055Z","comments":true,"path":"2020/05/26/43.RabbitMq1_document/","link":"","permalink":"http://www.dimsum.fun/2020/05/26/43.RabbitMq1_document/","excerpt":"","text":"主流消息中间件 ActiveMQ Kafka RocketMQ RabbitMQ RabbitMQ核心概念及AMQP协议 为什么用RabbitMQ RabbitMQ高性能的原因 什么是AMQP AMQP核心概念 RabbitMQ整体架构 RabbitMQ消息流转 RabbitMQ常用命令 rabbitmq-server rabbitmqctl 用户相关 virtual host相关 queue相关 高级操作 rabbitmq-plugins 消息生产与消费 重要概念 创建项目 具体代码 运行测试 Exchange–交换机 Exchange属性(交换机属性) Direct Exchange 代码示例 创建项目 具体代码 Topic Exchange 代码示例 创建项目 具体代码 Fanout Exchange 代码示例 创建项目 具体代码 Binding–绑定 Queue–消息队列 Message–消息 Virtual Hots–虚拟主机 源码：https://github.com/xiejiamiao/AllSamples 主流消息中间件衡量MQ指标：服务性能、数据存储、集群架构 ActiveMQ ActiveMQ是Apache出品，最流行的、能力最强劲的开源消息总线，并且它是一个完全支持JMS规范的消息中间件 其丰富的API、多种集群构建模式使得它称为业界老牌消息中间件，在中小型企业中应用广泛 性能比较一般，面对大数量高并发的情况容易出现堵塞、消息堆积过多导致延迟 适合并发量不高的场景 ActiveMQ的集群模式： KafkaKafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量(配置不高的单机服务器也能支撑每秒100K的吞吐数据量)，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务 Kafka集群模式： RocketMQRocketMQ是阿里开源的消息中间件，目前也已经孵化为Apache顶级项目，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，它对消息的可靠传输和事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分布等场景 RocketMQ集群模式： RabbitMQRabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。 RabbitMQ高可用负载均衡集群模式： RabbitMQ核心概念及AMQP协议RabbitMQ是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基于AMQP协议的。 为什么用RabbitMQ 与SpringAMQP完美的整合、API丰富 集群模式丰富，表达式配置，HA模式，镜像队列模型 保证数据不丢失的前提下做到高可靠性、可用性 RabbitMQ高性能的原因Erlang语言最初在于交换机领域的架构模式，这使得RabbitMQ在Broker之间进行数据交互的性能是非常优秀的 Erlang的优点：有着与原生Socket一样的延迟 什么是AMQP AMQP全称：Advance Message Queuing Protocol（高级消息队列协议） AMQP定义：具有现代特征的二进制协议。是一个提供统一消息的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。 AMQP协议模型： AMQP核心概念 Server：又称Broker，接受客户端的连接，实现AMQP实体服务 Connection：连接，应用程序域Broker的网络连接 Channel：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个会话任务 Message：消息，服务器和应用程序之间传送的数据，有Properties和Body组成，Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body则是消息体内容 Virtual host：虚拟主机，用于进行逻辑隔离，最上层的消息路由。一个Virtual host里面可以有若干个Exchange和Queue，同一个Virtual host里面不能有相同名称的Exchange和Queue Exchange：交换机，接受消息，根据路由键转发消息到绑定的队列 Binding：Exchange和Queue之间的虚拟连接，bingding中可以包含routing key Routing key：一个路由规则，虚拟机可用它来确定如何路由一个特定消息 Queue：也成为Message Queue，消息队列，保存消息并将它们转发给消费者 RabbitMQ整体架构 RabbitMQ消息流转 RabbitMQ常用命令rabbitmq-server 启动并后台运行：rabbitmq-server start &amp; 停止服务：rabbitmq-server stoprabbitmqctl 启动应用：rabbitmqctl start_app 停止应用：rabbitmqctl stop_app 节点状态：rabbitmqctl status用户相关 添加用户：rabbitmqctl add_user username password 列出所有用户：rabbitmqctl list_users 删除用户：rabbitmqctl delete_user username 清除用户权限：rabbitmqctl clear_permissions -p vhostpath username 列出用户权限：rabbitmqctl list_user_permissions username 修改密码：rabbitmqctl change_password username newpassword 设置用户权限：rabbitmqctl set_permissions -p vhostpath username &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;virtual host相关 创建虚拟主机：rabbitmqctl add_vhost vhostpath 列出所有虚拟主机：rabbitmqctl list_vhosts 列出虚拟主机上所有权限：rabbitmqctl list_permissions -p vhostpath 删除虚拟主机：rabbitmqctl delete_vhost vhostpathqueue相关 查看所有队列信息：rabbitmqctl list_queues 清楚队列里的消息：rabbitmqctl -p vhostpath purge_queue blue高级操作 移除所有数据：rabbitmqctl reset(要在rabbitmqctl stop_app之后使用) 组成集群命令：rabbitmqctl join_cluster &lt;clusternode&gt; [--ram] 查看集群状态：rabbitmqctl cluster_status 修改集群节点的存储形式：rabbitmqctl change_cluster_node_type disc | ram 忘记节点(摘除节点)：rabbitmqctl forget_cluster_node [--offline] 修改节点名称：rabbitmqctl rename_cluster_node oldnode1 newnode1 [oldnode2] [newnode2...] rabbitmq-plugins 列出当前所有插件：rabbitmq-plugins list 启动控制台：rabbitmq-plugins enable rabbitmq_management 消息生产与消费重要概念 ConnectionFactory：获取连接工厂 Connection：一个连接 Channel：数据通信信道，可发送和接收消息 Queue：具体的消息存储队列 Producer：消息生产者 Consumer：消息消费者 创建项目创建两个控制台应用程序，名字分别为： 12BasicConsumerBasicProducer 在两个项目分别通过nuget引入RabbitMQ.Client 具体代码BasicProducer.Program代码： 123456789101112131415161718192021222324252627282930313233343536using System;using System.Text;using RabbitMQ.Client;namespace BasicProducer&#123; class Program &#123; static void Main(string[] args) &#123; &#x2F;&#x2F; 1.创建一个ConnectionFactory var connectionFactory &#x3D; new ConnectionFactory &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; &#x2F;&#x2F; 2.通过连接工厂创建连接 using (var connection &#x3D; connectionFactory.CreateConnection()) &#123; &#x2F;&#x2F; 3.通过connection创建Channel var channel &#x3D; connection.CreateModel(); &#x2F;&#x2F; 4.通过channel发送数据 var message &#x3D; &quot;Hello RabbitMQ&quot;; var body &#x3D; Encoding.UTF8.GetBytes(message); for (int i &#x3D; 0; i &lt; 5; i++) &#123; channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;test001&quot;, basicProperties: null, body: body); &#125; &#125; Console.WriteLine(&quot;发送完毕&quot;); &#125; &#125;&#125; BasicConsumer.Program代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Text;using RabbitMQ.Client;using RabbitMQ.Client.Events;namespace BasicConsumer&#123; class Program &#123; static void Main(string[] args) &#123; &#x2F;&#x2F; 1.创建一个ConnectionFactory var connectionFactory &#x3D; new ConnectionFactory &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot; &#125;; &#x2F;&#x2F; 2.通过连接工厂创建连接 using (var connection &#x3D; connectionFactory.CreateConnection()) &#123; &#x2F;&#x2F; 3.通过connection创建Channel var channel &#x3D; connection.CreateModel(); &#x2F;&#x2F; 4.声明一个队列 var queue &#x3D; channel.QueueDeclare(queue: &quot;test001&quot;, durable: true, exclusive: false, autoDelete: true, arguments: null); &#x2F;&#x2F; 5.创建消费者 var consumer &#x3D; new EventingBasicConsumer(channel); &#x2F;&#x2F; 6.设置Channel channel.BasicConsume(queue: &quot;test001&quot;, autoAck: true, consumer: consumer); &#x2F;&#x2F; 7.获取消息 consumer.Received +&#x3D; (model, ea) &#x3D;&gt; &#123; var body &#x3D; ea.Body; var message &#x3D; Encoding.UTF8.GetString(body.ToArray()); Console.WriteLine($&quot;接收到消息:&#123;message&#125;&quot;); &#125;; Console.WriteLine(&quot;输入回车键键退出&quot;); Console.ReadLine(); &#125; &#125; &#125;&#125; 运行测试注意：先运行Consumer，再运行Producer，可以看到Consumer端接收到了Producer端发出的5条消息 Exchange–交换机Exchange：接受消息，并根据路由键转发消息所绑定的队列 Exchange属性(交换机属性) Name：交换机名字 Type：交换机类型 direct、topic、fanout、headers Durability：是否需要持久化，true为持久化 Auto Delete：当最后一个绑定到Exchange上的队列删除后，自动删除该Exchange Internal：当前Exchange是否用于RabbitMQ内部使用，默认为false Arguments：扩展参数，用于扩展AMQP协议自制定化使用 Direct Exchange所有发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue 注意：Direct模式可以使用RabbitMQ自带的Exchange:default Exchange，所以不需要将Exchange进行任何绑定(bingding)操作，消息传递时，RouteKey必须完全匹配才会被队列接受，否则该消息会被抛弃 代码示例创建项目创建两个控制台应用程序 12DirectExchange.ConsumerDirectExchange.Producer 再分别通过nuget引入RabbitMQ.Client 具体代码DirectExchange.Producer 12345678910111213141516171819202122232425262728293031323334353637383940using System;using System.Text;using RabbitMQ.Client;namespace DirectExchange.Producer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;**** Direct Exchange Producer Sample ****&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot;, AutomaticRecoveryEnabled &#x3D; true, NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3) &#125;; using (var connection &#x3D; connectionFactory.CreateConnection()) &#123; using (var channel &#x3D; connection.CreateModel()) &#123; var exchangeName &#x3D; &quot;test_direct_exchange&quot;; var routingKey &#x3D; &quot;test.direct&quot;; var message &#x3D; &quot;Hello World RabbitMQ For Direct Exchange&quot;; var body &#x3D; Encoding.UTF8.GetBytes(message); channel.BasicPublish(exchangeName, routingKey, null, body); &#125; &#125; Console.WriteLine(&quot;消息发送完毕&quot;); &#125; &#125;&#125; DirectExchange.Consumer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Text;using RabbitMQ.Client;using RabbitMQ.Client.Events;namespace DirectExchange.Consumer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;**** Direct Exchange Consumer Sample ****&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot;, AutomaticRecoveryEnabled &#x3D; true, NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3) &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;test_direct_exchange&quot;; var queueName &#x3D; &quot;test_direct_queue&quot;; var routingKey &#x3D; &quot;test.direct&quot;; &#x2F;&#x2F; 声明一个交换机 channel.ExchangeDeclare(exchange: exchangeName, type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null); &#x2F;&#x2F; 声明一个队列 channel.QueueDeclare(queue: queueName, durable: true, exclusive: false, autoDelete: false, arguments: null); &#x2F;&#x2F; 建立一个绑定关系 channel.QueueBind(queue:queueName,exchange:exchangeName,routingKey:routingKey); var consumer &#x3D; new EventingBasicConsumer(channel); channel.BasicConsume(queue: queueName, autoAck: true, consumer); consumer.Received +&#x3D; (model, ea) &#x3D;&gt; &#123; var body &#x3D; ea.Body; var message &#x3D; Encoding.UTF8.GetString(body.ToArray()); Console.WriteLine($&quot;接收到消息：&#123;message&#125;&quot;); &#125;; Console.WriteLine(&quot;输入回车键退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; Topic Exchange所有发送到Topic Exchange的消息都会被转发到所有关系RouteKey中指定Topic的Queue上 Exchange将RouteKey和某个Topic进行模糊匹配，此时队列需要绑定一个Topic 注意：可以使用通配符进行模糊匹配 1234符号&quot;#&quot;匹配一个或多个词符号&quot;*&quot;匹配不多不少一个词例如：&quot;log.#&quot; 能够匹配到 &quot;log.info.oa&quot; &quot;log.*&quot; 只能够匹配到 &quot;log.error&quot; 代码示例创建项目创建两个控制台应用程序 12TopicExchange.ConsumerTopicExchange.Producer 再分别通过nuget引入RabbitMQ.Client 具体代码TopicExchange.Producer 1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Text;using RabbitMQ.Client;namespace TopicExchange.Producer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;**** Topic Exchange Producer Sample ****&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot;, AutomaticRecoveryEnabled &#x3D; true, NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3) &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;test_topic_exchange&quot;; var routingKey1 &#x3D; &quot;user.save&quot;; var routingKey2 &#x3D; &quot;user.update&quot;; var routingKey3 &#x3D; &quot;user.delete.abc&quot;; var message &#x3D; &quot;Hello World RabbitMQ For Topic Exchange Message&quot;; var body &#x3D; Encoding.UTF8.GetBytes(message); channel.BasicPublish(exchange: exchangeName, routingKey: routingKey1, basicProperties: null, body); channel.BasicPublish(exchange: exchangeName, routingKey: routingKey2, basicProperties: null, body); channel.BasicPublish(exchange: exchangeName, routingKey: routingKey3, basicProperties: null, body); Console.WriteLine(&quot;消息发送完毕&quot;); &#125; &#125;&#125; TopicExchange.Consumer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Text;using RabbitMQ.Client;using RabbitMQ.Client.Events;namespace TopicExchange.Consumer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;**** Topic Exchange Consumer Sample ****&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot;, AutomaticRecoveryEnabled &#x3D; true, NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3) &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;test_topic_exchange&quot;; var queueName &#x3D; &quot;test_topic_queue&quot;; var routingKey &#x3D; &quot;user.*&quot;; &#x2F;&#x2F; 声明交换机 channel.ExchangeDeclare(exchange: exchangeName, type: ExchangeType.Topic, durable: true, autoDelete: false, arguments: null); &#x2F;&#x2F; 声明队列 channel.QueueDeclare(queue: queueName, durable: false, exclusive: false, autoDelete: false, arguments: null); &#x2F;&#x2F; 建立绑定关系 channel.QueueBind(queue: queueName, exchange: exchangeName, routingKey: routingKey); var consumer &#x3D; new EventingBasicConsumer(channel); channel.BasicConsume(queue: queueName, autoAck: true, consumer: consumer); consumer.Received +&#x3D; (model, ea) &#x3D;&gt; &#123; var body &#x3D; ea.Body; var message &#x3D; Encoding.UTF8.GetString(body.ToArray()); Console.WriteLine($&quot;接收到消息：&#123;message&#125; RoutingKey&#x3D;&#123;ea.RoutingKey&#125;&quot;); &#125;; Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; Fanout Exchange不处理路由键，只需要简单的队列绑定到交换机上，发送到交换机上的消息都会被转发到与该交换机绑定的所有队列上，Fanout交换机转发消息是最快的 代码示例创建项目创建两个控制台应用程序 12FanoutExchange.ConsumerFanoutExchange.Producer 再分别通过nuget引入RabbitMQ.Client 具体代码FanoutExchange.Producer 1234567891011121314151617181920212223242526272829303132333435using System;using System.Text;using RabbitMQ.Client;namespace FanoutExchange.Producer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;**** Fanout Exchange Producer Sample ****&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot;, AutomaticRecoveryEnabled &#x3D; true, NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3) &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;test_fanout_exchange&quot;; var message &#x3D; &quot;Hello World RabbitMQ For Fanout Exchange&quot;; var body &#x3D; Encoding.UTF8.GetBytes(message); channel.BasicPublish(exchange: exchangeName, routingKey: &quot;&quot;, basicProperties: null, body: body); Console.WriteLine(&quot;消息发送完毕&quot;); &#125; &#125;&#125; FanoutExchange.Consumer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Text;using RabbitMQ.Client;using RabbitMQ.Client.Events;namespace FanoutExchange.Consumer&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;**** Fanout Exchange Consumer Sample ****&quot;); var connectionFactory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;127.0.0.1&quot;, Port &#x3D; 5672, UserName &#x3D; &quot;admin&quot;, Password &#x3D; &quot;admin&quot;, VirtualHost &#x3D; &quot;&#x2F;&quot;, AutomaticRecoveryEnabled &#x3D; true, NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3) &#125;; using var connection &#x3D; connectionFactory.CreateConnection(); using var channel &#x3D; connection.CreateModel(); var exchangeName &#x3D; &quot;test_fanout_exchange&quot;; var queueName &#x3D; &quot;test_fanout_queue&quot;; &#x2F;&#x2F; 声明 channel.ExchangeDeclare(exchange: exchangeName, type: ExchangeType.Fanout, durable: true, autoDelete: false, arguments: null); channel.QueueDeclare(queue: queueName, durable: true, exclusive: false, autoDelete: false, arguments: null); channel.QueueBind(queue:queueName,exchange:exchangeName,&quot;&quot;); var consumer &#x3D; new EventingBasicConsumer(channel); channel.BasicConsume(queue: queueName, autoAck: true, consumer); consumer.Received +&#x3D; (model, ea) &#x3D;&gt; &#123; var body &#x3D; ea.Body; var message &#x3D; Encoding.UTF8.GetString(body.ToArray()); Console.WriteLine($&quot;接收到消息：&#123;message&#125;&quot;); &#125;; Console.WriteLine(&quot;输入回车退出...&quot;); Console.ReadLine(); &#125; &#125;&#125; Binding–绑定 Exchange和Exchange、Queue之间的连接关系 Binding中可以包含RoutingKey或参数 Queue–消息队列 消息队列，实际存储消息数据 Durability：是否持久化，Durable：是，Transient：否 Auto Delete：如果是yes，则代表当最后一个监听被移除之后，该queue会被自动删除 Message–消息 服务器和应用程序之间传送的数据 本质上就是一段数据，由Properties和Payload(Body)组成 常用属性：delivery mode、headers（自定义属性） content_type、content_encoding、priority(优先级) correlation_id（消息唯一ID）、reply_to（消息处理失败了返回哪个队列）、expiration（消息过期时间，多久时间没被消费就过期）、message_id timestamp、type、user_id、app_id、cluster_id Virtual Hots–虚拟主机 虚拟地址，用于进行逻辑隔离，最上层的消息路由","categories":[{"name":"消息队列","slug":"消息队列","permalink":"http://www.dimsum.fun/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://www.dimsum.fun/tags/RabbitMQ/"},{"name":"消息队列","slug":"消息队列","permalink":"http://www.dimsum.fun/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}]},{"title":"多线程","slug":"42.MultiThreading","date":"2020-05-25T02:11:00.000Z","updated":"2020-05-27T16:57:02.915Z","comments":true,"path":"2020/05/25/42.MultiThreading/","link":"","permalink":"http://www.dimsum.fun/2020/05/25/42.MultiThreading/","excerpt":"","text":"计算机概念进程程序在服务器运行时，占据的计算资源合计，称之为进程。进程之间不会相互干扰，但是进程间的通信比较困难（分布式）。 线程程序执行的最小单位，相应操作的最小执行流，线程也包含自己的计算资源。线程是属于进程的，一个进程可以有多个线程。 多线程一个进程里面，有多个线程并发执行 C#多线程ThreadThread是一个类，就是一个封装，是.NET对线程对象的抽象封装，通过Thread去完成的操作，最终是通过像操作系统请求得到的执行流 CurrentThread：当前线程–任何操作执行都是线程完成的，即获得运行当前这句话的线程 ManagerThreadId：是.NET平台给Thread起的名字，就是一个int值，尽量不重复 同步单线程方法：按顺序执行，每次调用完成后才能进下一行，是同一个线程运行的 异步多线程方法：发起调用，不等待结果就直接进入下一行(主线程)，动作会由一个新线程来执行(子线程) 特点界面卡顿 同步单线程方法卡界面 —- 主(UI)线程线程忙于计算，所以不能相应 异步多线程不卡界面 —- 计算任务交给子线程，主(UI)线程已经闲置，可以相应别的操作 多线程对于C/S：点击按钮后能不卡死，例如：上传文件界面不卡死 多线程对于B/S：例如：用户注册时同时发邮件/发短信/写日志执行速度 同步单线程方法慢 —- 因为只有一个线程在计算 异步多线程方法快 —- 因为多个线程并发计算 多线程就是用资源换性能 但是两者的速度差不是线性增长，例如1个线程耗时1000毫秒，5个线程不代表能做到耗时200毫秒。说明多线程的协调管理由额外的成本，同时资源也是由上限的 所以：线程并不是越多越好无序性 启动无序：几乎同一时间向操作系统请求线程，因为线程时操作系统资源，CLR只能去申请，具体时什么顺序启动这个无法掌握 执行时间不确定：同个线程同个任务耗时都不一样，更何况多个任务多个线程。这跟操作系统的资源调度策略有关 结束无序：上面的都无序，结束时间怎么可能有序 注意使用多线程时，千万不要通过延时等方式去掌控顺序 多线程控制顺序异步回调死循环IsCompleted等待信号量EndInvoke获得返回值使用各个版本的多线程处理方式Thread示例： 12345678910// Thread的API特别丰富，可以玩的很花哨，但是其实大部分人都玩不好，因为线程资源是操作系统管理的，相应并部灵敏，所以没那么好控制// Thread启动线程是没限制的，一个for循环启动几百万个线程，分分钟搞死服务器ThreadStart threadHandler = () =&gt;&#123; Console.WriteLine($\"Thread Start。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); Thread.Sleep(2000); Console.WriteLine($\"Thread End。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\");&#125;;var thread = new Thread(threadHandler);thread.Start(); ThreadPool示例： 1234567891011// ThreadPool：池化资源管理设计思想，线程是一种资源，以前要用到线程就去申请一个，使用完释放掉。// 这样是一种浪费，池化就是一个容器，容器提前申请一批线程，程序需要使用线程，直接找容器获取，用完再放回容器(通过控制资源的状态)，避免频繁的申请和销毁，容器自己还会根据限制的数量去申请和释放// 好处：1.线程服用，2.可以限制最大线程数量// 缺点：ThreadPool的API太少了，线程等待顺序控制比较弱，影响了实战WaitCallback callback = o =&gt;&#123; Console.WriteLine($\"ThreadPool Start。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); Thread.Sleep(2000); Console.WriteLine($\"ThreadPool End。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\");&#125;;ThreadPool.QueueUserWorkItem(callback); Task示例： 12345678910// Task:多线程最佳实践// 优点：1.Task的线程券是线程池的线程 2.提供了丰富的API，非常适合开发实践Action action = () =&gt;&#123; Console.WriteLine($\"Task Start。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); Thread.Sleep(2000); Console.WriteLine($\"Task End。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\");&#125;;Task task = new Task(action);task.Start(); Parallel示例： 123456789101112131415161718192021// Parallel：并行编程// 可以同时执行多个操作，同时主线程也会参与计算，不会闲置。可以节约一个线程// 可以通过ParallelOptions的MaxDegreeOfParallelism控制最大并发数量Parallel.Invoke(() =&gt; &#123; Console.WriteLine($\"Parallel 1 Start。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); Thread.Sleep(2000); Console.WriteLine($\"Parallel 1 End。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); &#125;, () =&gt; &#123; Console.WriteLine($\"Parallel 2 Start。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); Thread.Sleep(2000); Console.WriteLine($\"Parallel 2 End。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); &#125;, () =&gt; &#123; Console.WriteLine($\"Parallel 3 Start。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); Thread.Sleep(2000); Console.WriteLine($\"Parallel 3 End。。。&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); &#125;); Task比较全面示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void Coding(string dev, string module)&#123; var random = new Random(); var stopWatch = new Stopwatch(); stopWatch.Start(); Console.WriteLine($\"&#123;dev&#125;开发&#123;module&#125;模块 开始.......... ManagedThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); Thread.Sleep(random.Next(1000, 5000)); stopWatch.Stop(); Console.WriteLine($\"&#123;dev&#125;开发&#123;module&#125;模块 完成.......... ManagedThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125; 共耗时&#123;stopWatch.ElapsedMilliseconds&#125;毫秒\");&#125;public void AllJob()&#123; Console.WriteLine(\"谈需求...\"); Console.WriteLine(\"选成员...\"); Console.WriteLine(\"分配模块...\"); List&lt;Task&gt; tasks = new List&lt;Task&gt;(); tasks.Add(Task.Run(() =&gt; Coding(\"张小三\", \"用户管理\"))); tasks.Add(Task.Run(() =&gt; Coding(\"李筱思\", \"商品管理\"))); tasks.Add(Task.Run(() =&gt; Coding(\"王小五\", \"订单管理\"))); tasks.Add(Task.Run(() =&gt; Coding(\"赵小六\", \"售后管理\"))); TaskFactory taskFactory = new TaskFactory(); taskFactory.ContinueWhenAny(tasks.ToArray(), t =&gt; &#123; Console.WriteLine($\"达到里程碑... ManagerThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); &#125;); // 等待全部任务完成后，启动一个新的task来完成后续动作 taskFactory.ContinueWhenAll(tasks.ToArray(), tArray =&gt; &#123; Console.WriteLine($\"项目上线... ManagerThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); Console.WriteLine($\"项目验收... ManagerThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); Console.WriteLine($\"支付费用... ManagerThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); &#125;); /* // 会阻塞当前线程，直到任一任务结束 Task.WaitAny(tasks.ToArray()); Console.WriteLine(\"达到里程碑...\"); // 等待上面所有的多线程都计算完毕 // 会阻塞当前线程，直到全部任务结束 Task.WaitAll(tasks.ToArray()); Console.WriteLine(\"项目上线...\"); Console.WriteLine(\"项目验收...\"); Console.WriteLine(\"支付费用...\"); */&#125; 多线程安全如果一段代码，单线程执行和多线程执行结果不一致，就表明由线程安全问题","categories":[{"name":"C#","slug":"C","permalink":"http://www.dimsum.fun/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://www.dimsum.fun/tags/C/"},{"name":"多线程","slug":"多线程","permalink":"http://www.dimsum.fun/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"T-SQL复习17--触发器","slug":"41.TSqlReview17","date":"2020-05-24T05:24:00.000Z","updated":"2020-05-24T06:11:11.139Z","comments":true,"path":"2020/05/24/41.TSqlReview17/","link":"","permalink":"http://www.dimsum.fun/2020/05/24/41.TSqlReview17/","excerpt":"","text":"概念触发器是数据库服务器中发生事件时自动执行的特种存储过程 类型 DML触发器：当发生数据操作语言，如INSERT、UPDATE或DELETE时，执行的触发器 DDL触发器：当发生数据定义语言，如CREATE、ALTER或DROP时，执行的触发器 登陆触发器：与SQL Server示例建立用户会话时执行的触发器 DML触发器DML触发器有点：DML触发器类似于约束，可以强制实体完整性或域完整性；当约束支持的功能无法满足应用程序的功能要求时，DML触发器非常有用 示例： 1234567891011121314USE SCHOOLGOIF OBJECT_ID('TR_INSERT') IS NOT NULLDROP TRIGGER TR_INSERTGOCREATE TRIGGER TR_INSERTON dbo.STUDENTFOR INSERTASPRINT '插入学生表成功'GO--测试触发INSERT触发器INSERT dbo.STUDENT(NAME,SEX,Age) VALUES('Alice','女',24) 触发器工作原理SQL Server创建了两个专用表：inserted和deleted表，这是两个逻辑表，由系统维护，不允许用户直接对两个表进行修改。他们存放在内存中，不存放在数据库中。这两个表的结构总是与被触发器作用的表的结构相同 inserted表：存放由于INSERT或UPDATE语句的执行而要加到该触发表中去的所有新行。即用于插入或更新表的新行值，在插入或更新表的同时，也将其副本存储inserted表中。因为在inserted表中的行总是与触发表中的新行相同 deleted表：存放由于DELETE或UPDATE语句的执行而要从该触发表中删除的所有行。也就是说，把触发表中要删除或要更新的旧行移到deleted表中。因此deleted表和触发表的行不相同 示例： 1234567891011121314151617-- 当向成绩表插入学生多个课程的成绩时，学生的总分发生相应变化USE SCHOOLGOIF OBJECT_ID('TR_SCORE') IS NOT NULLDROP TRIGGER TR_SCOREGOCREATE TRIGGER TR_SCOREON dbo.SCOREFOR INSERTASBEGIN DECLARE @SCORE INT SELECT @SCORE=SCORE FROM inserted UPDATE dbo.TOTALSCORE SET TOTALSCORE=TOTALSCORE+@SCORE PRINT '学生总成绩修改成功'ENDGO 禁用触发器示例： 12ALTER TABLE dbo.STUDENTDISABLE TRIGGER TR_INSERT 启用触发器示例： 12ALTER TABLE dbo.SCOREENABLE TRIGGER TR_SCORE 删除触发器示例： 1DROP TRIGGER dbo.TR_SCORE","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习16--函数","slug":"40.TSqlReview16","date":"2020-05-24T03:42:00.000Z","updated":"2020-05-24T06:11:11.139Z","comments":true,"path":"2020/05/24/40.TSqlReview16/","link":"","permalink":"http://www.dimsum.fun/2020/05/24/40.TSqlReview16/","excerpt":"","text":"类型 内置函数：SQL Server自带 用户自定义函数：用户自己创建的函数 常用的内置函数日期时间函数 GETDATE() –返回当前日期时间 CURRENT_TIMESTAMP –返回当前日期时间 YEAR() –返回日期中的年 MONTH() –返回日期中的月 DAY() –返回日期中的日 SELECT DATEPART() –返回日期中指定部分的日期，如SELECT DATEPART(QUARTER,GETDATE()) DATEADD –返回给日期添加指定部分的数量后的日期，如SELECT DATEADD(YEAR,2,GETDATE()) DATEDIFF –返回指定两个日期指定部分的差，如SELECT DATEDIFF(YEAR,GETDATE(),’1991-08-22 00:00:00’) 字符串函数 LEFT() –从字符串左边开始返回指定个数的字符串，如:SELECT LEFT(‘张三’,1) RIGHT() –从字符串右边开始返回指定个数的字符串，如:SELECT RIGHT(‘李四’,1) LEN() –返回字符串的个数，如:SELECT LEN(‘王五’) DATALENGTH() –返回字符串的字节数，如:SELECT DATALENGTH(‘赵六’) LTRIM() –返回删除左边的空格的字符串，如:SELECT LTRIM(‘ 深田咏美’) RTRIM() –返回删除右边的空格的字符串，如:SELECT RTRIM(‘波多野结衣 ‘) LOWER() –将大写字符转成小写字符 UPPER() –将小写字符转为大写字符 SUBSTRING() –返回字符串中的一部分字符，如:SELECT SUBSTRING(‘张三李四王五赵六’,2,2) 其他函数 CAST() –将一种数据类型转换为另一种数据类型，如:SELECT CAST(‘2016-12-1’ AS datetime2) CONVERT() –将一种数据类型转换为另一种数据类型，如:SELECT CONVERT(datetime2,’2020-05-06’)示例：1SELECT SUM(CAST(AGE AS BIGINT)) FROM STUDENT ISNULL –使用指定的替换值替换NULL示例：1SELECT ISNULL(ADDRESS,'中国') FROM STUDENT NEWID() –创建uniqueidentifier类型的唯一值，如：SELECT NEWID() ROUND() –返回一个数值，舍入到指定的长度，如:SELECT ROUND(123.1243,2),ROUND(123.566,0,1),ROUND(123.456,-2,1) 用户自定义函数SQL Server用户定义函数时接受参数、执行操作(例如复杂计算)并将操作解雇以值得形式返回得例程。返回值可以是单个标量值或结果集。用户定义函数不能用于执行修改数据库状态操作 使用用户定义函数的优点： 可重复使用 执行速度更快 减少网络流量 函数类型：标量函数：返回单个值表值函数：用户定义表值函数返回TABLE数据类型 标量函数创建示例： 12345678910111213141516171819USE SCHOOLGOIF OBJECT_ID('FN_AGE') IS NOT NULLDROP FUNCTION FN_AGEGOCREATE FUNCTION FN_AGE(@NAME VARCHAR(10)) --定义输入参数及数据类型RETURNS INT --定义返回值数据类型ASBEGIN DECLARE @AGE INT SELECT @AGE=Age FROM dbo.STUDENT WHERE NAME=@NAME IF @AGE IS NULL SET @AGE=0 RETURN @AGE --指定返回值变量ENDGO 调用示例： 1SELECT dbo.FN_AGE('JAME') --必须加上所属架构dbo，否则会提示：不是可以识别的函数名称 表值函数创建1234567891011121314USE SCHOOLGOIF OBJECT_ID('FN_TABLE') IS NOT NULLDROP FUNCTION FN_TABLEGOCREATE FUNCTION FN_TABLE(@ID INT) --定义输入参数及数据类型RETURNS TABLE --返回类型为TABLEASRETURN --直接用RETURN，不能使用BEGIN...END块( --必须使用括号 SELECT NAME,Age FROM dbo.STUDENT WHERE ID=@ID)GO 调用示例： 1SELECT * FROM dbo.FN_TABLE(3)","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习15--事务","slug":"39.TSqlReview15","date":"2020-05-24T02:19:00.000Z","updated":"2020-05-24T06:11:11.138Z","comments":true,"path":"2020/05/24/39.TSqlReview15/","link":"","permalink":"http://www.dimsum.fun/2020/05/24/39.TSqlReview15/","excerpt":"","text":"概念 SQL Server事务 创建提交事务 标记一个事务 回滚事务 在事务内设置保存点 在存储过程中使用事务 概念事务是单个工作单元，如果某一事务成功，则在该事务中进行的所有数据修改均会提交，成为数据库中的永久组成部分，如果该事务遇到错误且必须取消或回滚，则所有数据修改均被清楚 SQL Server事务 自动提交事务：每条单独的语句都是一个事务 显式事务：每个事务均已BEGIN TRANSACTION语句显示开始，已COMMIT或ROLLBACK语句显式结束 隐式事务：在前一个事务完成时新事务隐式启动，但每个事务仍已COMMIT或ROLLBACK语句显式结束 创建提交事务示例： 1234567BEGIN TRANSACTION UP_STU --表示开始一个事务，BEGIN TRANSACTION使@@TRANCOUNT值按1递增--SELECT @@TRANCOUNT --查询@@TRANCOUNTUPDATE dbo.STUDENT SET Age=10 WHERE NAME='Hello'COMMIT TRANSACTION UP_STU --表示提交一个事务，仅当对数据库的操作全部正确时，才可以提交事务。COMMIT TRANSACTION时@@TRANCOUNT值按1递减--SELECT @@TRANCOUNT 标记一个事务示例： 1234BEGIN TRANSACTION UP_STUWITH MARK '修改学生年龄' --使用WITH MARK来标记事务UPDATE dbo.STUDENT SET Age=10 WHERE NAME='Hello'COMMIT TRANSACTION UP_STU 注：标记事务时事务名于事务日志中，在还原数据库时可将数据库还原到标记的事务 回滚事务示例： 123BEGIN TRANSACTION UP_STUUPDATE dbo.STUDENT SET Age=10 WHERE NAME='Hello'ROLLBACK TRANSACTION UP_STU --回滚事务到事务的起点，清除自事务起点所作的所有数据的修改，ROLLBACK TRANSACTION使@@TRANCOUNT值递减到0 在事务内设置保存点示例： 1234567BEGIN TRANSACTION UP_STUUPDATE dbo.STUDENT SET Age=10 WHERE NAME='Hello'SAVE TRANSACTION TRAN_SAVEUPDATE dbo.STUDENT SET Age=12 WHERE NAME='World'ROLLBACK TRANSACTION TRAN_SAVE --回滚到事务的保存点位置，ROLLBACK TRANSACTION savePointName 不影响@@TRANCOUNTUPDATE dbo.STUDENT SET Age=13 WHERE NAME='World'COMMIT TRANSACTION UP_STU 在存储过程中使用事务示例： 12345678910111213141516171819202122232425262728USE SCHOOLGOIF OBJECT_ID('P_STUDENT','P') IS NOT NULLDROP PROCEDURE P_STUDENTGOCREATE PROCEDURE P_STUDENTASBEGIN BEGIN TRY BEGIN TRANSACTION TRAN1 --外层事务 UPDATE STUDENT SET Age=10 WHERE NAME='Hello' BEGIN TRANSACTION SUBTRAN1 --嵌套事务 INSERT INTO STUDENT(NAME,Age,SEX) VALUES('JAME',12,'男') COMMIT TRANSACTION SUBTRAN1 COMMIT TRANSACTION TRAN1 END TRY BEGIN CATCH IF @@TRANCOUNT &gt; 0 --@@TRANCOUNT&gt;0表示在TRY块中的事务没有成功提交，那么就回滚整个外层事务 BEGIN PRINT @@TRANCOUNT SELECT ERROR_LINE(),ERROR_MESSAGE(),ERROR_PROCEDURE() ROLLBACK TRANSACTION TRAN1 END ELSE --ELSE就是@@TRANCOUNT的值为0，说明事务都已经全部提交了 SELECT * FROM dbo.STUDENT END CATCHENDGO","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习14--游标","slug":"38.TSqlReview14","date":"2020-05-23T08:54:00.000Z","updated":"2020-05-23T10:12:55.673Z","comments":true,"path":"2020/05/23/38.TSqlReview14/","link":"","permalink":"http://www.dimsum.fun/2020/05/23/38.TSqlReview14/","excerpt":"","text":"概念 游标类型： 只进 静态/不敏感 动态 键集 使用简单的游标 使用WHILE循环检索游标中的结果集 在存储过程中使用游标 概念SQL Server语句产生完整的结果集，但有时候最好对结果进行逐行处理，打开结果集中的游标，即可对结果集进行逐行处理。游标主要用于存储过程、触发器、批处理中* 游标通过以下方式来拓展结果处理： 允许定位在结果集中的特定行 从结果集的当前位置检索一行或一部分行 支持对结果集中当前位置的行进行数据修改 为由其他用户对显示在结果集中的数据库数据所作的更改提供不同级别的可见性支持 提供脚本、存储过程和触发器中用于访问结果集中的数据的TSQL语句 游标类型：只进只进游标不支持滚动，它只支持游标从头到尾顺序提取。行只在从数据库中提取出来后才检索。对所有由当前用户发出或由其他用户提交、并影响结果集中的行的INSERT、UPDATE、DELETE语句，其效果在这些行从游标中提取时是可见的 静态/不敏感静态游标总是按照打开游标时的原样显示结果集，游标在打开期间，对数据库的INSERT、UPDATE、DELETE影响的行，在游标中都无法反应出来，除非关闭游标重新打开。静态游标在滚动期间很少或根本检测不到变化，但消耗的资源相对很少 动态动态游标与静态游标相对，当游标滚动时，动态游标反应结果集中所做的所有更变，所有用户做的全部INSERT、UPDATE、DELETE语句均通过游标可见 键集由键集驱动的游标由一组唯一标识符(键)控制，这组键称为键集，打开由剪辑驱动的游标时，该游标中各行的成员身份和顺序是固定的 使用简单的游标示例： 12345678910DECLARE CUR_STU CURSOR --定义游标FORSELECT * FROM dbo.STUDENT WHERE SEX='女'GOOPEN CUR_STU --OPEN打开游标，然后通过执行DECLARE CURSOR语句的TSQL填充游标结果集FETCH NEXT FROM CUR_STU --FETCH从游标表检索行，NEXT依次从结果集中第一行返回数据SELECT @@FETCH_STATUS --查看@@FETCH_STATUS的值，游标有数据，则状态值=0，如果游标数据被提取完之后这个状态值为-1CLOSE CUR_STU --CLOSE关闭一个开放的游标，释放当前的结果集，必须对打开的游标使用CLOSE DEALLOCATE CUR_STU --DEALLOCATE删除游标引用 使用WHILE循环检索游标中的结果集示例： 1234567891011121314DECLARE CUR_STU CURSORFORSELECT * FROM dbo.STUDENT WHERE SEX='男'GOOPEN CUR_STUFETCH NEXT FROM CUR_STUWHILE (SELECT @@FETCH_STATUS)=0BEGIN FETCH NEXT FROM CUR_STUENDCLOSE CUR_STUDEALLOCATE CUR_STU 在存储过程中使用游标示例： 1234567891011121314151617181920212223242526272829303132USE SCHOOLGOIF OBJECT_ID('P_UPDATE_STU','P') IS NOT NULLDROP PROCEDURE P_UPDATE_STUGOCREATE PROCEDURE P_UPDATE_STUASBEGIN BEGIN TRY SET NOCOUNT ON --关闭显示受影响行数消息 DECLARE @ID BIGINT --定义两个变量 DECLARE @AGE INT DECLARE STU_CUR CURSOR FOR --定义游标 SELECT STU.ID,stu.AGE FROM dbo.GRADE GR INNER JOIN dbo.STUDENT STU ON GR.STUDENTID=STU.ID OPEN STU_CUR --打开游标 FETCH NEXT FROM STU_CUR INTO @ID,@AGE --获取第一行赋值给两个变量 WHILE @@FETCH_STATUS=0 BEGIN UPDATE dbo.STUDENT SET AGE=@AGE+1 WHERE ID=@ID FETCH NEXT FROM STU_CUR INTO @ID,@AGE END END TRY BEGIN CATCH SELECT ERROR_NUMBER(),ERROR_PROCEDURE(),ERROR_MESSAGE() END CATCH CLOSE STU_CUR DEALLOCATE STU_CUREND","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习13--流程控制语句","slug":"37.TSqlReview13","date":"2020-05-23T08:17:00.000Z","updated":"2020-05-23T10:12:55.672Z","comments":true,"path":"2020/05/23/37.TSqlReview13/","link":"","permalink":"http://www.dimsum.fun/2020/05/23/37.TSqlReview13/","excerpt":"","text":"BEGIN…END IF…ELSE… WHILE 在WHILE中使用BREAK、CONTINUE GOTO 使用GOTO语句实现循环 WAITFOR BEGIN…END可以包含多个TSQL语言，一次性执行多个TSQL语言 IF…ELSE…当IF中的条件满足时，执行IF条件后的TSQL语句，若IF中的条件不满足，则执行ELSE后的TSQL语句 具体语法： 1234IF 布尔表达式TSQLELSE --ELSE子句可选TSQL 注意：IF或ELSE条件只能影响一个TSQL语句，若要在IF或ELSE条件后面执行多个TSQL，则需要用BEGIN...END关键字 示例： 1234IF(SELECT AGE FROM dbo.STUDENT WHERE NAME='YOYOYO')&gt;18PRINT '已成年'ELSEPRINT '未成年' 使用嵌套的IF...ELSE...，示例： 1234567891011DECLARE @age INTSELECT @age=AGE FROM dbo.STUDENT WHERE NAME='YOYOYO'IF @age&gt;=18PRINT '已成年'ELSEBEGIN IF(@age&gt;=12) PRINT '小朋友' ELSE PRINT '小小朋友'END WHILE设置重复执行SQL语句或语句块的条件，指要指定的条件为真，就重复执行语句。可以使用BREAK和CONTINUE关键字在循环内部控制WHILE循环中语句的执行 示例： 12345WHILE (SELECT AGE FROM dbo.STUDENT WHERE NAME='Jame')&lt;18BEGIN UPDATE dbo.STUDENT SET AGE=AGE+1 WHERE NAME='Jame'ENDSELECT * FROM dbo.STUDENT WHERE NAME='Jame' --查询检查结果 在WHILE中使用BREAK、CONTINUE BREAK：退出循环，即推出当前循环，执行出现在END关键字后面的语句 CONTINUE：跳出本次循环，进行循环条件判断 示例： 123456789WHILE (SELECT AGE FROM dbo.STUDENT WHERE NAME='Jame')&lt;30BEGIN UPDATE dbo.STUDENT SET AGE=AGE+1 WHERE NAME='Jame' IF(SELECT AGE FROM dbo.STUDENT WHERE NAME='Jame')&lt;22 CONTINUE ELSE BREAKENDSELECT * FROM dbo.STUDENT WHERE NAME='Jame' GOTO将执行流更改到标签处，GOTO语句和标签可在过程、批处理或语句块中的任意位置使用 示例： 12345678910-- 使用GOTO语句循环出10到20之间的数字DECLARE @N INTSET @N=10LABEL: --标签名称要以冒号结束IF @N&lt;20BEGIN SET @N=@N+1 PRINT @N GOTO LABEL --GOTO指定跳转的标签名称END 使用GOTO语句实现循环示例： 12345678LABEL1:IF(SELECT AGE FROM dbo.STUDENT WHERE NAME='Jame')&lt;25BEGIN UPDATE dbo.STUDENT SET AGE=AGE+1 WHERE NAME='Jame' GOTO LABEL1ENDELSESELECT * FROM dbo.STUDENT WHERE NAME='Jame' WAITFOR控制语句执行的时间 示例： 12345678910BEGINWAITFOR TIME '16:52' --在几点开始执行，不能指定日期SELECT * FROM dbo.STUDENTENDBEGINWAITFOR DELAY '00:00:10' --多长时间后开始，最长为24小时，不能指定日期SELECT * FROM dbo.STUDENTEND","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习12--CASE表达式","slug":"36.TSqlReview12","date":"2020-05-23T07:48:00.000Z","updated":"2020-05-23T10:12:55.672Z","comments":true,"path":"2020/05/23/36.TSqlReview12/","link":"","permalink":"http://www.dimsum.fun/2020/05/23/36.TSqlReview12/","excerpt":"","text":"CASE简单表达式 CASE搜索表达式 在ORDER BY、GROUP BY中使用CASE表达式 在UPDATE中使用CASE表达式 CASE简单表达式CASE简单表达式仅用于同行检查，将第一个表达式与每个WHEN子句中的表达式进行等同行检查，以确定它们是否等效 示例： 123456SELECT NAME,AGE,(CASE SEX WHEN '男' THEN '是' ELSE '否' END) AS 是否男性FROM dbo.STUDENT CASE搜索表达式CASE搜索表达式按照指定顺序对每个WHEN子句的布尔表达式进行计算 示例： 12345678SELECT NAME,SEX,(CASE --注意这里CASE后面没带字段名称 WHEN AGE &gt; '18' THEN '成年' ELSE '未成年'END) AS 是否成年FROM dbo.STUDENT 在ORDER BY、GROUP BY中使用CASE表达式示例： 12345678910111213141516SELECT ( CASE WHEN AGE&gt;18 THEN '已成年' ELSE '未成年' END) AS 是否成年,COUNT(ID) AS 人数FROM dbo.STUDENTGROUP BY ( CASE WHEN AGE&gt;18 THEN '已成年' ELSE '未成年' END)ORDER BY 是否成年 在UPDATE中使用CASE表达式示例： 123456789UPDATE dbo.STUDENT SETAGE=( CASE NAME WHEN 'Hello' THEN 18 WHEN 'world' THEN 11 ELSE AGE end)","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习11--存储过程","slug":"35.TSqlReview11","date":"2020-05-22T09:51:00.000Z","updated":"2020-05-23T10:12:55.672Z","comments":true,"path":"2020/05/22/35.TSqlReview11/","link":"","permalink":"http://www.dimsum.fun/2020/05/22/35.TSqlReview11/","excerpt":"","text":"解析 存储过程的类型 简单的存储过程 创建 执行 修改 删除 执行多步操作的存储过程 带输入参数的存储过程 概念 创建 执行 带通配符的存储过程 创建 执行 带输出参数的存储过程 创建 执行 带表值参数的存储过程 创建 执行 带变量的存储过程 概念 创建 执行 可捕获异常的存储过程 概念 创建 执行 对存储过程加密及重新编译 概念 创建 存储过程的优化 解析存储过程是由一个或多个Transact-SQL语句构成的一个组 存储过程可以： 接受输入参数并以输出参数的格式向调用程序返回多个值 包含用于在数据库中执行操作的编程语句，这包括调用其他存储过程 向调用程序返回状态值，以值明成功或失败(以及失败的原因) 使用存储过程的好处： 减少了服务器/客户端网络流量 更强的安全性 代码的重复使用 更容易维护 改进的性能 存储过程的类型 用户定义的存储过程：由用户自己创建的存储过程 临时存储过程：也是由用户创建的存储过程，存储在tempdb中，名字以#开头，仅在创建该过程的会话中存在，会话结束，临时存储过程即被删除(类似临时表) 系统存储过程：系统存储过程是由SQL Server附带的，系统过程以sp_开头，帮助用户使用、管理数据库 简单的存储过程创建示例： 1234567891011USE SCHOOLGOIF OBJECT_ID('P_STUDENT') IS NOT NULLDROP PROCEDURE P_STUDENTGOCREATE PROCEDURE P_STUDENTASBEGIN SELECT NAME,AGE FROM dbo.STUDENTENDGO 执行示例： 12EXEC dbo.P_STUDENT --EXEC是EXECUTE的简写EXECUTE dbo.P_STUDENT 修改示例： 12345ALTER PROCEDURE P_STUDENTASBEGIN SELECT NAME,AGE,SEX FROM dbo.STUDENT WHERE AGE&gt;13END 删除示例： 1DROP PROCEDURE dbo.P_STUDENT 执行多步操作的存储过程示例： 1234567891011121314USE SCHOOLGOIF OBJECT_ID('P_COURSE02') IS NOT NULLDROP PROCEDURE P_COURSE02GOCREATE PROCEDURE P_COURSE02ASBEGIN INSERT INTO COURSE01 SELECT * FROM dbo.COURSE UPDATE COURSE01 SET NAME='高数' WHERE NAME='.NET CORE' DELETE FROM dbo.COURSE01 WHERE NAME='JAVA' SELECT * FROM dbo.COURSE01ENDGO 带输入参数的存储过程概念 输入参数：调用方将数据值传递给存储过程 输出参数：存储过程将数据值返回给调用方 变量：可以在存储过程内部存储和传递数据值，不能将数据从外部传递到存储过程内部 创建示例： 12345678910111213USE SCHOOLGOIF OBJECT_ID('P_STUDENT') IS NOT NULLDROP PROCEDURE P_STUDENTGOCREATE PROCEDURE P_STUDENT@sex CHAR(2), --注意：定义参数位置在存储过程名称粥，参数要以@符号开始@age INT = 18 --这里是将age参数的默认值设定为18，当参数由默认值的时候，调用方如果没传该参数的值过来，则使用默认值进行执行ASBEGIN SELECT ID,NAME,AGE,SEX FROM dbo.STUDENT WHERE SEX=@sex AND AGE&gt;@age ENDGO 执行示例： 1EXEC dbo.P_STUDENT @sex='女',@age=15 带通配符的存储过程示例： 创建123456789101112USE SCHOOLGOIF OBJECT_ID('P_STUDENT','P') IS NOT NULLDROP PROCEDURE P_STUDENTGOCREATE PROCEDURE P_STUDENT@name NVARCHAR(100) --参数定义方法不变ASBEGIN SELECT NAME,AGE,SEX FROM dbo.STUDENT WHERE NAME LIKE @name --通配符查询得使用LIKEENDGO 执行示例： 1EXEC dbo.P_STUDENT @name = N'王%' 带输出参数的存储过程创建示例： 12345678910111213USE SCHOOLGOIF OBJECT_ID('P_STUDENT','P') IS NOT NULLDROP PROCEDURE P_STUDENTGOCREATE PROCEDURE P_STUDENT@name NVARCHAR(100),@age INT OUTPUT --OUTPUT或OUT都表示为输出参数ASBEGIN SELECT @age=AGE FROM dbo.STUDENT WHERE NAME=@nameENDGO 执行示例： 12345-- 执行带输出参数的存储过程时一定要先使用DECLARE声明参数DECLARE @age INTEXECUTE dbo.P_STUDENT @name = N'李筱思', @age = @age OUTPUTSELECT @age 返回值age 带表值参数的存储过程创建示例： 123456789101112131415161718192021222324USE SCHOOLGO-- 创建表类型IF OBJECT_ID('TYPE01','TT') IS NOT NULLDROP TYPE TYPE01GOCREATE TYPE TYPE01 AS TABLE(NAME NVARCHAR(100) NOT NULL,SEX CHAR(2) NOT NULL,AGE INT NOT NULL)GO-- 创建存储过程IF OBJECT_ID('P_INSERT_STUDENT','P') IS NOT NULLDROP PROCEDURE P_INSERT_STUDENTGOCREATE PROCEDURE P_INSERT_STUDENT@DATA TYPE01 READONLY --定义输入参数类型为上面定义的TYPE01类型ASBEGIN INSERT INTO STUDENT(NAME,SEX,AGE) SELECT NAME,SEX,AGE FROM @DATAENDGO 执行示例： 12345678910111213-- 执行存储类型-- 先定义表类型的变量@MyDataDECLARE @MyData AS TYPE01-- 然后往变量@MyData里添加数据INSERT INTO @MyDataSELECT 'Jame','男',12 UNION ALLSELECT 'Alice','女',23-- 执行存储过程，将上面定义的变量传入存储过程EXEC dbo.P_INSERT_STUDENT @DATA = @MyDataGO-- 查看执行结果SELECT * FROM dbo.STUDENTGO 带变量的存储过程概念变量：变量分局部变量和全局变量 局部变量：用户自定义的变量，作用范围在程序内部，局部变量必须先生命，再使用，名称必须以@开头 全局变量：是SQL系统内部实现定义好的变量，不需要用户参与定义，任何程序均可以随时调用，SQL中共有30多个全局变量，名称都以@@开头，主要用于SQL Server的配置设定值和效能统计数据 声明局部变量：DECLARE 以@开头的变量名 数据类型(长度) 局部变量复制： SET 局部变量名=值 SELECT 局部变量名=字段名 FROM 表名 ORDER BY 字段名，若SELECT返回值有多个，则数据库引擎会分配最后一个值给变量 局部变量的作用域：在DECLARE变量开始至脚本或存储过程结束 创建示例： 1234567891011121314USE SCHOOLGOIF OBJECT_ID('P_STUDENT','P') IS NOT NULLDROP PROCEDURE dbo.P_STUDENTGOCREATE PROCEDURE P_STUDENT@NAME NVARCHAR(100)ASBEGIN DECLARE @AGE INT --注意：参数的定义位置在AS前面，变量的定义位置在AS后面 SELECT @AGE=AGE FROM dbo.STUDENT WHERE NAME=@NAME --通过查询结果给变量复制 SELECT * FROM dbo.STUDENT WHERE AGE=@AGE --使用变量进行查询ENDGO 执行示例： 1EXEC dbo.P_STUDENT @NAME = N'李筱思' 可捕获异常的存储过程概念使用TRY...CATCH结构来捕获并处理异常 在TRY块中的SQL发生异常，则执行CATCH块中的SQL，TRY...CATCH不可用在用户自定义函数中 创建示例： 1234567891011121314151617181920212223USE SCHOOLGOIF OBJECT_ID('P_STUDENT','P') IS NOT NULLDROP PROCEDURE dbo.P_STUDENTGOCREATE PROCEDURE P_STUDENT@ID CHAR(10),@NAME VARCHAR(10),@SEX CHAR(2)ASBEGIN BEGIN TRY INSERT INTO STUDENT(ID,SEX,NAME) --这里模拟个异常 SELECT @ID,@NAME,@SEX END TRY BEGIN CATCH SELECT ERROR_NUMBER() AS ERROR_NUM, ERROR_PROCEDURE() AS ERROR_PROC, ERROR_SEVERITY() AS ERROR_SEVE, ERROR_MESSAGE() AS ERROR_MSG END CATCHENDGO 执行示例： 123EXEC dbo.P_STUDENT @ID = '1', @NAME = '123131', @SEX = '131' 对存储过程加密及重新编译概念使用EXEC sys.sp_helptext 存储过程名字查看存储过程定义 使用WITH ENCRYPTION选项对过程定义进行模糊处理 使用WITH RECOMPILE选项强制重新编译过程： 数据结构进行了重要更改，则重新编译过程会进行更新并针对这些更改优化过程的查询计划，这样可以提高过程的处理性能 对过程引用的基础表添加了过程可能从中受益的新索引，可以强制在下次执行过程时对其重新编译 创建示例： 123456789101112131415USE SCHOOLGOIF OBJECT_ID('P_STUDENT','P') IS NOT NULLDROP PROCEDURE P_STUDENTGOCREATE PROCEDURE P_STUDENT@NAME VARCHAR(10)WITH ENCRYPTION,RECOMPILEASBEGIN DECLARE @AGE INT SELECT @AGE=AGE FROM dbo.STUDENT WHERE NAME=@NAME SELECT * FROM dbo.STUDENT WHERE AGE=@AGEENDGO 存储过程的优化 在存储过程中使用SET NOCOUNT ON/OFF关闭或启用显示受TSQL语句影响的行计数消息：SET NOCOUNT ON有利于提升过程执行效率 当在过程中创建或引用数据库对象时使用架构名称，减少数据库引擎解析对象名称所用的处理时间：就是类似dbo.STUDENT这样的写法，补上前面的dbo，不要直接写STUDENT 避免函数包装在WHERE和JOIN子句中指定的列，这样做会使列具有不确定性并且禁止查询处理器使用索引 避免在返回许多行数据的SELECT语句中使用标量函数。因为标量函数必须应用于每一行，会降低性能 避免使用SELECT *。而是应指定所需的列名称 避免处理或返回过多的数据，尽可能在过程代码中缩小结果的范围 通过使用BEGIN/END TRANSACTION来使用显示事务并且保留尽可能短的事务。更长的事务意味着更长的记录锁定和更高的死锁风险 通过TRY...CATCH...功能进行过程内的错误处理，TRY...CATCH...可以封装整个TSQL语句块 在过程主体中对CREATE TABLE或ALTER TABLE语句引用的所有表列使用DEFAULT关键字，这将禁止将NULL传递到不允许NULL值的列 对于临时表中的每一列使用NULL或NOT NULL 使用UNION ALL运算符来代替UNION或OR运算符，除非存在针对非重复值的特定需要。UNION ALL运算符要求更少的处理开销，因为重复值不从结果集中筛选出来","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习10--索引","slug":"34.TSqlReview10","date":"2020-05-22T08:19:00.000Z","updated":"2020-05-22T11:00:01.085Z","comments":true,"path":"2020/05/22/34.TSqlReview10/","link":"","permalink":"http://www.dimsum.fun/2020/05/22/34.TSqlReview10/","excerpt":"","text":"解析 分类 聚集索引 非聚集索引 唯一索引 查询优化器如何使用索引 创建索引 隐式创建索引 显示创建索引 删除索引 查看SQL Server的查询步骤 在哪些字段创建索引 解析索引就像书中的目录，使你能快速定位到所需的信息，数据库中的索引可以加快检索表或视图中的信息速度。索引包含表或视图中的一列或多列生成的键，这些键存储在一个结构(B树)中，时SQL Server可以快速有效的查找域键值相关联的行 索引类似一个微表，索引中只存储索引所在列的件值，需要查询数据时，若可以用到索引中的列，则首先会在索引表中查询，而不是直接从数据表中查询数据 分类聚集索引聚集索引是指数据表回根据索引表中键值的顺序存储和排序表数据，因为一张表只能按照一个顺序排序，所以一张表只能由一个聚集索引 非聚集索引非聚集索引中的键值只是在逻辑上排序，并不对表中的数据进行排序，因此叫做非聚集索引，一张表可以有多个非聚集索引，当一个表有聚集索引时，非聚集索引时指向聚集索引的指针，也就是说当使用非聚集索引查询数据时，SQL Server先从非聚集索引中查到该键值，再去查该键值对应的聚集索引键值，再从聚集索引中找到需要的数据，如果表中没有聚集索引，那么非聚集索引就是一个行定位符 唯一索引唯一索引指的时不允许该索引键列有两行重复的值，聚集索引和非聚集索引都可以是唯一索引 查询优化器如何使用索引当执行查询时，查询优化器评估可用于检索数据的每个方法，然后选择最有效的方法，可能采用的方法包括扫描表和扫描一个或多个索引(如果有). 扫描表时，查询优化器读取表中的所有行，并提取满足查询条件的行，扫描表会有许多磁盘I/O操作，并占用大量资源 查询优化器使用索引时，搜索索引键列，查找到查询所需行的存储位置，然后从该位置提取匹配行，通常，搜索索引比搜索表要快很多，因为索引与表不同，一般每行包含的列非常少，且行遵循排序顺序 创建索引隐式创建索引创建PRIMARY KEY约束后，会自动创建唯一聚集索引；创建UNIQUE约束后，会自动创建唯一非聚集索引这里不做示例，需要查看示例返回看约束 显示创建索引示例： 12345678910111213-- 创建唯一聚集索引USE SCHOOLGOCREATE UNIQUE CLUSTERED INDEX INDEX_ID --创建唯一聚集索引ON dbo.STUDENT(ID DESC) --指定STUDENT表的ID列GO-- 创建唯一非聚集索引USE SCHOOLGOCREATE UNIQUE NONCLUSTERED INDEX INDEX_NAMEON dbo.STUDENT(NAME DESC)GO 删除索引示例： 1DROP INDEX dbo.STUDENT.[INDEX_NAME] 查看SQL Server的查询步骤查看SQL Server的查询步骤，已经是否选择了哪个索引，帮助用户分析哪些索引被系统引用 示例： 123SET SHOWPLAN_ALL ON --开启显示查询步骤GOSELECT * FROM dbo.STUDENT WHERE ID=2 在哪些字段创建索引 查询经常引用的列可创建聚集索引 频繁更新的列不应该创建聚集索引，可创建非聚集索引 用户GROUP BY和ORDER BY的列 若要创建组合聚集索引，应把最常用的字段放在组合键中靠前的位置 一个表中的索引最好不要超过5个，因为创建索引后，向表中写数据时，SQL Server既要向数据表中写数据，同时也要向创建的索引中写数据，索引越多需要写入越多，因此新建索引时要考虑这个因素","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习09--视图","slug":"33.TSqlReview09","date":"2020-05-22T07:36:00.000Z","updated":"2020-05-22T11:00:01.085Z","comments":true,"path":"2020/05/22/33.TSqlReview09/","link":"","permalink":"http://www.dimsum.fun/2020/05/22/33.TSqlReview09/","excerpt":"","text":"解析 视图的作用 创建视图 修改视图 更新视图数据 使用系统存储过程查看创建视图脚本 加密视图 删除视图 解析视图是一个虚拟表，其内容由查询定义，同表一样，视图包含一系列带有名称的列和行数据，行和列数据来自定义视图的查询所引用的表，并且在引用视图时动态生成 视图的作用 集中用户需要的数据 用作安全机制，数据库管理元只允许用户通过视图查询数据，而不授予用户直接访问视图基础表的权限 提高性能，存储复杂查询 创建视图示例： 123456USE SCHOOLGOCREATE VIEW V_BEST_SCOREASSELECT * FROM dbo.GRADE WHERE SCORE&gt;90GO 修改视图示例： 123456USE SCHOOLGOALTER VIEW dbo.V_BEST_SCOREASSELECT * FROM dbo.GRADE WHERE SCORE&gt;95GO 更新视图数据示例： 1234USE SCHOOLGOUPDATE dbo.V_BEST_SCORE SET SCORE=96GO 注：更新视图数据同时也会更新源表数据 使用系统存储过程查看创建视图脚本示例： 1EXEC sys.sp_helptext 'V_BEST_SCORE' 加密视图使用WITH ENCRYPTION加密视图脚本，WITH CHECK OPTION强制更新视图的数据并且符合创建视图时的筛选条件示例： 123456USE SCHOOLGOALTER VIEW dbo.V_BEST_SCORE WITH ENCRYPTIONASSELECT * FROM dbo.GRADE WHERE SCORE&gt;90WITH CHECK OPTION 加密了视图之后，使用sp_helptext存储过程就无法查看视图脚本了 使用WITH CHECK OPTION表示如果更新视图数据，必须保证更新完数据还在视图里，即参照上面的示例，如果将SCORE更新成91，则可以更新成功，如果将SCORE更新成89，则无法更新成功 删除视图示例： 1DROP VIEW dbo.V_BEST_SCORE","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习08--数据完整性(约束)","slug":"32.TSqlReview08","date":"2020-05-22T03:17:00.000Z","updated":"2020-05-22T11:00:01.084Z","comments":true,"path":"2020/05/22/32.TSqlReview08/","link":"","permalink":"http://www.dimsum.fun/2020/05/22/32.TSqlReview08/","excerpt":"","text":"数据完整性 概念 类型 约束 域完整性类型 DEFAULT约束 为现有表添加DEFAULT约束 创建表时添加DEFAULT约束 CHECK约束 创建表时添加CHECK约束 为现有表添加CHECK约束 删除约束 NULL约束 创建表时指定是否允许为NULL 修改现有表的字段是否允许为NULL 实体完整性类型 primary key约束 创建表时指定主键 给现有的表添加主键 UNIQUE约束 创建表时同时创建UNIQUE约束 给现有的表添加UNIQUE约束 引用完整性类型 FOREIGN KEY约束 总结 数据完整性概念数据完整性是指存储在数据库中数据的准确性和可靠性，它是应防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的 类型 域完整性：域完整性指特定列的项的有效性 实体完整性：要求表中的所有行具有唯一的标识，例如主关键字值 引用完整性：确保量表之间的关系在更新和删除期间保持同步约束使用不同的约束强制数据完整性。约束时重要的数据库对象 域完整性类型DEFAULT约束指定列的默认值 为现有表添加DEFAULT约束示例： 1234567USE SCHOOLGOALTER TABLE dbo.STUDENTADD CONSTRAINT DEF_SEX --添加的约束名称DEFAULT '男' --约束类型及约束的值FOR SEX --添加约束的列GO 创建表时添加DEFAULT约束示例： 12345678USE SCHOOLGOCREATE TABLE TEMP_DEFAULT(Id INT NOT NULL,JOB NVARCHAR(100) DEFAULT '.NET CORE DEV' NOT NULL)GO 注：每一列只能有一个DEFAULT约束，不能用于IDENTITY属性的列，若默认值长度大于该字段允许的字符空间，则插入到该列的值会被截断 CHECK约束限制列可接受的值，控制列值的范围，检车列值 CHECK约束默认检查现有数据和所有新数据，使用WITH NOCHECK中检查新数据 创建表时添加CHECK约束示例： 12345678USE SCHOOLGOCREATE TABLE TEMP_CHECK(ID INT NOT NULL,JOB NVARCHAR(100) CHECK(JOB='JAVA' OR JOB='C#') NOT NULL)GO 为现有表添加CHECK约束示例： 123456USE SCHOOLGOALTER TABLE dbo.STUDENT --[WITH NOCHECK] 添加WITH NOCHECK则指检查新数据，不检查表里原有数据ADD CONSTRAINT CHECK_AGE --指定约束名称CHECK(AGE&gt;=0 AND AGE&lt;=150) --指定约束访范围GO 删除约束示例： 12345USE SCHOOLGOALTER TABLE dbo.STUDENTDROP CONSTRAINT CHECK_AGE --约束名称GO NULL约束指定列是否允许NULL，空值(或NULL)不同于0、空白或长度为0的字符串(如””)。NULL的意思是没有输入 创建表时指定是否允许为NULL示例： 12345678USE SCHOOLGOCREATE TABLE TEMP_NULL(ID INT NOT NULL,NAME NVARCHAR(100) NULL)GO 修改现有表的字段是否允许为NULL示例： 12345USE SCHOOLGOALTER TABLE dbo.STUDENTALTER COLUMN ID INT NOT NULL --NOT NULL修改为NULL则标识允许为NULLGO 实体完整性类型primary key约束能唯一标识表中每一行的值的一列或一组列，这样的一列或多列称为表的主键。一个表只能有一个primary key约束，并且primary key约束中的列不允许空值，不允许重复。如果对多列定义了primary key约束，则一列中的值可能会重复，但来自primary key约束定义中所有列的任何值组合必须唯一。 创建表时指定主键示例： 12345678USE SCHOOLGOCREATE TABLE TEMP_PK(ID BIGINT PRIMARY KEY(ID),NAME NVARCHAR(100) NOT NULL)GO 给现有的表添加主键示例： 123456USE SCHOOLGOALTER TABLE dbo.STUDENTADD CONSTRAINT PK_ID --约束名称PRIMARY KEY(ID) --指定主键列GO UNIQUE约束确保在非主键列中不输入重复的值，可以对一个表定义多个UNIQUE约束，但只能定义一个PRIMARY KEY约束，UNIQUE约束允许一个NULL值，而PARMARY KEY约束不允许有NULL值 创建UNIQUE约束时，同时会创建一个同名的非聚集索引，当插入或修改数据时，UNIQUE约束自动执行校验数据 创建表时同时创建UNIQUE约束示例： 12345678USE SCHOOLGOCREATE TABLE TEMP_UNIUQE(ID INT NOT NULL,NAME NVARCHAR(20) CONSTRAINT UNIQUE_NAME UNIQUE(NAME) NULL)GO 给现有的表添加UNIQUE约束示例： 123456USE SCHOOLGOALTER TABLE dbo.STUDENTADD CONSTRAINT UNIQUE_NAMEUNIQUE(NAME)GO 引用完整性类型FOREIGN KEY约束用于建立和加强两个表数据之间的链接，可以是一列或多列，称为表的外键(FK)，一个表可以有多个FOREIGN KEY约束，选作外键必须与其他对应的主键列具有相同的数据类型，每个键中列的数必须相等，即如果主键是一列，则外键是一列，如果主键是多列，则外键对应也是多列。FOREIGN KEY约束不仅可以与另一个表的PRIMARY KEY约束相关联，还可以定义为引用另一个表的UNIQUE约束列 主键要先创建好才能创建外键，FOREIGN KEY约束不能自动创建索引 外键约束的主要目的时控制可以存储在外键表中的数据，同时它也可以控制对主键表中数据的更改 示例： 1234567USE SCHOOLGOALTER TABLE dbo.GRADEADD CONSTRAINT FK_STUDENT_ID --外键约束名称FOREIGN KEY(STUDENTID) --指定当前表哪一列是外键REFERENCES dbo.STUDENT(ID) --这个外键对应的是哪个表的主键GO 总结 DEFAULT、CHECK、NULL约束是针对表中的列进行完整性的控制，因此叫做域完整性 PRIMARY KEY、UNIQUE约束是针对行限制数据行的唯一性，因此叫做实体完整性 FOREIGN KEY约束是针对表与表之间的关系控制数据完整性，因此叫参照完整性","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习07--表或字段添加描述信息","slug":"31.TSqlReview07","date":"2020-05-21T10:15:00.000Z","updated":"2020-05-22T11:00:01.083Z","comments":true,"path":"2020/05/21/31.TSqlReview07/","link":"","permalink":"http://www.dimsum.fun/2020/05/21/31.TSqlReview07/","excerpt":"","text":"添加/更新/删除表级别的描述信息示例： 123456789EXEC sys.sp_addextendedproperty --添加表描述信息 -- sys.sp_updateextendedproperty 更新表属性信息 -- sp_dropextendedproperty 删除表属性信息 @name = N'Student', -- 描述的名称，可以设定为表名 @value = N'学生表', -- 描述内容 @level0type = N'SCHEMA', -- 固定语法 @level0name = N'dbo', -- 架构 @level1type = N'TABLE', -- 类型 @level1name = N'STUDENT' -- 要添加描述的表名 添加/更新/删除字段描述信息示例： 1234567891011EXEC sys.sp_addextendedproperty --添加字段描述信息 -- sys.sp_updateextendedproperty 更新字段属性信息 -- sp_dropextendedproperty 删除字段属性信息 @name = N'ID', -- 描述的名称，可以设定为字段名称 @value = N'学生编号', -- 描述内容 @level0type = N'SCHEMA', -- 固定语法 @level0name = N'dbo', -- 架构 @level1type = N'TABLE', -- 类型 @level1name = N'STUDENT', -- 表名 @level2type = N'COLUMN', -- 列 @level2name = N'ID' -- 要添加描述的字段名 查询表中的描述信息示例： 1SELECT * FROM sys.extended_properties a WHERE a.major_id=OBJECT_ID('[dbo].[STUDENT]')","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习06--高级查询","slug":"30.TSqlReview06","date":"2020-05-21T02:15:00.000Z","updated":"2020-05-21T10:08:32.474Z","comments":true,"path":"2020/05/21/30.TSqlReview06/","link":"","permalink":"http://www.dimsum.fun/2020/05/21/30.TSqlReview06/","excerpt":"","text":"UNION(ALL) 联接查询 联接查询需要满足的条件 连接查询分类 INNER JOIN内连接 外连接(LEFT/RIGHT/FULL JOIN) 左外连接 右外连接 全外连接 交叉连接(很少用) 聚合函数 SUM SUM(ALL|DISTINCT 列名) SUM(列名) OVER(PARTITION BY 列名 ORDER BY 列名) AVG AVG(ALL|DISTINCT 列名) AVG(列名) OVER(PARTITION BY 列名 ORDER BY 列名) COUNT COUNT(ALL|DISTINCT 列名) COUNT(列名) OVER(PARTITION BY 列名 ORDER BY 列名) COUNT(*)返回表中的行数，包括空值和重复项 MIN MIN(列名) MIN(列名) OVER(PARTITION BY 列名 ORDER BY 列名) MAX MAX(列名) MAX(列名) OVER(PARTITION BY 列名 ORDER BY 列名) GROUP BY HAVING WHERE和HAVING区别 ROLLUP、CUBE 子查询 使用IN或NOT IN的子查询 使用ANY、SOME或ALL的子查询 使用EXISTS或NOT EXISTS的子查询 在UPDATE、DELETE和INSERT中使用子查询 使用嵌套查询返回特定排名的数据 不用聚合函数求最大值 UNION(ALL)将两个或更多个查询结果合并为单个结果集，该结果集包含联合查询中的所有查询的全部行 使用UNION合并两个查询结果集的基本准则： 所有查询中的列数和列的顺序必须相同 数据类型必须兼容 ALL将全部行并入结果中，其中包括重复行。如果没有ALL则删除重复行 示例： 1234567891011-- 使用UNION合并两个学生表的学生信息NAME,SEX,AGE FROM dbo.STUDENTUNION (ALL)SELECT ID,NAME,SEX,AGE FROM dbo.STUDENT02-- 将SELECT INTO与UNION一起使用SELECT NAME,AGE,SEX INTO STUDENT_UNION FROM STUDENT UNION ALL SELECT NAME,AGE,SEX FROM dbo.STUDENT02 联接查询根据数据库表之间的逻辑关系，从两个或多个数据库表中检索数据 联接查询需要满足的条件所要连接的表必须拥有相同的字段值，且数据类型类似。尽量在表的主键上的基础上，指定连接条件 连接查询分类 内部链接：基本内连接，多表连接 外部连接：左外连接，右外连接，全外连接 交叉连接 INNER JOIN内连接只返回两个表中连接字段相等的行，用...INNER JOIN...ON...语句进行连接，JOIN指定需要连接的数据表，ON指定连接条件(INNER可省略) 基本语法： 1234567SELECT 字段1,字段2,...FROM 表1INNER JOIN 表2 ON 关联条件INNER JOIN 表3 ON 关联条件...WHERE 筛选条件GO 示例： 1234567-- 查询学生信息及成绩SELECT ST.NAME,ST.SEX,GR.SCORE FROM dbo.STUDENT ST INNER JOIN dbo.GRADE GR ON ST.ID=GR.STUDENTID-- 查询学生信息、成绩及课程名称SELECT ST.NAME,ST.SEX,CO.NAME,GR.SCORE FROM dbo.STUDENT ST INNER JOIN dbo.GRADE GR ON ST.ID=GR.STUDENTIDINNER JOIN dbo.COURSE CO ON GR.COURSEID=CO.ID 外连接(LEFT/RIGHT/FULL JOIN)基本语法： 1234567USE 数据库名SELECT 字段1,字段2,...FROM 表1 LEFT OUTER JOIN 表2 --左外连接 OUTER通常省略 RIGHT OUTER JOIN 表2 --右外连接 OUTER通常省略 FULL OUTER JOIN 表2 --全连接 OUTER通常省略ON 表1.字段=表2.字段GO 左外连接LEFT OUTER JOIN以左表为基表，结果集返回左表的所有行，而右表只返回符合连接条件的记录，右表中不足的地方显示为NULL 示例： 12-- 查询所有学生信息及参加考试的学生成绩SELECT ST.NAME,ST.SEX,ST.AGE,GR.SCORE FROM dbo.STUDENT ST LEFT OUTER JOIN dbo.GRADE GR ON ST.ID=GR.STUDENTID 右外连接RIGHT OUTER JOIN以右表为基表，结果集返回右表的所有行，而左表只返回符合连接条件的记录，左表中不足的地方显示为NULL 示例： 12-- 安徽查询所有课程信息及参加该考试的学生成绩SELECT CO.ID,CO.NAME,GR.SCORE FROM dbo.GRADE GR RIGHT OUTER JOIN dbo.COURSE CO ON GR.COURSEID=CO.ID 全外连接FULL OUTER JOIN结果集返回左表和右表的所有行 示例： 12-- 查找素有的学生信息及所有参加该考试的学生成绩SELECT ST.NAME,ST.SEX,ST.AGE,GR.SCORE FROM dbo.STUDENT ST FULL OUTER JOIN dbo.GRADE GR ON ST.ID=GR.STUDENTID 交叉连接(很少用)CROSS JOIN将从被连接的表中返回所有可能的记录组合(如：一个表8条记录，另一个表9条记录，结果将返回72条记录)，交叉连接的结果集是量表行数乘积的集合，也被称为笛卡尔积 基本语法： 1234USE 数据库名SELECT 表1.字段,表2.字段,...FROM 表1 CROSS JOIN 表2GO 注：交叉连接不需要使用ON连接条件 示例： 1SELECT ST.NAME,ST.AGE,ST.SEX,GR.SCORE FROM dbo.STUDENT ST CROSS JOIN dbo.GRADE GR 聚合函数 SUM()：计算表达式中所有值得和，忽略空值，这些表达式通常是字段名或包含字段名的表达式 AVG()：计算表达式的平均值，忽略空值，这些表达式通常是字段名或包含字段名的表达式 COUNT(列名)：计算表达式中非空值的数量，即忽略空值 COUNT(*)：计算表达式中所有值的数量，包括空值 MIN()：返回表达式中所有值的最小值，这些表达式通常是字段名或包含字段名的表达式 MAX()：返回表达式中所有值的最大值，这些表达式通常是字段名或包含字段名的表达式 SUM示例： 1SELECT SUM(SCORE) FROM dbo.GRADE SUM(ALL|DISTINCT 列名)返回表达式中所有值的和或仅非重复值的和。SUM只能用于数字列，将忽略NULL值。 ALL表示所有值求和，默认是ALL DISTINCT表示对唯一值求和 SUM(列名) OVER(PARTITION BY 列名 ORDER BY 列名)在SUM后面使用OVER子句可对表数据分区再求和，PARTITION BY指定分区列，ORDER BY指定在分区内按照某列的排序顺序在求和 示例： 12345678-- 对课程ID分区后对学生分数求和SELECT STUDENTID,COURSEID,SCORE,SUM(SCORE) OVER(PARTITION BY COURSEID) AS SUM_PAR FROM dbo.GRADE-- 按照学生编号排序对学生分数求和SELECT STUDENTID,COURSEID,SCORE,SUM(SCORE) OVER(ORDER BY STUDENTID) SUM_ORDER FROM dbo.GRADE ORDER BY STUDENTID-- 对课程分区并按照学生编号排序后对学生分数求和SELECT STUDENTID,COURSEID,SCORE,SUM(SCORE) OVER(PARTITION BY COURSEID ORDER BY STUDENTID) SUM_PAR_ORDER FROM dbo.GRADE AVG示例： 1SELECT AVG(SCORE) FROM dbo.GRADE AVG(ALL|DISTINCT 列名)返回组中各值得平均值，空值将被忽略，后面可以跟随OVER子句 ALL表示对所有值求平均值，默认是ALL DISTINCT表示对唯一值求平均值 AVG(列名) OVER(PARTITION BY 列名 ORDER BY 列名)在AVG使用OVER子句可对表数据分区再求平均值，PARTITION BY指定分区列，ORDER BY指定在分区内按照某列排序再求平均值 示例： 12345678-- 对课程ID分区后对学生分数求平均值SELECT STUDENTID,COURSEID,SCORE,AVG(SCORE) OVER(PARTITION BY COURSEID) AVG_PAR FROM dbo.GRADE-- 按照学生编号排序对学生分数求平均值SELECT STUDENTID,COURSEID,SCORE,AVG(SCORE) OVER(ORDER BY STUDENTID) AVG_ORDER FROM dbo.GRADE-- 对课程分区并按照学生编号排序后对学生分数求平均值SELECT STUDENTID,COURSEID,SCORE,AVG(SCORE) OVER(PARTITION BY COURSEID ORDER BY STUDENTID) AVG_PAR_ORDER FROM dbo.GRADE COUNT示例： 1SELECT COUNT(NAME) FROM dbo.STUDENT COUNT(ALL|DISTINCT 列名)返回组中的项数，不包含空值 ALL对所有值计数，不包括空值，默认是ALL DISTINCT计算唯一非空值数量 COUNT(列名) OVER(PARTITION BY 列名 ORDER BY 列名)在COUNT后使用OVER子句可对表数据分区后计数，PARTITION BY指定分区列，ORDER BY指定在分区内按照某列排序再计数 示例： 123SELECT NAME,SEX,AGE,COUNT(NAME) OVER(PARTITION BY SEX) COUNT_PAR FROM dbo.STUDENTSELECT NAME,SEX,AGE,COUNT(NAME) OVER(ORDER BY AGE) COUNT_ORDER FROM dbo.STUDENTSELECT NAME,SEX,AGE,COUNT(NAME) OVER(PARTITION BY SEX ORDER BY AGE) FROM dbo.STUDENT COUNT(*)返回表中的行数，包括空值和重复项12SELECT COUNT(*) FROM dbo.STUDENTSELECT COUNT(1) FROM dbo.STUDENT MIN1SELECT MIN(AGE) FROM dbo.STUDENT MIN(列名)返回族中最小的值，忽略空值 MIN(列名) OVER(PARTITION BY 列名 ORDER BY 列名)在MIN后使用OVER子句可对表数据分区后求最小值，PARTITION BY指定分区列，ORDER BY指定在分区内按照某列排序在求最小值 示例： 123SELECT NAME,SEX,AGE,MIN(AGE) OVER(PARTITION BY SEX) MIN_PAR FROM dbo.STUDENTSELECT NAME,SEX,AGE,MIN(AGE) OVER(ORDER BY AGE) MIN_ORDER FROM dbo.STUDENTSELECT NAME,SEX,AGE,MIN(AGE) OVER(PARTITION BY SEX ORDER BY AGE) MIN_PAR_ORDER FROM dbo.STUDENT MAX1SELECT MAX(AGE) FROM dbo.STUDENT MAX(列名)返回族中最大的值，忽略空值 MAX(列名) OVER(PARTITION BY 列名 ORDER BY 列名)在MAX后使用OVER子句可对表数据分区后求最大值，PARTITION BY指定分区列，ORDER BY指定在分区内按照某列排序在求最小值 示例： 123SELECT NAME,SEX,AGE,MAX(AGE) OVER(PARTITION BY SEX) MAX_PAR FROM dbo.STUDENTSELECT NAME,SEX,AGE,MAX(AGE) OVER(ORDER BY AGE) MAX_ORDER FROM dbo.STUDENTSELECT NAME,SEX,AGE,MAX(AGE) OVER(PARTITION BY SEX ORDER BY AGE) MAX_PAR_ORDER FROM dbo.STUDENT GROUP BYGROUP BY：对结果集分组，针对每一组返回一行 若SELECT子句中同时包含聚合函数和GROUP BY，则聚合函数对每个组聚合计算 若指定GROUP BT时，GROUP BY后的所有字段都要出现在SELECT列表中 GROUP BY后不能使用数据类型为text、ntext、image的字段 示例： 12345-- 简单GROUP BY示例SELECT SEX FROM dbo.STUDENT GROUP BY SEX-- 聚合函数中使用GROUP BYSELECT SEX,AVG(AGE) 平均年龄 FROM dbo.STUDENT GROUP BY SEX ORDER BY 平均年龄 HAVING使用HAVING过滤分组后的数据，因此HAVING要用在GROUP BY之后 示例： 12345-- 按照性别分区，求学生平均年龄SELECT SEX,AVG(AGE) 平均年龄 FROM dbo.STUDENT GROUP BY SEX-- 按照性别分区，求学生平均年龄大于12岁的学生性别SELECT SEX,AVG(AGE) 平均年龄 FROM dbo.STUDENT GROUP BY SEX HAVING AVG(AGE)&gt;12 WHERE和HAVING区别 WHERE语句在GROUP BY语句之前，SQL会在分组之前计算WHERE语句 HAVING语句在GROUP BY语句之后，SQL会在分组之后计算HAVING语句 在一个SQL语句中可以同时有WHERE子句和HAVING子句，HAVING与WHERE子句类似，均用于设置限定条件 WHERE子句的作用时在对查询结果进行分组前，将不符合WHERE条件的行去掉，即在分组之前过滤数据，条件中不能包含聚合函数，使用WHERE条件显示特定的行 HAVING子句的作用时筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚合函数，使用HAVING条件显示特定的组，也可以使用多个分组标准进行分组 示例： 12-- 查询年龄大于11岁各性别学生平均年龄大于13岁的学生信息SELECT SEX,AVG(AGE) 平均年龄 FROM dbo.STUDENT WHERE AGE&gt;11 GROUP BY SEX HAVING AVG(AGE)&gt;13 ROLLUP、CUBE在GROUP BY后使用ROLLUP、CUBE子句对分组数据汇总 ROLLUP就是将GROUP BY后面的第一个字段的各个值分组在聚合运算，而其他列并不要求，其中ROLLUP包含仅使用GROUP BY的结果集 而CUBE则会将GROUP BY后面的每一个字段的各个值分组在聚合运算，其中CUBE结果集包含ROLLUP结果集 注：ROLLUP、CUBE在后续SQL SERVER版中将删除 示例： 12SELECT SEX,NAME,AVG(AGE) FROM dbo.STUDENT GROUP BY SEX,NAME WITH ROLLUP ORDER BY SEX,NAMESELECT SEX,NAME,AVG(AGE) FROM dbo.STUDENT GROUP BY SEX,NAME WITH CUBE ORDER BY SEX,NAME 子查询在WHERE子句中包含的SELECT查询，就成为子查询或嵌套查询。而包含子查询的语句称为外部查询或外部选择。子查询可以嵌套在外部SELECT、INSERT、UPDATE或DELETE语句的WHERE或HAVING子句内，也可以嵌套在其他子查询内。 子查询类型： 使用IN或NOT IN的子查询(用的比较多) 使用ANY、SOME或ALL的子查询 使用EXISTS或NOT EXISTS的子查询(用的比较多) 注：子查询通常用()括起来 使用IN或NOT IN的子查询示例： 12345678-- 使用IN的子查询SELECT NAME,SEX,AGE FROM dbo.STUDENT WHERE ID IN (SELECT STUDENTID FROM dbo.GRADE WHERE COURSEID='k01' AND SCORE&gt;60)-- 使用NOT IN的子查询SELECT NAME,SEX,AGE FROM dbo.STUDENT WHERE ID NOT IN (SELECT STUDENTID FROM dbo.GRADE WHERE COURSEID='k01' AND SCORE&gt;60)-- 使用联接查询SELECT ST.NAME,ST.SEX,ST.AGE FROM dbo.STUDENT ST INNER JOIN dbo.GRADE GR ON ST.ID=GR.STUDENTID WHERE GR.COURSEID='k01' AND GR.SCORE&gt;60 联接总是可以表示为子查询，子查询经常(但不总是)可以表示为联接。这是因为联接时对称的，无论以何种顺序联接表A或B，都将得到相同的结果 使用联接而不是用子查询的一个同之处在于，联接使您可以在结果中显示多个表中的列 使用ANY、SOME或ALL的子查询如果子查询的返回值不止一个，而是一个集合时，则不能直接使用比较运算符，可以在比较运算符和子查询之间插入ANY或ALL。ANY与SOME完全等效 ANY任一个： &gt;ANY：表示至少大于一个值，即大于最小值。因此&gt;ANY(1,2,3)表示大于1 &lt;ANY：表示至少小于一个值，即小于最大值。因此&lt;ANY(1,2,3)表示小于3 =ANY：表示至少等于一个值，因此=ANY(1,2,3)表示等于1或等于2或等于3，=ANY等效于IN ALL所有： &gt;ALL：表示大于每一个值，即大于最大值。因此&gt;ALL(1,2,3)表示大于3 &lt;ALL：表示小于每一个值，即小于最小值。因此&lt;ALL(1,2,3)表示小于1 示例： 12345-- 使用ANY的子查询SELECT * FROM dbo.STUDENT WHERE ID&gt;ANY(SELECT STUDENTID FROM dbo.GRADE WHERE SCORE&gt;80)-- 使用ALL的子查询SELECT * FROM dbo.STUDENT WHERE ID&gt;ALL(SELECT STUDENTID FROM dbo.GRADE WHERE SCORE&gt;80) 使用EXISTS或NOT EXISTS的子查询使用EXISTS的子查询，只进行存在测试，外部查询的WHERE子句测试子查询返回的行是否存在，子查询实际上不产生任何数据，它时返回TRUE或FALSE值 使用EXISTS引入的子查询的语法： 1WHERE [NOT] EXISTS (subquery) EXISTS关键字前面没有列名、常量或其他表达式 由EXISTS引入的子查询的选择列通常几乎都是由星号(*)组成，由于这是测试是否存在符合子查询指定条件的行，因此不必列出列名 示例： 12345678-- 使用EXISTS的子查询SELECT * FROM dbo.STUDENT WHERE [NOT] EXISTS (SELECT * FROM dbo.GRADE WHERE dbo.STUDENT.ID=dbo.GRADE.STUDENTID AND COURSEID='k02')-- 使用IN替换的子查询SELECT * FROM dbo.STUDENT WHERE ID IN (SELECT STUDENTID FROM dbo.GRADE WHERE COURSEID='k01')-- 使用联接查询替换SELECT ST.* FROM dbo.STUDENT ST INNER JOIN dbo.GRADE GR ON ST.ID=GR.STUDENTID WHERE GR.COURSEID='k01' 在UPDATE、DELETE和INSERT中使用子查询示例： 1234567891011-- 在DELETE语句中使用NOT IN子查询DELETE FROM dbo.GRADE WHERE STUDENTID NOT IN (SELECT ID FROM dbo.STUDENT)-- 在DELETE语句中使用NOT EXISTS子查询DELETE FROM dbo.GRADE WHERE NOT EXISTS(SELECT * FROM dbo.STUDENT WHERE STUDENTID=dbo.GRADE.STUDENTID)-- 在UPDATE语句中使用IN子查询UPDATE dbo.GRADE SET SCORE=SCORE+5 WHERE STUDENTID IN (SELECT ID FROM dbo.STUDENT WHERE SEX='女')-- 使用联接的等效UPDATE语句UPDATE dbo.GRADE SET SCORE=SCORE+5 FROM dbo.GRADE INNER JOIN dbo.STUDENT ON dbo.GRADE.STUDENTID=dbo.STUDENT.ID WHERE dbo.STUDENT.SEX='女' 使用嵌套查询返回特定排名的数据示例： 12-- 查询成绩表中排名名词在中间的信息和成绩SELECT * FROM (SELECT ROW_NUMBER() OVER(ORDER BY SCORE) 排名,* FROM dbo.GRADE WHERE COURSEID='k01') A INNER JOIN dbo.STUDENT B ON A.STUDENTID=B.ID WHERE A.排名=4 不用聚合函数求最大值示例： 12345678-- 使用聚合函数求学生最大年龄SELECT MAX(AGE) FROM dbo.STUDENT-- 不适用聚合函数求学生最大年龄SELECT * FROM dbo.STUDENT A WHERE A.AGE NOT IN (SELECT B.AGE FROM dbo.STUDENT B INNER JOIN dbo.STUDENT c ON B.AGE&lt;C.AGE)","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习05--基础查询","slug":"29.TSqlReview05","date":"2020-05-20T06:49:00.000Z","updated":"2020-05-21T10:08:32.473Z","comments":true,"path":"2020/05/20/29.TSqlReview05/","link":"","permalink":"http://www.dimsum.fun/2020/05/20/29.TSqlReview05/","excerpt":"","text":"SELECT语句语法 查询执行顺序 使用SELECT…WHERE查询数据 使用通配符*查询所有列 查询指定的列 使用as给列或表指定别名 where使用 模糊查询 OR/AND逻辑运算 BETWEEN…AND IN IS NULL ORDER BY 排名函数RANK 排名函数ROW_NUMBER 过滤重复数据 判断对象(表/存储过程/视图等)是否存在 判断表是否存在方式1 判断表是否存在方式2 SELECT…INTO INSERT…SELECT MERGE..INTO TOP 使用TOP限制删除的行数 使用TOP限制更新的行数 使用TOP限制插入行数 SELECT语句语法基本语法： 123456select 选择列表(查询所显示的内容)from 表名(查询内容所在的表)where 查询条件(查询内容的条件)group by 条件(分组汇总的条件)having 条件(筛选条件)order by 列名(排序基准) 解析： 选择列表：可以包括几个列名或者表达式，用逗号隔开，用于指示应该返回哪些数据 from子句包含提供数据的表或视图名称 where子句用于给出查询条件 聚合函数对数据进行汇总计算，使用having进行筛选 order by子句决定结果集的排列顺序 查询执行顺序 FROM：查询首先回根据select语句的from子句组装初始数据集 WHERE：筛选阶段实际上是根据where子句进行筛选 聚合：SQL语句对数据集执行聚合运算 ORDER BY：根据from子句和where子句筛选出满足条件的行后，按照order by子句指定方式排序 谓词：可以只显示前几行或只返回指定行 使用SELECT…WHERE查询数据使用通配符*查询所有列示例： 1SELECT * FROM dbo.STUDENT 查询指定的列示例： 1SELECT NAME,AGE FROM dbo.STUDENT 使用as给列或表指定别名示例： 1SELECT NAME AS 姓名,AGE AS 性别 FROM dbo.STUDENT AS 学生表 其中AS可以直接省略，例如： 1SELECT NAME 姓名,AGE 性别 FROM dbo.STUDENT 学生表 where使用示例： 12SELECT * FROM dbo.STUDENT WHERE NAME='李筱思'SELECT * FROM dbo.STUDENT WHERE AGE&gt;16 注：字符类型和时间类型的数据需要加引号标识 模糊查询示例： 1234567891011121314-- 查找学生姓名以'李'开头的学生信息SELECT * FROM STUDENT WHERE NAME LIKE '李%'-- 查找学生姓名以'李'或以'赵'开头的学生信息SELECT * FROM STUDENT WHERE NAME LIKE '[李赵]%'-- 查找学生姓名不以'李'开头的学生信息SELECT * FROM STUDENT WHERE NAME NOT LIKE '李%'-- 查找学生姓名不以'李'或以'赵'开头的学生信息SELECT * FROM STUDENT WHERE NAME LIKE '[^李赵]%'-- 查找学生姓名以'李'开头，名字只有一个字符的学生信息SELECT * FROM STUDENT WHERE NAME LIKE '[李]_' OR/AND逻辑运算示例： 12345678-- 查询姓名以'李'开头或年龄是13岁的学生信息SELECT * FROM STUDENT WHERE NAME LIKE '李%' OR AGE=13-- 查询姓名以'李'开头，或年龄是13岁性别为女的学生信息SELECT * FROM STUDENT WHERE NAME LIKE '李%' OR (AGE=13 AND SEX='女')-- 查询姓名以'李'开头且性别为女,或年龄13岁且性别为女的学生信息SELECT * FROM STUDENT WHERE (NAME LIKE '李%' AND SEX='女') OR (AGE=13 AND SEX='女') BETWEEN…AND示例： 12345-- 查询年龄在11到13范围内的学生SELECT * FROM STUDENT WHERE AGE BETWEEN 11 AND 13-- 查询年龄不在11到13范围内的学生SELECT * FROM STUDENT WHERE AGE NOT BETWEEN 11 AND 13 注：BETWEEN…AND是包括边界的 IN示例： 123456-- 查询年龄为10岁或15岁的学生SELECT * FROM STUDENT WHERE AGE IN (10,15)-- 其实这里跟使用OR是一个效果-- 查询年龄不为10岁或15岁的学生SELECT * FROM STUDENT WHERE AGE NOT IN (10,15) IS NULL示例： 12345-- 查询地址为空的学生信息SELECT * FROM STUDENT WHERE ADDRESS IS NULL-- 查询地址不为空的学生信息SELECT * FROM STUDENT WHERE ADDRESS IS NOT NULL ORDER BYORDER BY ... DESC/ASC：降序排序/升序排序，默认是ASC示例： 12345-- 查询所有学生，按年龄降序排序SELECT * FROM STUDENT ORDER BY AGE DESC-- 查询所有学生，按年龄升序排序SELECT * FROM STUDENT ORDER BY AGE ASC 同时对多个字段排序：若以多个字段排序时，以第一个排序的字段为主，当第一个字段出现相等值时对第二个字段排序 示例： 12-- 同时对学生性别、年龄排序SELECT * FROM STUDENT ORDER BY SEX DESC,AGE DESC 排名函数RANK具体语法： 1RANK() OVER(PARTITION BY 表达式 ORDER BY 表达式) 注：针对分区内的每行数据排名，若排序字符按值相等，则排名相同，PARTITION BY子句可选示例： 12345678-- 按照学生年龄降序排名SELECT *,RANK() OVER(ORDER BY AGE DESC) AS 排名 FROM dbo.STUDENT-- 按照性别分组，在分组内按照年龄降序排名SELECT *,RANK() OVER(PARTITION BY SEX ORDER BY AGE DESC) 排名 FROM dbo.STUDENT-- 按照性别分组，在分组内按照年龄降序排名，对结果集按照年龄升序排序SELECT *,RANK() OVER(PARTITION BY SEX ORDER BY AGE DESC) 排名 FROM dbo.STUDENT ORDER BY AGE ASC 排名函数ROW_NUMBER具体语法： 1ROW_NUMBER() OVER(PARTITION BY 表达式 ORDER BY 表达式) 注：对分区内的每行数据排名，若排序字段值相等，则排名累计，PARTITION BY子句可选示例： 12345678-- 按照学生年龄降序排名SELECT *,ROW_NUMBER() OVER(ORDER BY AGE DESC) AS 排名 FROM dbo.STUDENT-- 按照性别分组，在分组内按照年龄降序排名SELECT *,ROW_NUMBER() OVER(PARTITION BY SEX ORDER BY AGE DESC) 排名 FROM dbo.STUDENT-- 按照性别分组，在分组内按照年龄降序排名，对结果集按照年龄升序排序SELECT *,ROW_NUMBER() OVER(PARTITION BY SEX ORDER BY AGE DESC) 排名 FROM dbo.STUDENT ORDER BY AGE ASC 过滤重复数据DISTINCT消除重复项 DISTINCT关键字可以从SELECT语句的结果中消除重复的行，如果没有指定DISTINCT，将返回所有行，包括重复的行 示例： 1SELECT DISTINCT ADDRESS FROM dbo.STUDENT 判断对象(表/存储过程/视图等)是否存在判断表是否存在方式1使用SYS.OBJECTS测试，在数据库中创建的每个用户定义的架构作用域内的对象在该表中对应一行 示例： 12IF EXISTS(SELECT * FROM sys.objects WHERE name='STUDENT')DROP TABLE/PROC dbo.STUDENT 判断表是否存在方式2使用OBJECT_ID测试，OBJECT_ID(OBJECT_NAME.[OBJECT_TYPE])返回架构范围内数据库对象的唯一标识。 OBJECT_TYPE：U表示用户自定义表，P表示SQL存储过程，V表示视图 示例： 12IF(OBJECT_ID('STUDENT','U/P/V') IS NOT NULL)DROP TABLE/PROC dbo.STUDENT SELECT…INTO使用SELECT...INTO创建表并复制表中数据，源表中定义的索引、约束和触发器不会转移到新表中，也不能在SELECT...INTO语句中指定它们 如果定义表的SELECT语句包含一个联接，而该联接将导致IDENTITY属性不能转移到新表 示例： 123456-- 创建表并复制表数据-- 先判断表是否存在，存在则删除，然后再用SELECT...INTOIF(OBJECT_ID('STUDENT_CP','U') IS NOT NULL)DROP TABLE dbo.STUDENT_CPGOSELECT * INTO STUDENT_CP FROM dbo.STUDENT INSERT…SELECT使用INSERT...SELECT将数据从一个表插入另一个表 基本语法： 1INSERT INTO 目标表...INSERT INTO 源表 注：目标表必须存在示例： 123456789101112-- 先判断表是否存在，存在则删除，然后再创建一张表，再往表里写源表查询出来的数据IF OBJECT_ID('STUDENT_INSERT','U') IS NOT NULLDROP TABLE STUDENT_INSERTGOCREATE TABLE STUDENT_INSERT(姓名 VARCHAR(10),性别 CHAR(2),年龄 INT)GOINSERT INTO STUDENT_INSERT SELECT NAME,SEX,AGE FROM dbo.STUDENT MERGE..INTO根据与源表的联接的结果，对目标表执行插入、更新或删除操作。例如：根据在另一个表中找到的差异在一个表中插入、更新或删除行，可以对两个表进行同步 示例： 1234567891011-- 合并两张学生表的学生信息，当学生姓名相同时更新目标表的学生信息，当目标表没有该学生时插入学生信息-- 目标表=STUDENT 源表=STUDENT_INSERT-- 以下操作描述： -- 以STUDENT_INSERT为准，如果STUDENT里的哪条数据跟STUDENT_INSERT里哪条数据的NAME相同，则将STUDENT里这条数据的年龄更新成STUDENT_INSERT里这条数据的年龄 -- 如果STUDENT_INSERT里有数据的姓名是STUDENT里没有的，则向STUDENT里插入这条数据MERGE INTO dbo.STUDENTUSING dbo.STUDENT_INSERTON dbo.STUDENT.NAME=dbo.STUDENT_INSERT.姓名WHEN MATCHED THEN UPDATE SET AGE=dbo.STUDENT_INSERT.年龄 --匹配上则更新年龄WHEN NOT MATCHED THEN INSERT (NAME,SEX,AGE) VALUES(dbo.STUDENT_INSERT.姓名,dbo.STUDENT_INSERT.性别,dbo.STUDENT_INSERT.年龄); --没匹配上则插入GO TOPTOP限制返回结果集的行数，当将TOP与ORDER BY子句结合使用时，结果集限制为前N个已排序行，否则，它将以未定义的顺序返回前N个行 示例： 12345678-- 查询学生表中前3行数据SELECT TOP 3 * FROM dbo.STUDENT-- 对学生表按年龄排序返回前3行数据SELECT TOP 3 * FROM dbo.STUDENT ORDER BY AGE-- TOP N WITH TIES 返回结果集前N条记录，以及排序字段值与第N条记录相等的记录，TOP N WITH TIES必须与ORDER BY一同使用SELECT TOP 3 WITH TIES * FROM dbo.STUDENT ORDER BY AGE 使用TOP限制删除的行数示例： 12345-- 删除年龄小于15岁的任意一个学生数据DELETE TOP(1) FROM dbo.STUDENT WHERE AGE&lt;15-- 删除年龄小于15岁年龄最小的一个学生DELETE FROM dbo.STUDENT WHERE AGE IN (SELECT TOP 1 AGE FROM dbo.STUDENT WHERE AGE&lt;15 ORDER BY AGE ASC) 使用TOP限制更新的行数示例： 12345-- 更新年龄小于15岁的任意一个学生的年龄UPDATE TOP(1) dbo.STUDENT SET AGE=AGE+10 WHERE AGE&lt;15-- 更新年龄小于15岁年龄最小的一位学生的年龄UPDATE dbo.STUDENT SET AGE=AGE+10 FROM (SELECT TOP 1 ID FROM dbo.STUDENT WHERE AGE&lt;15 ORDER BY AGE ASC) TB_TOP WHERE TB_TOP.ID=dbo.STUDENT.ID 使用TOP限制插入行数示例： 1234567891011121314151617-- 向新创建的表中插入任意两条学生数据 -- 先创建STUDENT02表 -- 在插入数据SELECT * INTO STUDENT02 FROM dbo.STUDENT WHERE 1=2GOINSERT TOP(2) INTO STUDENT02OUTPUT Inserted.NAME,Inserted.SEX,Inserted.AGESELECT NAME,SEX,AGE FROM dbo.STUDENTGO-- 向创建的新表中插入年龄最小的两条学生数据SELECT * INTO STUDENT03 FROM dbo.STUDENT WHERE 1=2GOINSERT INTO STUDENT03OUTPUT Inserted.NAME,Inserted.SEX,Inserted.AGESELECT TOP(2) NAME,SEX,AGE FROM dbo.STUDENT ORDER BY AGE ASCGO 注：Inserted是一张系统的临时表，将要插入的数据都会在这个表里有记录，OUTPUT就是将这些要插入的数据显示出来","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习04--临时表的使用","slug":"28.TSqlReview04","date":"2020-05-20T04:07:00.000Z","updated":"2020-05-20T11:09:09.094Z","comments":true,"path":"2020/05/20/28.TSqlReview04/","link":"","permalink":"http://www.dimsum.fun/2020/05/20/28.TSqlReview04/","excerpt":"","text":"临时表的类型 本地临时表 全局临时表 临时表的创建 创建方式1(不基于原始表) 创建方式2(基于原始表) 临时表的增删改查 临时表的类型本地临时表本地临时表仅在当前会话中可见，本地临时表的名称前面有一个数字符号(#table_name)，本地临时表在当前会话结束时都会被自动删除 全局临时表全局临时表在所有会话中都可见，全局临时表的名称前面有两个数字符号(##table_name)，全局临时表在创建此表的会话结束且其他所有任务停止对其引用时会被动删除 临时表的创建创建方式1(不基于原始表)具体语法： 12create table #临时表名/##临时表名(字段 数据类型) 示例： 12345678USE SCHOOLGOCREATE TABLE #t1(id INT,name VARCHAR(20))GO 创建方式2(基于原始表)具体语法： 1select * into #临时表名/##临时表名 from 原始表 示例： 1SELECT * INTO #student FROM dbo.STUDENT 临时表的增删改查与普通表的增删改查一致","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习03--数据操作语言DML","slug":"27.TsqlReview03","date":"2020-05-20T03:48:00.000Z","updated":"2020-05-20T11:09:09.094Z","comments":true,"path":"2020/05/20/27.TsqlReview03/","link":"","permalink":"http://www.dimsum.fun/2020/05/20/27.TsqlReview03/","excerpt":"","text":"从表检索数据 查询表中的所有列(性能低) 查询表中的几个字段(性能高) 向表中插入数据 修改表中的数据 删除表中的数据 删除表中部分数据 删除表中全部数据 使用delete 使用truncate 从表检索数据查询表中的所有列(性能低)具体语法： 123use 数据库名select * from 表名go 示例： 1234USE SCHOOLGOSELECT * FROM dbo.STUDENTGO 查询表中的几个字段(性能高)具体语法： 123use 数据库名select 字段1,字段2 ... 字段3 from 表名go 示例： 1234USE SCHOOLGOSELECT NAME,SEX FROM dbo.STUDENTGO 向表中插入数据具体语法： 1234567use 数据库名insert into 表名(字段1,字段2,...,字段N)values(值1,值2,...,值N),(值1,值2,...,值N)go 注：N最大为1024示例： 12345678USE SCHOOLGOINSERT dbo.STUDENT(NAME,SEX,AGE)VALUES('张小三','男','14'),('李小四','女','12')GO 修改表中的数据具体语法： 1234567use 数据库名update 表名set 字段1='修改后的值',字段2='修改后的值',...where 条件 示例： 1234567USE SCHOOLGOUPDATE dbo.STUDENTSETNAME='李筱思',AGE='16'WHERE ID=2 删除表中的数据删除表中部分数据具体语法： 1234use 数据库名delete from 表名where 条件go 示例： 1234USE SCHOOLGODELETE FROM dbo.STUDENT WHERE ID=1GO 删除表中全部数据使用delete具体语法： 123use 数据库名delete from 表名go 示例： 1234USE SCHOOLGODELETE FROM dbo.STUDENTGO 使用truncate具体语法： 12use 数据库名truncate table 表名 示例： 1234USE SCHOOLGOTRUNCATE TABLE dbo.STUDENTGO 注：truncate table 表名与delete from 表名效果相同，删除表中的所有记录，但是truncate速度快使用的系统资源和事务日志资源更少 删除表中全部数据，但是表的框架还在，即各个字段都还存在，只是表中没有记录而已，要删除整张表，得使用drop table 表名","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习02--数据表操作","slug":"26.TSqlReview02","date":"2020-05-20T02:21:00.000Z","updated":"2020-05-20T11:09:09.093Z","comments":true,"path":"2020/05/20/26.TSqlReview02/","link":"","permalink":"http://www.dimsum.fun/2020/05/20/26.TSqlReview02/","excerpt":"","text":"数据库相关概念 数据类型类别 标识符 创建表的规则 使用T-SQL创建表 使用T-SQL修改表列属性 使用T-SQL添加删除表列 添加列 删除列 使用T-SQL修改表名 使用T-SQL删除表 数据库相关概念 数据库就是存放数据的仓库 数据库由表、关系及操作对象组成 数据存放在表中 数据库表由记录组成 记录由字段组成 字段由字符或数字等组成 在创建表时，要考虑数据表的结构问题，也就是涉及确定数据表中各列的数据格式是数值、字符、日期、货币、图像等其他数据格式，这个数据格式就是数据类型 在SQL Server数据库中，每个列、变量、表达式和参数都有其各自的数据类型。指定对象的数据类型相当于定义了对象的以下特性 对象所含的数据类型，如字符、整数或二进制数 所存储值的长度或它的大小 小数位数(仅用于数字数据类型) 数据类型类别 描述 具体类型 字符串 char、varchar、text Unicode字符串 nchar、nvarchar、ntext 精确数字 bigint、int、smallint、tinyint、numeric、decimal、money、smallmoney 日期和时间 datetime2、datetime、smalldatetime、date、time、datetimeoffset 近似数字 float、real 二进制字符串 binary、varbinary、image 其他数据类型 cursor、timestamp、hierarchyid、uniqueidentifier、xml、sql_variant、table 标识符 标识符可以包含字符、符号及数字，不允许有空格 标识符应尽量短 标识符要使用有意义的名字 使用能够区分对象类型的标识符 保持对象名和用户名唯一性 创建表的规则 表和列的名称必须遵守标识符的规定 列名在表中必须是唯一的 必须为每列指定数据类型 每一行代表一条唯一的记录 使用T-SQL创建表具体语法： 123456789use 数据库名create table 表名( 字段1 数据类型 identity(标识种子,递增量) 是否为空, 字符2 数据类型 是否为空, ... 字段N 数据类型 是否为空)go 注：N最大可等于1024在数据库中，常用的一个流水编号通常会使用identity字段来进行设置，这种编号的个好处是一定不会重复，而且一定是唯一的，这对table中的唯一值特性很重要，通常用来做客户编号、订单编号等功能。identity用在数据类型后边，并定义初始值和递增量，因为使用identity的字段由数据库维护，所以在insert into该表时，不需要对该字段插入值示例： 1234567891011USE SCHOOLGOCREATE TABLE STUDENT(ID BIGINT IDENTITY(1,1) NOT NULL,NAME VARCHAR(10) NOT NULL,SEX CHAR(2) NOT NULL,AGE INT NOT NULL)GO 使用T-SQL修改表列属性当数据库中的表创建完成后，可以根据需要改变表中原先定义的许多选项，以更改表的结构。用户可以增加、删除和修改列，增加、删除和修改约束，更改表名以及改变表的所有者等 具体语法： 1234use 数据库名alter table 表名alter column 字段名 新数据类型 (新长度)go 示例： 12345USE SCHOOLGOALTER TABLE dbo.STUDENTALTER COLUMN NAME CHAR(20) NULLGO 使用T-SQL添加删除表列添加列具体语法： 12345use 数据库名alter table 表名add 字段名1 数据类型 null--是否可空，默认是空，若要不为空，可以指定为not nulladd 字段名2 ... --可以同时添加多列go 示例： 12345USE SCHOOLGOALTER TABLE dbo.STUDENTADD PHONE CHAR(20) NULLGO 删除列具体语法： 123456use 数据库名alter table 表名drop column 字段名1drop column 字段名2... --可以同时删除多列go 示例： 12345USE SCHOOLGOALTER TABLE dbo.STUDENTDROP COLUMN PHONEGO 使用T-SQL修改表名需要使用到系统自带的sp_name存储过程具体语法： 12use 数据库名exec sp_rename '旧表名','新表名' 示例: 1234USE SCHOOLGOEXEC sys.sp_rename 'STUDENT','STUDENT01'GO 使用T-SQL删除表具体语法： 12use 数据库名drop table 表名 示例： 1234USE SCHOOLGODROP TABLE dbo.STUDENT01GO","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"T-SQL复习01--数据库操作","slug":"25.TSqlReview01","date":"2020-05-20T01:32:00.000Z","updated":"2020-05-20T11:09:09.093Z","comments":true,"path":"2020/05/20/25.TSqlReview01/","link":"","permalink":"http://www.dimsum.fun/2020/05/20/25.TSqlReview01/","excerpt":"","text":"T-SQL DDL(数据定义语言) DML(数据操作语言) DCL(数据控制语言) DQL(数据查询语言) 使用T-SQL创建数据库 使用T-SQL新增辅助数据文件 使用T-SQL新增日志文件 使用T-SQL修改数据库文件属性 使用T-SQL操作文件组 添加文件组 添加文件把它放进文件组 设置默认文件组 修改数据库名称/删除数据库 修改数据库名称 删除数据库 T-SQLDDL(数据定义语言)主要针对数据库对象，数据库对象包括表、视图、存储过程、索引等 create(创建) alter(修改) drop(删除)DML(数据操作语言)主要针对对象的内容，对象的内容包括表或视图的记录(数据) insert(插入) update(更新) delete(删除)DCL(数据控制语言)主要针对用户权限的控制，如数据库的权限和服务器的权限等 revoke(撤销) deny(拒绝) grant(同意、授权)DQL(数据查询语言)就是针对数据查询的 select(查询) 使用T-SQL创建数据库具体语法： 1234567891011121314151617181920create database 数据库名on primary( --数据文件 name='逻辑名', filename='文件的存放路径', size=数据文件的初始大小, maxsize=数据文件的最大大小, filegrowth=文件的增长方式)log on( --日志文件 name=逻辑名 filename='文件的存放路径', size=日志文件的初始大小, maxsize=日志文件的最大大小, filegrowth=日志文件的增长方式)go 示例： 1234567891011121314151617CREATE DATABASE SCHOOLON PRIMARY( NAME='SCHOOL', FILENAME='C:\\database\\SCHOOL.MDF', SIZE=10MB, MAXSIZE=100MB, FILEGROWTH=2MB)LOG ON( NAME='SCHOOL_LOG', FILENAME='C:\\database\\SCHOOL_LOG.LDF', SIZE=5MB, MAXSIZE=UNLIMITED, --大小不受限制 FILEGROWTH=10%) 使用T-SQL新增辅助数据文件具体语法： 12345678910alter database 数据库名add file( name='逻辑名', filename='文件存放的路径', size=初始大小 maxsize=最大大小, filegrowth=增长方式)go 示例： 123456789ALTER DATABASE SCHOOLADD FILE( NAME='SCHOOL01', FILENAME='C:\\database\\SCHOOL01.NDF', SIZE=5MB, MAXSIZE=100MB, FILEGROWTH=3MB) 使用T-SQL新增日志文件具体语法： 123456789alter database 数据库名add log file( name=逻辑名 filename='文件的存放路径', size=日志文件的初始大小, maxsize=日志文件的最大大小, filegrowth=日志文件的增长方式) 示例 123456789ALTER DATABASE SCHOOLADD LOG FILE( NAME='SCHOOL_LOG01', FILENAME='C:\\database\\SCHOOL_LOG01.LDF', SIZE=5MB, MAXSIZE=80MB, FILEGROWTH=1MB) 使用T-SQL修改数据库文件属性具体语法： 12345678alter database 数据库名modify file( name='逻辑名', size=修改后的大小, maxsize=修改后的大小， filegrowth=修改后的大小) 示例 12345678ALTER DATABASE SCHOOLMODIFY FILE(NAME='SCHOOL_LOG01',SIZE=18MB,MAXSIZE=88MB,FILEGROWTH=8MB) 使用T-SQL操作文件组添加文件组具体语法： 12alter database 数据库名add filegroup 文件组名 示例： 12ALTER DATABASE SCHOOLADD FILEGROUP FILEGROUP01 添加文件把它放进文件组具体语法： 1234alter database 数据库名add file(...)to filegroup 文件组名 示例： 12345678910ALTER DATABASE SCHOOLADD FILE( NAME='SCHOOL02', FILENAME='C:\\database\\SCHOOL02.NDF', SIZE=5MB, MAXSIZE=50MB, FILEGROWTH=1MB)TO FILEGROUP FILEGROUP01 设置默认文件组具体语法： 12alter database 数据库名modify filegroup 文件组名 default 示例： 12ALTER DATABASE SCHOOLMODIFY FILEGROUP FILEGROUP01 DEFAULT 修改数据库名称/删除数据库修改数据库名称具体语法： 12alter database 原数据库名称modify name=新数据库名 示例： 12ALTER DATABASE SCHOOLMODIFY NAME=SCHOOL_NEW 删除数据库不能删除系统数据库具体语法： 1drop database 数据库名 示例： 1DROP DATABASE SCHOOL_NEW","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"}]},{"title":"面试备忘","slug":"24.InterviewBackup","date":"2020-05-14T09:51:00.000Z","updated":"2020-05-27T16:57:02.914Z","comments":true,"path":"2020/05/14/24.InterviewBackup/","link":"","permalink":"http://www.dimsum.fun/2020/05/14/24.InterviewBackup/","excerpt":"","text":"ASP.NET Core 数据库相关 其他 一些面试题的备忘 ASP.NET Core 服务的注册方式和获取方式 解答 使用框架自带的IoC框架是通过Startup的ConfigureService方法里的IServiceCollerction进行注册 一般通过接口与实现类的方式实现，也可以通过工厂的方式进行注册服务，不推荐直接new服务进行注册，这样IoC框架是不会进行该服务的生命周期管理 获取方式一般可以通过构造函数、参数的[FromService]、通过BuilderServiceProvider获取serviceProvider对象，在serviceProvider里获取服务 autofac和自带的IoC框架的区别 解答 Autofac新增基于名称的注入、属性注入、AOP 注册服务的地方是在Startup里新增的ConfigureContainer方法里 WebAPI的CQRS策略 JWT的组成和加密方式 解答 加密方式.经过base64转码的消息主体.签名 使用HS256的签名加密方式 ViewData、ViewBag、TempData的区别 解答： ViewBag是在ViewData上面加一层dynamic，如果用同个key，比如ViewBag.Info=&quot;ABC&quot;，在页面其实也可以通过ViewData[&quot;Info&quot;]来获取，同时也以为着ViewBag=&quot;ABC&quot;;ViewData[&quot;info&quot;]=&quot;123&quot;，后面会覆盖前面的； TempData是存放在session里面，意味着可以跨action来取值，比如ActionA中赋值了TempData[&quot;Info&quot;]=&quot;ABC&quot;，在ActionA对应的ViewA中点击跳转到ActionB，则可以直接在ActionB中通过TempData[&quot;Info&quot;]来取得&quot;ABC&quot; 但是要注意，TempData在被取值之后就会被删除，所以上面的场景如果在ActionA对应的ViewA中把TempData[&quot;Info&quot;]取出来，则在ActionB中就获取不到TempData[&quot;Info&quot;]的值，获取到的是个null API的版本管理 解答 使用URL带版本的方式，在Controller里使用[Route(&#39;&#39;)]来指定版本 使用中间件Use/Run/Map的区别 解答 通常使用的Use Run起到的是断路器的作用，即不再执行后面的中间件 Map一般是针对特殊的路径使用特殊的中间件管道 中间件里面怎么获取服务 解答 使用中间件的Invoke方法中的HttpContext对象context.RequestServices.GetService&lt;T&gt;()来获取 EFCore的TPH EFCore的lazyload 数据库相关 delete、truncate的区别 解答： delete可以带where，truncate不能带where delete慢，truncate快 delete每删一条数据都会在数据库日志里记录这条记录，truncate只会记录整表做了清除记录，这意味这delete可以被回滚，truncate是不能回滚的 delete会触发delete触发器，truncate是不会触发任何触发器的 view、table的区别 go做了什么，go上面定义的变量go下面能获得到吗？ 定义事务的标准 连续自增的主键删除掉一个断开了，怎么补回这个断掉的逐渐 select * into A from B、insert into A select * from B的区别 create table #tmp_A(id int) go insert into #tmp_A values(1) --select * from #tmp_A if @@error&lt;&gt;0 print @@error else print @@rowcount 上面的执行结果是什么 存储过程中@、#、##、CTE的区别 聚集索引与非聚集所以区别 其他 .xsd、XML的schemas json是什么 rabbitmq中的topic、queue是什么，消息持久化是在哪个位置 说一下pub/sub，订阅的时候能获得订阅之前的消息吗？ Queue、ConQueue的区别 从数据结构说一下stack、queue的区别 编译的时候Debug模式和Release模式的区别 解答： 在Debug模式可以使用#IF DEBUG来跑一些调试模式下的特殊代码，在打包成Release的DLL的时候，#IF DEBUG的代码会被忽略 编译时选择Any CPU、x86、x64的区别 DDD是怎么分层的 说一下 聚合根、实体、值对象 DDD的仓储层是怎么实现的 async/await会不会堵塞主线程，如果会，那为什么还要用？ 解答 调用线程在遇到await的时候，会直接返回去做调用后的事情，不会执行await后面的代码 可以粗暴的认为，在await后面的代码会被包装成一个回调，在await代码执行完成之后，再执行回调代码，其中回调的线程具备多种可能行，可能是执行await代码的线程，也可能是新线程 反编译查看：首先IL里面是没有async/await的，就是常规代码，代码正常执行的时候，会实例化一个状态机，状态=-1，然后执行Task前面的普通代码，遇到await Task.Run()的时候会启动线程去执行Task，然后判断是否完成，这时候线程刚启动肯定没完成，所以判断为未完成，并将状态重置=0，然后递归调用一下自己，调用之后再次判断是否状态，发现状态=0，则表示调用线程任务完成，返回去做自己原来的事","categories":[{"name":"面试","slug":"面试","permalink":"http://www.dimsum.fun/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.dimsum.fun/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"C#一些基础语法理解","slug":"23.CSharpBase","date":"2020-04-23T09:51:00.000Z","updated":"2020-04-23T11:10:29.799Z","comments":true,"path":"2020/04/23/23.CSharpBase/","link":"","permalink":"http://www.dimsum.fun/2020/04/23/23.CSharpBase/","excerpt":"","text":"abstract virtual 只是一些日常开发理解备忘，肯定有漏洞！别当真！！！ abstract抽象类，定义方式为 123abstract class MyAbstractClass&#123;&#125; 主要由以下几个特点： 不能直接被实例化 可以包含或不包含普通方法 可以包含或不包含抽象方法，抽象方法不能有方法体，即只能定义不能实现，使用abstract关键字，类似：1public abstract void MyMethod(); 要使用抽象类，需要有另一个普通类来继承这个抽象类，这个普通类要override抽象类里的抽象方法，然后使用方实例化这个普通类即可 说点人话：我是大爷(抽象类)，大爷会开车(抽象方法)、会打人(普通方法)，但是驾照被吊销了；你跟了我(继承)，你就得会开车，开车的事你来做(override)，但是打人我能干，别人叫你打人的时候我来干 正经点，说个使用场景： 有个类，有一些方法是需要继承它的类自己单独实现，但是又有一些方法是通用的，这个类就可以定义为抽象类，需要子类去实现的方法定义为抽象方法，通用的方法则定义为普通方法 virtual这个关键字是给方法用的，使用方式为 1234public virtual string Hello()&#123; return \"Hello From Temp\";&#125; 定义virtual方法是标识这个方法可以被子类override，在调用的时候，如果子类override了这个方法，则会调用子类的方法，如果子类没有override这个方法，则会调用父类的virtual方法 说点人话：你继承你爹我(继承)，你会的你干(override)，你不会的你爹来干(没有override)！！","categories":[{"name":"C#基础备忘","slug":"C-基础备忘","permalink":"http://www.dimsum.fun/categories/C-%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://www.dimsum.fun/tags/C/"}]},{"title":"gRPC in ASP.NET Core","slug":"22.gRPC_document","date":"2020-04-20T10:30:00.000Z","updated":"2020-04-23T11:06:11.997Z","comments":true,"path":"2020/04/20/22.gRPC_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/20/22.gRPC_document/","excerpt":"","text":"开发环境 VSCode 消息类型的演进 更新消息类型的规则 默认值 枚举 在.NET Core中使用gRPC ASP.NET Core .NET Core 引包之后的操作 作为服务端 作为客户端 上代码 服务端 创建目录 编写proto 编写测试数据 编写Service 修改Startup 运行项目 客户端 创建项目 复制proto文件 修改Program.cs 运行项目 日志和异常 日志 ASP.NET Core .NET Core控制台 异常 关于JWT授权 多项目之间共享proto文件 开发环境VSCodewindow下需要安装Clang，百度找Clang，去官网自行下载，如果下载速度慢，可以添加以下内容到C:\\Windows\\System32\\drivers\\etc\\host文件 12354.231.82.146 vagrantcloud-files-production.s3.amazonaws.com219.76.4.4 s3.amazonaws.com219.76.4.4 github-cloud.s3.amazonaws.com 然后再VSCode中安装两个插件 12vscode-proto3Clang-Format 消息类型的演进 向前兼容变更：使用新的.proto文件来写数据 – 从旧的.proto文件读取数据 向后兼容变更：使用旧的.proto文件来写数据 – 从新的.proto文件读取数据更新消息类型的规则 不要修改任何现有字段的数字(tag) 可以添加新的字段，旧的代码会忽略掉新字段的解析，所以要注意新字段的默认值 字段可以被删除，只要它们的数字(tag)在更新后的消息类型中不再使用即可，也可以把字段名使用OBSOLETE_前缀而不是删除字段，或者把这些字段的数字(tag)进行保留(reserved)，以免未来其他开发者不小心使用这些字段 尽量不要修改原有的字符数据类型默认值默认值在更新Protocol Buffer消息定义的时候有很重要的作用，它可以防止对现有代码/新代码造成破坏性影响。它们也可以保证字段永远不会有null值 但是，默认值还是非常危险的：你无法区分这个默认值到底是来自一个丢失的字段还是字段的实际值正好等于默认值 所以，需要保证这个默认值对于业务来说是一个毫无意义的值，例如int32 pop人口这个字段的默认值可以设置为-1，再就是可能需要再代码里对默认值进行判断处理 枚举enum同样可以进化，就和消息的字段一样，可以添加、删除值，也可以保留值 但是如果代码不知道它接收到的值对应哪个enum值，那么enum的默认值将会被采用 在.NET Core中使用gRPCASP.NET Core依赖包： 1Grpc.AspNetCore .NET Core依赖包： 123Google.ProtobufGrpc.Net.ClientGrpc.Tools 引包之后的操作按照项目类型引入上面的包之后，直接编译是不会得到gRPC框架生成的代码，需要做以下操作：右键.proto文件 -&gt; 属性 -&gt; 将Build Action选择为Protobuf compiler -&gt; gRPC Stub Classes按照需求选择Client and Server/Client only/Server only/Do not generate 进行完上面的操作之后，编译项目会在obj\\Debug\\netcoreapp3.1目录里自动生成RPC代码 作为服务端怎么实现rpc定义的方法：假设在.proto文件里有EmployeeService这样一个service，在编译项目之后，会有一个EmployeeService.EmployeeServiceBase的类，自己编写一个类继承自EmployeeService.EmployeeServiceBase这个类，然后override去重载.proto服务里定义的那些rpc方法即可 作为客户端怎么调用rpc定义的方法：需要先创建Channel，例如： 1using var channel = GrpcChannel.ForAddress(\"https://localhost:5001\"); 然后假设在.proto文件里有EmployeeService这样一个service，在编译项目之后(需要选择client或client and server)，会有一个EmployeeService.EmployeeServiceClient的类，实例化这个类就相当实例化一个client，例如： 1var client = new EmployeeService.EmployeeServiceClient(channel); 在client里就可以调用.proto服务里定义的那些方法 上代码服务端创建名字为RoutingDemo的ASP.NET Core项目，类型为空，通过nuget引入： 1Grpc.AspNetCore 创建目录在项目根目录创建以下三个文件夹 123DataProtosServices 编写proto在Protos文件夹中添加文件Order.proto，具体内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051syntax &#x3D; &quot;proto3&quot;;option csharp_namespace &#x3D; &quot;GrpcDemo.Protos&quot;;message Order&#123; int32 Id &#x3D; 1; string OrderNo &#x3D; 2; int32 Status &#x3D; 3; float Payment &#x3D; 4; repeated OrderProduct Products &#x3D; 5; OrderAddress Address &#x3D; 6; int32 OrderOwner &#x3D; 7; message OrderProduct&#123; string ProductTitle &#x3D; 1; string SkuTitle &#x3D; 2; int32 Num &#x3D; 3; float UnitPrice &#x3D; 4; &#125; message OrderAddress&#123; string Province &#x3D; 1; string City &#x3D; 2; string Districe &#x3D; 3; string Detail &#x3D; 4; string Name &#x3D; 5; string Mobile &#x3D; 6; &#125;&#125;message GetByOrderNoRequest&#123; string OrderNo &#x3D; 1;&#125;message GetByOwnerRequest&#123; int32 OrderOwner &#x3D; 1;&#125;message BatchAddOrderNoReturnResponse&#123; bool IsAllSuccess &#x3D; 1; repeated string FailOrderNo &#x3D; 2;&#125;service OrderService&#123; rpc GetByOrderNo(GetByOrderNoRequest) returns(Order); rpc GetByOwner(GetByOwnerRequest) returns(stream Order); rpc AddOrder(Order) returns(Order); rpc BatchAddOrder(stream Order) returns(stream Order); rpc BatchAddOrderNoReturn(stream Order) returns(BatchAddOrderNoReturnResponse);&#125; 在解决方案资源管理器找到Order.proto文件，右键 -&gt; 属性 -&gt; Build Action选择Protobuf compiler -&gt; gRPC Stub Classes选择Server only 编译一次项目 编写测试数据在Data文件夹创建InMemoryData.cs文件，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using System.Collections.Generic;using GrpcDemo.Protos;namespace GrpcServerDemo.Data&#123; public class InMemoryData &#123; public static List&lt;Order&gt; Orders = new List&lt;Order&gt;() &#123; new Order() &#123; Id = 1, OrderNo = \"2020042201\", Status = 1, Payment = 43141.98f, Products = &#123; new Order.Types.OrderProduct() &#123; ProductTitle = \"Apple iPhone11\", SkuTitle = \"256GB 黑色\", Num = 2, UnitPrice = 9999.99f &#125;, new Order.Types.OrderProduct() &#123; ProductTitle = \"Apple MacBook Pro\", SkuTitle = \"i7 512GB 灰色\", Num = 1, UnitPrice = 23142 &#125; &#125;, Address = new Order.Types.OrderAddress() &#123; Province = \"广东省\", City = \"深圳市\", Districe = \"南山区\", Detail = \"Nanshan Road 1234\", Name = \"Jiamiao.x\", Mobile = \"13500000000\" &#125;, OrderOwner = 100, &#125;, new Order() &#123; Id = 2, OrderNo = \"2020042202\", Status = 2, Payment = 56.00f, Products = &#123; new Order.Types.OrderProduct() &#123; ProductTitle = \"ASP.NET Core微服务实战\", SkuTitle = \"1本\", Num = 1, UnitPrice = 56.00f &#125; &#125;, Address = new Order.Types.OrderAddress() &#123; Province = \"广东省\", City = \"深圳市\", Districe = \"南山区\", Detail = \"Nanshan Road 1234\", Name = \"Jiamiao.x\", Mobile = \"13500000000\" &#125;, OrderOwner = 100 &#125; &#125;; &#125;&#125; 注意：这里的Order是gRPC生成的，命名空间为GrpcDemo.Protos 编写Service在Services文件夹创建DemoOrderService.cs文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081using System;using System.Linq;using System.Threading;using System.Threading.Tasks;using Grpc.Core;using GrpcDemo.Protos;using GrpcServerDemo.Data;using Microsoft.Extensions.Logging;namespace GrpcServerDemo.Services&#123; public class DemoOrderService : OrderService.OrderServiceBase &#123; private readonly ILogger&lt;DemoOrderService&gt; _logger; public DemoOrderService(ILogger&lt;DemoOrderService&gt; logger) &#123; _logger = logger; &#125; public override async Task&lt;Order&gt; GetByOrderNo(GetByOrderNoRequest request, ServerCallContext context) &#123; _logger.LogInformation(\"有人请求接口 -&gt; GetByOrderNo\"); var metaData = context.RequestHeaders; foreach (var item in metaData) &#123; _logger.LogInformation($\"&#123;item.Key&#125;: &#123;item.Value&#125;\"); &#125; await Task.CompletedTask; var dbValue = InMemoryData.Orders.FirstOrDefault(x =&gt; x.OrderNo == request.OrderNo); if (dbValue != null) &#123; return dbValue; &#125; else &#123; throw new Exception(\"订单号错误\"); &#125; &#125; public override async Task GetByOwner(GetByOwnerRequest request, IServerStreamWriter&lt;Order&gt; responseStream, ServerCallContext context) &#123; _logger.LogInformation(\"有人请求接口 -&gt; GetByOwner\"); var dbValue = InMemoryData.Orders.Where(x =&gt; x.OrderOwner == request.OrderOwner); foreach (var item in dbValue) &#123; Thread.Sleep(2000); _logger.LogInformation($\"发送数据：&#123;item&#125;\"); await responseStream.WriteAsync(item); &#125; &#125; public override async Task&lt;Order&gt; AddOrder(Order request, ServerCallContext context) &#123; _logger.LogInformation(\"有人请求接口 -&gt; AddOrder\"); await Task.CompletedTask; request.Id = InMemoryData.Orders.Max(x =&gt; x.Id) + 1; InMemoryData.Orders.Add(request); return request; &#125; public override async Task BatchAddOrder(IAsyncStreamReader&lt;Order&gt; requestStream, IServerStreamWriter&lt;Order&gt; responseStream, ServerCallContext context) &#123; _logger.LogInformation(\"有人请求接口 -&gt; BatchAddOrder\"); while (await requestStream.MoveNext()) &#123; var inputOrder = requestStream.Current; lock (this) &#123; _logger.LogInformation($\"接受数据：&#123;inputOrder&#125;\"); inputOrder.Id = InMemoryData.Orders.Max(x =&gt; x.Id) + 1; InMemoryData.Orders.Add(inputOrder); &#125; await responseStream.WriteAsync(inputOrder); Thread.Sleep(5000); &#125; &#125; &#125;&#125; 注意：这里的OrderService.OrderServiceBase一样是gRPC生成的，命名空间为GrpcDemo.Protos 修改Startup修改Startup.cs，内容如下： 1234567891011121314151617181920212223242526272829303132using GrpcServerDemo.Services;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace GrpcServerDemo&#123; public class Startup &#123; public void ConfigureServices(IServiceCollection services) &#123; services.AddGrpc(); &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapGrpcService&lt;DemoOrderService&gt;(); &#125;); &#125; &#125;&#125; 运行项目在Powershell中进入到项目根目录，直接dotnet run运行目录即可 客户端创建项目创建名字为GrpcClientDemo的控制台应用，通过nuget引入以下三个包： 123Google.ProtobufGrpc.Net.ClientGrpc.Tools 复制proto文件将服务端GrpcServerDemo的Protos文件夹拷贝到项目根目录，在解决方案资源管理器找到Order.proto文件，右键 -&gt; 属性 -&gt; Build Action选择Protobuf compiler -&gt; gRPC Stub Classes选择Client only 修改Program.cs修改Program.cs文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174using System;using System.Collections.Generic;using System.Threading.Tasks;using Grpc.Core;using Grpc.Net.Client;using GrpcDemo.Protos;namespace GrpcClientDemo&#123; class Program &#123; static async Task Main(string[] args) &#123; using var channel = GrpcChannel.ForAddress(\"https://localhost:5001\"); var client = new OrderService.OrderServiceClient(channel); var option = int.Parse(args[0]); switch (option) &#123; case 0: await GetByOrderNoAsync(client); break; case 1: await GetByOwner(client); break; case 2: await AddOrder(client); break; case 3: await BatchAddOrder(client); break; &#125; Console.WriteLine(\"==========END==========\"); &#125; public static async Task GetByOrderNoAsync(OrderService.OrderServiceClient client) &#123; var metaData = new Metadata() &#123; &#123;\"userName\", \"jiamiao.x\"&#125;, &#123;\"clientName\", \"GrpcClientDemo\"&#125; &#125;; var response = await client.GetByOrderNoAsync(new GetByOrderNoRequest() &#123;OrderNo = \"2020042201\"&#125;,metaData); Console.WriteLine($\"接收到数据：&#123;response&#125;\"); &#125; public static async Task GetByOwner(OrderService.OrderServiceClient client) &#123; var response = client.GetByOwner(new GetByOwnerRequest() &#123;OrderOwner = 100&#125;); var responseStream = response.ResponseStream; while (await responseStream.MoveNext()) &#123; Console.WriteLine($\"接收到数据：&#123;responseStream.Current&#125;\"); &#125; Console.WriteLine($\"数据接收完毕\"); &#125; public static async Task AddOrder(OrderService.OrderServiceClient client) &#123; var order = new Order() &#123; OrderNo = \"2020042301\", Status = 1, Payment = 43141.98f, Products = &#123; new Order.Types.OrderProduct() &#123; ProductTitle = \"OnePlus 7T\", SkuTitle = \"256GB 蓝色\", Num = 1, UnitPrice = 3600f &#125; &#125;, Address = new Order.Types.OrderAddress() &#123; Province = \"广东省\", City = \"深圳市\", Districe = \"南山区\", Detail = \"北科大厦7003\", Name = \"Jiamiao.x\", Mobile = \"13822113366\" &#125;, OrderOwner = 100, &#125;; var response = await client.AddOrderAsync(order); Console.WriteLine($\"接收到数据：&#123;response&#125;\"); &#125; public static async Task BatchAddOrder(OrderService.OrderServiceClient client) &#123; var orders = new List&lt;Order&gt;() &#123; new Order() &#123; OrderNo = \"2020042301\", Status = 1, Payment = 3600f, Products = &#123; new Order.Types.OrderProduct() &#123; ProductTitle = \"OnePlus 7T\", SkuTitle = \"256GB 蓝色\", Num = 1, UnitPrice = 3600f &#125; &#125;, Address = new Order.Types.OrderAddress() &#123; Province = \"广东省\", City = \"深圳市\", Districe = \"南山区\", Detail = \"北科大厦7003\", Name = \"Jiamiao.x\", Mobile = \"13822113366\" &#125;, OrderOwner = 100, &#125;, new Order() &#123; OrderNo = \"2020042302\", Status = 1, Payment = 13999.99f, Products = &#123; new Order.Types.OrderProduct() &#123; ProductTitle = \"SONY PS4 Pro\", SkuTitle = \"1TB 黑色\", Num = 1, UnitPrice = 3999.99f &#125;, new Order.Types.OrderProduct() &#123; ProductTitle = \"Surface Desktop Pro\", SkuTitle = \"1TB 白色\", Num = 1, UnitPrice = 13999.99f &#125; &#125;, Address = new Order.Types.OrderAddress() &#123; Province = \"广东省\", City = \"深圳市\", Districe = \"南山区\", Detail = \"北科大厦7003\", Name = \"Jiamiao.x\", Mobile = \"13822113366\" &#125;, OrderOwner = 100, &#125; &#125;; var call = client.BatchAddOrder(); foreach (var order in orders) &#123; await call.RequestStream.WriteAsync(order); &#125; await call.RequestStream.CompleteAsync(); Console.WriteLine(\"----数据发送完毕----\"); await Task.Run(async () =&gt; &#123; while (await call.ResponseStream.MoveNext()) &#123; Console.WriteLine($\"接收到消息：&#123;call.ResponseStream.Current&#125;\"); &#125; &#125;); &#125; &#125;&#125; 运行项目在Powershell进入到项目根目录，使用dotnet run [arg]运行项目既可以看到效果，[arg]是对应switch里的参数 日志和异常日志ASP.NET Core作为服务端在ASP.NET Core中开启gRPC日志只需要在appsettings.json中配置grpc的日志等级即可，修改appsettings.json内容如下： 1234567891011&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\", \"grpc\": \"Debug\" &#125; &#125;, \"AllowedHosts\": \"*\"&#125; 运行项目就可以看到控制台打印出gRPC相关日志 .NET Core控制台在客户端的.NET Core控制台程序，需要自定义一个LoggerFactory，然后在创建Channel的时候指定自定义的LoggerFactory。这里的示例使用Serilog来作为日志组件，需要在引入以下三个包： 123SerilogSerilog.Extensions.LoggingSerilog.Sinks.Console 创建SerilogLoggerFactory.cs，内容如下： 12345678910111213141516171819202122232425262728using Microsoft.Extensions.Logging;using Serilog.Debugging;using Serilog.Extensions.Logging;namespace Jiamiao.x.GrpcClient&#123; public class SerilogLoggerFactory:ILoggerFactory &#123; private readonly SerilogLoggerProvider _provider; public SerilogLoggerFactory(Serilog.ILogger logger=null,bool dispose = false) &#123; _provider = new SerilogLoggerProvider(logger, dispose); &#125; public void Dispose() =&gt; _provider.Dispose(); public ILogger CreateLogger(string categoryName) &#123; return _provider.CreateLogger(categoryName); &#125; public void AddProvider(ILoggerProvider provider) &#123; SelfLog.WriteLine(\"Ignore added logger provider &#123;0&#125;\", provider); &#125; &#125;&#125; 回到gRPC服务调用的地方，将创建GrpcChannel的代码修改如下： 1234using var channel = GrpcChannel.ForAddress(\"https://localhost:5001\",new GrpcChannelOptions()&#123; LoggerFactory = new SerilogLoggerFactory()&#125;); 运行项目即可以看到gRPC日志内容 异常服务端在gRPC抛出异常的时候，可以抛出RpcException来指定异常类型，RpcException示例里的trailer是一个Metadata，可以携带自定义的键值对，客户端捕获异常也可以捕获指定的RpcException，一样可以拿到trailer来获取自定义的键值对信息 关于JWT授权在通过授权接口获取到JWT Token之后，与普通HTTP请求类似，JWT Token也是放在头部与请求一起发送出去，只不过在RPC换了个名词，编程MetaData，其实是一样道理，用Authorization:Bearer {JWT Token}来进行发送即可 多项目之间共享proto文件 使用单独的Git仓库管理proto文件 使用submodule将proto文件集成到工程目录中 使用dotnet-grpc命令行添加proto文件及祥光依赖包引用 备注：由proto生成的代码文件会存放在obj目录中，不会被嵌入到Git仓库","categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/categories/ASP-NET-Core/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"gRPC","slug":"gRPC","permalink":"http://www.dimsum.fun/tags/gRPC/"}]},{"title":"MediatR：轻松实现命令查询职责分离模式(CQRS)","slug":"21.MediatR_document","date":"2020-04-15T07:00:00.000Z","updated":"2020-04-15T15:49:20.106Z","comments":true,"path":"2020/04/15/21.MediatR_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/15/21.MediatR_document/","excerpt":"","text":"一对一 核心对象 代码展示 创建命令和处理者存放路径 创建命令 创建命令处理者 发送命令 运行代码 一对多 核心对象 代码实现 创建事件和事件处理者存放路径 创建事件 创建事件处理者 修改Program 运行代码 一对一核心对象 IMediator IRequest 、IRequest&lt;T&gt; IResuestHandler&lt;in TRequest,TResponse&gt; 代码展示创建名字为MediatorDemo的控制台应用，通过nuget引入以下三个包： 123MediatRMediatR.Extensions.Microsoft.DependencyInjectionMicrosoft.Extensions.DependencyInjection 创建命令和处理者存放路径在根目录创建以下两个文件夹： 12CommandsCommandHandlers 创建命令在Commands文件夹中创建MyCommand.cs，内容如下 1234567891011121314using MediatR;namespace MediatorDemo.Commands&#123; public class MyDemoCommand:IRequest&lt;string&gt; &#123; public string Data &#123; get; &#125; public MyDemoCommand(string data) &#123; Data = data; &#125; &#125;&#125; 创建命令处理者在CommandHandlers文件夹中创建MyDemoCommandHandler.cs，内容如下： 12345678910111213141516using System.Threading;using System.Threading.Tasks;using MediatorDemo.Commands;using MediatR;namespace MediatorDemo.CommandHandlers&#123; public class MyDemoCommandHandler:IRequestHandler&lt;MyDemoCommand,string&gt; &#123; public async Task&lt;string&gt; Handle(MyDemoCommand request, CancellationToken cancellationToken) &#123; await Task.CompletedTask; return $\"Hello from MyDemoCommandHandler.Handler -&gt; command data = &#123;request.Data&#125;\"; &#125; &#125;&#125; 发送命令修改Program.cs，具体内容如下： 1234567891011121314151617181920212223using System;using System.Threading.Tasks;using MediatorDemo.CommandHandlers;using MediatR;using Microsoft.Extensions.DependencyInjection;namespace MediatorDemo&#123; class Program &#123; static async Task Main(string[] args) &#123; var service = new ServiceCollection(); service.AddMediatR(typeof(Program).Assembly); var serviceProvider = service.BuildServiceProvider(); var mediator = serviceProvider.GetService&lt;IMediator&gt;(); var rsp = await mediator.Send(new MyDemoCommand(\"This is my demo command\")); Console.WriteLine(rsp); &#125; &#125;&#125; 解释代码： 通过var service = new ServiceCollection();创建服务容器 service.AddMediatR(typeof(Program).Assembly);是想服务容器注册MediatR组件，同时指定MediatR扫描当前Program所在的程序集，获得当前程序集里的所有Command和Handler(通过接口约束) var mediator = serviceProvider.GetService&lt;IMediator&gt;();从服务容器中获取mediator对象 var rsp = await mediator.Send(new MyDemoCommand(&quot;This is my demo command&quot;));发送一条MyDemoCommand命令 运行代码运行代码之后可以看到控制台打印以下信息： 1Hello from MyDemoCommandHandler.Handler -&gt; command data &#x3D; This is my demo command 可以看到Program并没有直接去引用MyDemoCommandHandler这个类，只是向MediatR发送了一条指定的命令，MediatR框架会自动去查找该命令对应的Handler，调用Handler里的Handle方法 注意：所谓一对一就是当你有对一个命令有多个Handler的时候，MediatR只会找到最后注册的那个来执行 一对多核心对象 IMediator INotification INotificationHandler&lt;in TNotification&gt; 代码实现创建事件和事件处理者存放路径在根目录创建以下两个文件夹： 12EventsEventHandlers 创建事件在Events文件夹中创建MyDemoEvent.cs，内容如下： 1234567891011121314using MediatR;namespace MediatorDemo.Events&#123; public class MyDemoEvent:INotification &#123; public string EventName &#123; get; &#125; public MyDemoEvent(string eventName) &#123; EventName = eventName; &#125; &#125;&#125; 创建事件处理者在EventHandlers文件夹中创建MyDemoEventHandler.cs，内容如下： 1234567891011121314151617181920212223242526using System;using System.Threading;using System.Threading.Tasks;using MediatorDemo.Events;using MediatR;namespace MediatorDemo.EventHandlers&#123; public class MyDemoEventHandler:INotificationHandler&lt;MyDemoEvent&gt; &#123; public async Task Handle(MyDemoEvent notification, CancellationToken cancellationToken) &#123; await Task.CompletedTask; Console.WriteLine($\"MyDemoEventHandler.Handle执行:&#123;notification.EventName&#125;\"); &#125; &#125; public class MyDemoEventHandlerV2 : INotificationHandler&lt;MyDemoEvent&gt; &#123; public async Task Handle(MyDemoEvent notification, CancellationToken cancellationToken) &#123; await Task.CompletedTask; Console.WriteLine($\"MyDemoEventHandlerV2.Handle执行:&#123;notification.EventName&#125;\"); &#125; &#125;&#125; 这里是一个cs文件中写了两个Handler 修改Program在原有的Main方法最后面添加以下代码： 1await mediator.Publish(new MyDemoEvent(\"MyEvent\")); 运行代码运行项目可以看到以下信息： 123Hello from MyDemoCommandHandler.Handler -&gt; command data &#x3D; This is my demo commandMyDemoEventHandler.Handle执行:MyEventMyDemoEventHandlerV2.Handle执行:MyEvent 其中后面两行分别为两个事件处理者打印出来的","categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/categories/ASP-NET-Core/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"DDD","slug":"DDD","permalink":"http://www.dimsum.fun/tags/DDD/"},{"name":"CQRS","slug":"CQRS","permalink":"http://www.dimsum.fun/tags/CQRS/"},{"name":"MediatR","slug":"MediatR","permalink":"http://www.dimsum.fun/tags/MediatR/"}]},{"title":"EntityFramework Core的并发处理","slug":"20.EFCore_Concurrency_document","date":"2020-04-10T08:21:00.000Z","updated":"2020-04-10T10:31:51.922Z","comments":true,"path":"2020/04/10/20.EFCore_Concurrency_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/10/20.EFCore_Concurrency_document/","excerpt":"","text":"什么叫并发 怎么解决 EFCore是怎么做的 Talk is cheap. Show me the code 创建项目 创建数据库实体 配置实体映射规则(这里指定锁) 创建DbContext 修改Startup 添加数据库连接字符串 添加测试控制器 迁移数据库 测试 官方文档 什么叫并发假设一个场景： 用户下了一个单，数据库的Order表存放这个订单数据，其中订单状态=待发货 仓库从数据库中查询出这个代发货订单，进行发货逻辑处理，比如： 判断订单状态 判断地址是否能到达 查询商品库存 获取快递单号 调用打印快递单服务 更新订单状态/商品库存等等 可以看出做发货逻辑处理耗时会比较长，正在这时候，顾客进行了退货申请，一个按钮点击申请退款，注意：业务逻辑要求已发货的订单不能申请退款，但是在顾客点击申请退款那一瞬间，发货流程还没走完，发货系统还在屁颠屁颠的处理发货逻辑，数据库里的订单状态还是待发货，这时候顾客申请退款，接口一下数据库，发现是待发货，就直接将数据库里的订单状态更新为申请退款，并反馈给用户操作成功 这时候苦逼的发货系统终于把所有发货逻辑全部计算完，兴高采烈得将数据库里得订单状态修改为已发货 那么请问，最终这个订单的状态应该是什么呢？待发货？申请退款？已发货？ 上面那个场景就是所谓的并发，多个地方在对同一条数据进行操作的时候，时常会出现这种情况 怎么解决锁！ 悲观锁：是的，相当悲观，对整个世界都不信任的那种！就是假设我读取的数据一定会被修改，所以读数据之前我先把这些数据锁起来，外界拿不到，等我对数据操作完，再把锁释放掉，外界才可以继续用这些数据； 乐观锁：相对来说乐观一些，读取数据的时候不对数据上锁，相信没人会来修改这些数据，但是在处理完数据要重新更新数据库的时候，不能盲目信任，要查一下这些数据有没有发生变化，如果变化了，则说明被别人修改了，于是悲伤的抛出个异常表示对这个世界的不满，如果没有变化，则正常的将数据更新进去； EFCore是怎么做的EFCore使用的是乐观锁，它选择相信这个世界！ EFCore的乐观锁分两种粒度：ConcurrencyToken和RowVersion ConcurrencyToken：这个针对表中的某个字段，为表中的某个字段指定为ConcurrencyToken，则当这个字段被并发修改了，则无法进行SaveChange，如果不是这个字段，而是这一行的其他字段被修改了，则可以正常进行SaveChange。以上面订单例子为例，如果将订单状态这个字段设置为ConcurrencyToken，那个在顾客申请退款之后，发货系统去更新订单状态则会失败，但是如果这个时候不是更新订单状态这个字段，而是更新发货员这个字段，则不会有任何影响，照样可以更新进去 RowVersion：这个针对表中的所有字段，指定表中某个字段为RowVersion，每一次更新都会修改RowVersion这个字段的值，在取出数据重新更新的时候，会查询RowVersion这个字段的值是否与刚刚取出来的值一致，如果不一致说明这个表中可能某个或多个字段被修改过，则无法进行SaveChange Talk is cheap. Show me the code创建项目创建名字为EFCoreConcurrencyDemo的ASP.NET Core项目，类型为API，这里使用的是Sql Server数据库，所有需要引入以下3个包： 123Microsoft.EntityFrameworkCore.SqlServerMicrosoft.EntityFrameworkCore.DesignMicrosoft.EntityFrameworkCore.Tools 创建数据库实体在项目根目录创建以下路径和文件： 123456|--EFCoreConcurrencyDemo |-- DbModel |-- ConcurrencyCheckDemo |-- ConcurrencyCheckDemo.cs |-- RowVersionDemo |-- RowVersionDemo.cs ConcurrencyCheckDemo.cs的内容如下： 1234567891011namespace EFCoreConcurrencyDemo.DbModel.ConcurrencyCheckDemo&#123; public class ConcurrencyCheckDemo &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; &#125;&#125; RowVersionDemo.cs的内容如下： 12345678910111213namespace EFCoreConcurrencyDemo.DbModel.RowVersionDemo&#123; public class RowVersionDemo &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public byte[] RowVersion &#123; get; set; &#125; &#125;&#125; 配置实体映射规则(这里指定锁)在项目根目录创建以下路径和文件 1234|--EFCoreConcurrencyDemo |-- DbModelConfiguration |-- ConcurrencyCheckDemoConfiguration.cs |-- RowVersionDemoConfiguration.cs ConcurrencyCheckDemoConfiguration.cs的内容如下： 123456789101112131415using EFCoreConcurrencyDemo.DbModel.ConcurrencyCheckDemo;using Microsoft.EntityFrameworkCore;using Microsoft.EntityFrameworkCore.Metadata.Builders;namespace EFCoreConcurrencyDemo.DbModelConfiguration&#123; public class ConcurrencyCheckDemoConfiguration : IEntityTypeConfiguration&lt;ConcurrencyCheckDemo&gt; &#123; public void Configure(EntityTypeBuilder&lt;ConcurrencyCheckDemo&gt; builder) &#123; builder.ToTable(\"ConcurrencyCheckDemo\"); builder.Property(x =&gt; x.Name).IsConcurrencyToken(); //并发令牌 &#125; &#125;&#125; RowVersionDemoConfiguration.cs的内容如下： 123456789101112131415using EFCoreConcurrencyDemo.DbModel.RowVersionDemo;using Microsoft.EntityFrameworkCore;using Microsoft.EntityFrameworkCore.Metadata.Builders;namespace EFCoreConcurrencyDemo.DbModelConfiguration&#123; public class RowVersionDemoConfiguration: IEntityTypeConfiguration&lt;RowVersionDemo&gt; &#123; public void Configure(EntityTypeBuilder&lt;RowVersionDemo&gt; builder) &#123; builder.ToTable(\"RowVersionDemo\"); builder.Property(x =&gt; x.RowVersion).IsRowVersion(); //行版本 &#125; &#125;&#125; 创建DbContext在项目根目录创建以下路径和文件 123|--EFCoreConcurrencyDemo |-- DbContext |-- MyDbContext.cs MyDbContext.cs的内容如下： 123456789101112131415161718192021222324using EFCoreConcurrencyDemo.DbModel.ConcurrencyCheckDemo;using EFCoreConcurrencyDemo.DbModel.RowVersionDemo;using EFCoreConcurrencyDemo.DbModelConfiguration;using Microsoft.EntityFrameworkCore;namespace EFCoreConcurrencyDemo.DbContext&#123; public class MyDbContext:Microsoft.EntityFrameworkCore.DbContext &#123; public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options):base(options) &#123; &#125; public DbSet&lt;ConcurrencyCheckDemo&gt; ConcurrencyCheckDemos &#123; get; set; &#125; public DbSet&lt;RowVersionDemo&gt; RowVersionDemos &#123; get; set; &#125; protected override void OnModelCreating(ModelBuilder modelBuilder) &#123; modelBuilder.ApplyConfiguration(new ConcurrencyCheckDemoConfiguration()); modelBuilder.ApplyConfiguration(new RowVersionDemoConfiguration()); &#125; &#125;&#125; 修改Startup修改Startup.ConfigureServices方法，具体内容如下： 123456789public void ConfigureServices(IServiceCollection services)&#123; services.AddDbContext&lt;MyDbContext&gt;(options =&gt; &#123; options.UseSqlServer(Configuration.GetConnectionString(\"EFCoreConcurrencyDemo\")); options.EnableSensitiveDataLogging(false); &#125;); services.AddControllers();&#125; 添加数据库连接字符串在appsettings.json中添加数据库连接字符串，具体内容如下（连接字符串就换成你自己的数据库）： 12345678910111213&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125; &#125;, \"ConnectionStrings\": &#123; \"EFCoreConcurrencyDemo\": \"Password=jiamiao.x.20.demo;Persist Security Info=True;User ID=sa;Initial Catalog=EFCoreConcurrencyDemo;Data Source=127.0.0.1\" &#125;, \"AllowedHosts\": \"*\"&#125; 添加测试控制器在Controllers中添加DemoController.cs，具体内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System.Threading.Tasks;using EFCoreConcurrencyDemo.DbContext;using EFCoreConcurrencyDemo.DbModel.ConcurrencyCheckDemo;using EFCoreConcurrencyDemo.DbModel.RowVersionDemo;using Microsoft.AspNetCore.Mvc;using Microsoft.EntityFrameworkCore;namespace EFCoreConcurrencyDemo.Controllers&#123; [Route(\"[controller]/[action]\")] [ApiController] public class DemoController : ControllerBase &#123; private readonly MyDbContext _dbContext; public DemoController(MyDbContext dbContext) &#123; _dbContext = dbContext; &#125; public async Task&lt;int&gt; SeedData() &#123; var concurrencyCheckDemo = new ConcurrencyCheckDemo() &#123; Name = \"ConcurrencyCheck测试\", Age = 20 &#125;; await _dbContext.ConcurrencyCheckDemos.AddAsync(concurrencyCheckDemo); var rowVersionDemo = new RowVersionDemo() &#123; Name = \"RowVersion测试\", Age = 24 &#125;; await _dbContext.RowVersionDemos.AddAsync(rowVersionDemo); var changedRow = await _dbContext.SaveChangesAsync(); return changedRow; &#125; public async Task&lt;int&gt; ConcurrencyCheck() &#123; var dbValue = await _dbContext.ConcurrencyCheckDemos.FirstOrDefaultAsync(); //dbValue.Name = \"ConcurrencyCheck New Value\"; dbValue.Age = 29; var changedRow = await _dbContext.SaveChangesAsync(); return changedRow; &#125; public async Task&lt;int&gt; RowVersionCheck() &#123; var dbValue = await _dbContext.RowVersionDemos.FirstOrDefaultAsync(); //dbValue.Name = \"RowVersion New Value\"; dbValue.Age = 36; var changedRow = await _dbContext.SaveChangesAsync(); return changedRow; &#125; &#125;&#125; 迁移数据库在Visual Studio 2019中的程序包管理控制台中输入以下命令： 1add-migration InitDemoDb 得到迁移记录之后，用以下命令生成数据库脚本，去Microsoft SQL Server Management Studio中执行即可，或者你可以用EFCore中的update命令直接迁移 1script-migration 测试 这里提供测试思路，将项目运行起来，先访问/demo/SeedData往数据库写入两条测试数据 分别测试/demo/ConcurrencyCheck和/demo/RowVersionCheck，在赋值的那行代码打断点，取得数据之后，自己在Microsoft SQL Server Management Studio中手动修改数据，然后继续运行代码，则可以看出效果 官方文档 https://docs.microsoft.com/zh-cn/ef/core/saving/concurrency","categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/categories/ASP-NET-Core/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"EntityFramework Core","slug":"EntityFramework-Core","permalink":"http://www.dimsum.fun/tags/EntityFramework-Core/"},{"name":"ORM","slug":"ORM","permalink":"http://www.dimsum.fun/tags/ORM/"}]},{"title":"ASP.NET Core发布到Docker中(使用Dockerfile)","slug":"19.Docker_AspNetCore_document","date":"2020-04-09T07:49:00.000Z","updated":"2020-04-09T09:20:56.918Z","comments":true,"path":"2020/04/09/19.Docker_AspNetCore_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/09/19.Docker_AspNetCore_document/","excerpt":"","text":"ASP.NET Core的常用命令 Dockerfile中的命令 FROM WORKDIR COPY RUN ENTRYPOINT 具体操作 创建项目 创建Dockerfile文件 编写Dockerfile文件 生成镜像 ASP.NET Core的常用命令在使用VS 2019、VSCode、Rider这类IDE写完代码之后，在命令行进入项目目录，尝试使用以下命令来恢复、编译、发布、运行项目 恢复所有的NuGet包1dotnet restore [项目名.csproj] 这里的项目文件可以省略，自己在命令行中执行可以省略，但是如果将命令写到文件中，为了方便理解，一般会将项目文件写上 编译1dotnet build [项目名.csproj] -c Release -o /app/build 项目文件解释参照上面 -c 表示编译配置，这里指定编译配置为Release -o 表示编译后文件输出到哪个目录，这里指定编译后输出目录为/app/build 发布1dotnet publish [项目名.csproj] -c Release -o /app/publish 命令参数与编译的参数基本一致 运行在生成发布文件的目录里运行1dotnet [项目名称.dll] Dockerfile中的命令为了快速看到效果，这里只是列举了下面简单示例使用到的命令 FROM指定运行是镜像，例如FROM mcr.microsoft.com/dotnet/core/aspnet:3.1，后面用AS命令可以在执行命令时给镜像起别名，例如FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS base，即表示将mcr.microsoft.com/dotnet/core/aspnet:3.1这个镜像起别名为base 当需要多个镜像的时候，可多次使用这个命令 WORKDIR设定工作目录，类似命令行中的cd命令，设定之后后续的命令相当于在工作目录中运行 COPY拷贝文件，这个命令可以拷贝当前宿主机的文件，也可以拷贝上面那种引用多个镜像进行编译的文件到当前镜像 拷贝宿主机文件1COPY . ./ 表示拷贝当前文件夹的所有文件到镜像中的当前文件夹，一般在执行这个命令之前会设置好工作目录，表示将宿主机当前文件夹中的所有文件拷贝到镜像中的工作目录中 拷贝其他镜像文件1COPY --from=build /app/publish . 使用--from=build表示从build的镜像中拷贝文件，这里的build是引入镜像时指定的别名，/app/publish是build镜像的文件路径，最后一个.是指要拷贝到当前镜像来的目录，.表示当前路径，一般也是配合WORKDIR使用RUN执行命令，构建镜像的时候需要安装其他软件或者编译文件的命令在这里执行，多条命令可以用&amp;&amp;来连接，以发布ASP.NET Core项目为例，将代码拷贝到镜像之后，需要进行restore、build、publish，就可以在这里使用，例如：1RUN dotnet restore \"./Jiamiao.x.ServiceA.csproj\" &amp;&amp; dotnet build \"./Jiamiao.x.ServiceA.csproj\" -c Release -o /app/build &amp;&amp; dotnet publish \"./Jiamiao.x.ServiceA.csproj\" -c Release -o /app/publish ENTRYPOINT一样是执行命令，但是这里是容器启动的时候要执行的命令，比如上面那些恢复、编译、发布的命令就不能在这里执行，因为容器启动的时候是不用做这些操作的，作为容器启动，只需要启动站点即可，所以这里使用的是运行命令，所以每个Dockerfile只有一个ENTRYPOINT，多个ENTRYPOINT后面会覆盖前面1ENTRYPOINT [ &quot;dotnet&quot;,&quot;Jiamiao.x.ServiceA.dll&quot; ] 上面的命令等于在命令行执行dotnet Jiamiao.x.ServiceA.dll这个命令 具体操作创建项目创建名字为Jiamiao.x.ServiceA的ASP.NET Core项目，类型为API，这里只是做发布测试，所以不需要动任何代码 创建Dockerfile文件这里使用VSCode为例，在VSCode中安装Docker扩展，如下图 按Ctrl + Shift + P，打开控制面板，输入add docker，选择Docker:Add Docker Files To Workspace，如下图 选择.NET:ASP.NET Core，如下图 选择Linux，如下图 选择No，如下图 默认输入80, 443保持不变，回车即可生成Dockerfile文件 好了！这里的文件内容不是我们想要的，直接删掉Dockerfile里的文件内容即可，我们主要是要自动生成一个.dockerignore文件 编写Dockerfile文件确定以下思路，这里需要将代码拷贝进容器进行编译发布，然后再将发布好的文件拷贝到运行时的镜像中，容器运行时启动站点，具体代码如下： 12345678910111213141516# 指定运行是镜像FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS baseWORKDIR /app# 指定编译和发布镜像FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build# 设置工作目录为srcWORKDIR /src# 拷贝所有文件到容器中的工作目录COPY . ./RUN dotnet restore \"./Jiamiao.x.ServiceA.csproj\" &amp;&amp; dotnet build \"./Jiamiao.x.ServiceA.csproj\" -c Release -o /app/build &amp;&amp; dotnet publish \"./Jiamiao.x.ServiceA.csproj\" -c Release -o /app/publishFROM base as finalWORKDIR /appCOPY --from=build /app/publish .ENTRYPOINT [ \"dotnet\",\"Jiamiao.x.ServiceA.dll\" ] 这里使用了两个镜像，一个是编译发布用的mcr.microsoft.com/dotnet/core/sdk:3.1简称为build，一个是运行时用的mcr.microsoft.com/dotnet/core/aspnet:3.1简称base 生成镜像在项目根目录，即Dockerfile所在目录运行预下命令 1docker build -t xiejiamiao/aspnetcore . 其中xiejiamiao/aspnetcore为镜像名字，后面的.表示使用当前目录的Dockerfile。如果生成成功，使用docker images应该就可以看到刚刚生成的镜像，执行以下命令启动容器 1docker run -d -p 8080:80 xiejiamiao&#x2F;aspnetcore --name ASPNETCore-X -d表示后台运行容器 8080:80是指将宿主机的8080端口映射到容器中的80端口 xiejiamiao/aspnetcore为镜像的名字 ASPNETCore-X为镜像运行起来的容器的名字容器启动成功后，访问http://127.0.0.1:8080/WeatherForecast应该就可以看到返回一些json","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.dimsum.fun/categories/Docker/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"Docker","slug":"Docker","permalink":"http://www.dimsum.fun/tags/Docker/"}]},{"title":".NET Core开发实战课程备忘(18) -- 微服务之工程结构概览：定义应用分层及依赖关系","slug":"18.MicroService01_document","date":"2020-04-07T10:18:00.000Z","updated":"2020-04-09T09:20:56.918Z","comments":true,"path":"2020/04/07/18.MicroService01_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/07/18.MicroService01_document/","excerpt":"","text":"分层 总结 分层 领域模型层Domain：定义领域模型的地方，这里面会有不同的聚合、领域事件，其中不同的聚合下面就是领域模型 基础设施层Infrastructure：仓储层和一些共享代码的实现、领域模型与数据库之间的映射关系 应用层Application：API和后台任务 Web API也分类一些目录： Application：项目使用了CQRS模式，即命令与查询职责分离，所以我们会把命令放在一个目录，查询放在一个目录，还有两个事件处理的目录，一个是领域模型中领域事件的处理，一个是集成事件的处理 Controllers：主要就是定义Web Extensions：将服务注册进容器的代码和中间件配置的代码，就是ServiceCollection和ApplicationBuilder的扩展 Infrastructure：身份认证、缓存等与基础设施交互的代码 共享层Share GeekTime.Core –主要是承载基础简单的类型，比如自定义异常类，一下帮助类 GeekTime.Domain.Abstractions –领域抽象层，定义领域模型的一些基类、接口、领域事件的接口、领域事件处理的接口、Entity的接口和Entity的基类 GeekTime.Infrastructure.Core –基础设施核心层，可以仓储和EFContext定义一些共享的代码 共享层的代码是在所有项目里面都可以共享的，所有建议的做法是把这些代码通过私有的NuGet仓库来存储，然后其他工程可以使用NuGet包来直接引用即可 各层之间的依赖关系： 共享层：这个层不依赖解决方案中其他层 GeekTime.Core：不依赖任何其他工程 GeekTime.Domain.Abstractions：不依赖任何其他工程 GeekTime.Infrastructure.Core：依赖领域模型的抽象层GeekTime.Domain.Abstractions 领域模型层： 我们的领域模型是需要继承我们定义的模型基类，并且实现一个聚合根的接口，表示它是一个聚合根 领域事件就需要我们实现一个领域事件的机口 基础设施层： 定义仓储和仓储的实现，仓储的定义实际上依赖了基础设施核心层GeekTime.Infrastructure.Core里的仓储定义，这样就能复用仓储层的代码 数据库访问的实现：继承了我们自己定义的EFContext 事务处理的对象：这个对象是来管理我们整个应用程序的请求上下文的事务，这样就可以让我们避免去手动的处理事务，简化我们的代码 应用层： 依赖基础设施层，基础设施层又依赖领域层，应用层实际上是把各层组装在一起的一层，它是我们应用程序的一个宿主，我们协调各层之间的关系，以及组装的代码都在这里实现 总结 领域模型专注业务的实现，不依赖仓储等基础设施层 基础设置的仓储层仅负责领域模型的取出和存储 使用CQRS模型设计应用层 Web API是面向前端的交互接口，避免依赖领域模型 将共享代码设计为共享包，使用私有NuGet仓库来分发管理","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"},{"name":"微服务","slug":"微服务","permalink":"http://www.dimsum.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":".NET Core开发实战课程备忘(14) -- 异常处理中间件：区分真异常与逻辑一场","slug":"14.Exception_document","date":"2020-04-02T14:17:00.000Z","updated":"2020-05-14T14:56:30.036Z","comments":true,"path":"2020/04/02/14.Exception_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/14.Exception_document/","excerpt":"","text":"处理异常的方式 代码实现 创建项目 注释掉系统自带的异常处理中间件 创建自定义的异常类 为什么要创建自定义的异常类 自定义异常类 异常处理页代码实现 异常处理匿名委托方法代码实现 IExceptionFilter代码实现 ExceptionFilterAttribute代码实现 总结 处理异常的方式 异常处理页 异常处理匿名委托方法 IExceptionFilter ExceptionFilterAttribute 代码实现创建项目创建名字为ExceptionDemo的ASP.NET Core项目，类型为API 注释掉系统自带的异常处理中间件在Startup.Configure中有app.UseDeveloperExceptionPage();这个中间件，这个就是ASP.NET Core自带的一个异常处理页，但是这个页面错误信息太多，只适合开发时对开发人员进行提示，不适合放到生产环境，所以这里注释掉这个中间件 创建自定义的异常类为什么要创建自定义的异常类通常情况下我们系统里面的异常与我们业务逻辑里的异常是不同的，业务逻辑上的判断异常，比如输入的参数不合法、订单状态不符合条件，当前账户余额不足这样的错误信息，我们有两种处理方式，一种处理方式是对不同的逻辑输出不同的业务对象，还有一种方式就是对于这种业务逻辑输出一个异常，用异常来承载我们的逻辑的特殊分支，那这个时候我们就需要识别出哪些是我们的业务异常，哪些是我们不确定的未知异常，比如网络突发的无法连接、MySql的闪断之类的 那这里怎么识别出哪些是业务异常，哪些是未知异常？ 首先通过定义一个接口，接口里有错误码和错误信息，当我们有一个业务出现异常，我们可以人为的抛出一个已经实现了这个接口的自定义异常类。然后在异常处理过程中，我们尝试将捕获到的异常转为我们定义的异常接口，如果能转成功，说明这个异常是我们认为抛出的业务异常，否则为系统抛出的未知异常 自定义异常类在项目根目录创建文件夹Exceptions，所有异常的自定义类都放在这里 创建IKnownException接口，具体代码如下： 1234567891011namespace ExceptionDemo.Exceptions&#123; public interface IKnownException &#123; string Message &#123; get; &#125; int ErrorCode &#123; get; &#125; object[] ErrorData &#123; get; &#125; &#125;&#125; 创建KnownException类，具体代码如下： 1234567891011121314151617181920212223namespace ExceptionDemo.Exceptions&#123; public class KnownException:IKnownException &#123; public KnownException(object[] errorData, int errorCode, string message) &#123; ErrorData = errorData; ErrorCode = errorCode; Message = message; &#125; public string Message &#123; get; &#125; public int ErrorCode &#123; get; &#125; public object[] ErrorData &#123; get; &#125; public static readonly IKnownException UnKnown = new KnownException(errorData: new object[] &#123; &#125;, errorCode: 9999, message: \"未知错误\"); public static IKnownException FromKnownException(IKnownException exception) &#123; return new KnownException(errorData: exception.ErrorData, errorCode: exception.ErrorCode, message: exception.Message); &#125; &#125;&#125; 创建测试用的InvalidParameterException类，用来模拟参数错误的异常，具体代码如下： 12345678910111213141516using System;namespace ExceptionDemo.Exceptions&#123; public class InvalidParameterException: Exception,IKnownException &#123; public InvalidParameterException(int errorCode, string message, params object[] errorData) : base(message) &#123; ErrorCode = errorCode; ErrorData = errorData; &#125; public int ErrorCode &#123; get; &#125; public object[] ErrorData &#123; get; &#125; &#125;&#125; 异常处理页代码实现创建处理页面控制器ErrorController，在Index方法中获取到当前请求上下文的异常信息，并尝试进行转成IKnownException，如果转成功则表示为业务逻辑异常，如果失败则表示为未知异常，未知异常则通过KnownException的静态方法生成一个特定的未知异常对象，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637using ExceptionDemo.Exceptions;using Microsoft.AspNetCore.Diagnostics;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Controllers&#123; public class ErrorController : Controller &#123; private readonly ILogger&lt;ErrorController&gt; _logger; public ErrorController(ILogger&lt;ErrorController&gt; logger) &#123; _logger = logger; &#125; [Route(\"/error\")] public IActionResult Index() &#123; var exceptionHandlerPathFeature = HttpContext.Features.Get&lt;IExceptionHandlerPathFeature&gt;(); var ex = exceptionHandlerPathFeature?.Error; var knownException = ex as IKnownException; if (knownException == null) &#123; _logger.LogError(ex,ex.Message); knownException = KnownException.UnKnown; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); &#125; return View(knownException); &#125; &#125;&#125; 对应的试图Index.cshtml代码如下： 1234567891011121314151617@model ExceptionDemo.Exceptions.IKnownException@&#123; Layout = null;&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;title&gt;Index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;错误码：@Model.ErrorCode&lt;/p&gt; &lt;p&gt;错误信息：@Model.Message&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 回到Startup，对ConfigureServices和Configure两个方法做出调整，具体代码如下： 12345678910111213141516public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; app.UseExceptionHandler(\"/error\"); app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 切换到WeatherForecastController，在这里来主动抛出异常，将Get方法修改如下： 12345[HttpGet]public IEnumerable&lt;WeatherForecast&gt; Get()&#123; throw new InvalidParameterException(65, \"参数有误\", new List&lt;string&gt;() &#123;\"exception info 1\",\"exception info 2\" &#125;);&#125; 运行代码，访问/weatherforecast，可以看到返回了以下 123错误码：65错误信息：参数有误 将WeatherForecastController.Get里的异常换成一个普通的异常，在重新运行代码，可以看到页面会变成未知错误的提示，同时控制台打印出来的日志是完全的异常日志 异常处理匿名委托方法代码实现将Startup.Configure方法中的app.UseExceptionHandler(&quot;/error&quot;);注释掉，原位置新增以下代码： 123456789101112131415161718192021222324app.UseExceptionHandler(errApp =&gt;&#123; errApp.Run(async context =&gt; &#123; var exceptionHandlerPathFeature = context.Features.Get&lt;IExceptionHandlerPathFeature&gt;(); var knownException = exceptionHandlerPathFeature.Error as IKnownException; if (knownException == null) &#123; var logger = context.RequestServices.GetService&lt;ILogger&lt;Startup&gt;&gt;(); logger.LogError(exceptionHandlerPathFeature.Error, exceptionHandlerPathFeature.Error.Message); knownException = KnownException.UnKnown; context.Response.StatusCode = StatusCodes.Status500InternalServerError; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); context.Response.StatusCode = StatusCodes.Status200OK; &#125; var jsonOptions = context.RequestServices.GetService&lt;IOptions&lt;JsonOptions&gt;&gt;(); context.Response.ContentType = \"application/json; charset=utf-8\"; await context.Response.WriteAsync(JsonSerializer.Serialize(knownException, jsonOptions.Value.JsonSerializerOptions)); &#125;);&#125;); 这里的操作与异常处理页逻辑差不多，只是不再返回视图，而是返回json，同时设定好业务逻辑异常返回200状态码，未知异常返回500状态码(这样做的好处后面说明)，运行代码，访问/weatherforecast，通过修改抛出异常，可看到对应的返回结果 IExceptionFilter代码实现在Exceptions文件夹新建MyExceptionFilter.cs，具体代码如下： 123456789101112131415161718192021222324252627282930313233using Microsoft.AspNetCore.Http;using Microsoft.AspNetCore.Mvc;using Microsoft.AspNetCore.Mvc.Filters;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Exceptions&#123; public class MyExceptionFilter:IExceptionFilter &#123; public void OnException(ExceptionContext context) &#123; var knownException = context.Exception as IKnownException; if (knownException == null) &#123; var logger = context.HttpContext.RequestServices.GetService&lt;ILogger&lt;MyExceptionFilter&gt;&gt;(); logger.LogError(context.Exception,context.Exception.Message); knownException = KnownException.UnKnown; context.HttpContext.Response.StatusCode = StatusCodes.Status500InternalServerError; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); context.HttpContext.Response.StatusCode = StatusCodes.Status200OK; &#125; context.Result = new JsonResult(knownException) &#123; ContentType = \"application/json; charset=utf-8\" &#125;; &#125; &#125;&#125; 这里对异常的处理逻辑与异常处理匿名委托方法一样 修改Startup的ConfigureServices、Configure，具体代码如下： 12345678910111213141516171819public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews(options =&gt; &#123; options.Filters.Add&lt;MyExceptionFilter&gt;(); &#125;).AddJsonOptions( options =&gt; &#123; options.JsonSerializerOptions.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping; &#125;);&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 运行代码，访问/weatherforecast，通过修改抛出异常，可看到对应的返回结果 ExceptionFilterAttribute代码实现在Exceptions中新建MyExceptionFilterAttribute.cs，具体代码如下： 123456789101112131415161718192021222324252627282930313233using Microsoft.AspNetCore.Http;using Microsoft.AspNetCore.Mvc;using Microsoft.AspNetCore.Mvc.Filters;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Exceptions&#123; public class MyExceptionFilterAttribute : ExceptionFilterAttribute &#123; public override void OnException(ExceptionContext context) &#123; var knownException = context.Exception as IKnownException; if (knownException == null) &#123; var logger = context.HttpContext.RequestServices.GetService&lt;ILogger&lt;MyExceptionFilterAttribute&gt;&gt;(); logger.LogError(context.Exception, context.Exception.Message); knownException = KnownException.UnKnown; context.HttpContext.Response.StatusCode = StatusCodes.Status500InternalServerError; &#125; else &#123; knownException = KnownException.FromKnownException(knownException); context.HttpContext.Response.StatusCode = StatusCodes.Status200OK; &#125; context.Result = new JsonResult(knownException) &#123; ContentType = \"application/json; charset=utf-8\" &#125;; &#125; &#125;&#125; 修改Startup的ConfigureServices、Configure，具体代码如下： 1234567891011121314public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 在WeatherForecastController中添加类特性，具体代码如下： 12345678910111213141516171819202122232425262728293031using System.Collections.Generic;using ExceptionDemo.Exceptions;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace ExceptionDemo.Controllers&#123; [ApiController] [Route(\"[controller]\")] [MyExceptionFilter] public class WeatherForecastController : ControllerBase &#123; private static readonly string[] Summaries = new[] &#123; \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\" &#125;; private readonly ILogger&lt;WeatherForecastController&gt; _logger; public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger) &#123; _logger = logger; &#125; [HttpGet] public IEnumerable&lt;WeatherForecast&gt; Get() &#123; throw new InvalidParameterException(65, \"参数有误！！！\", new List&lt;string&gt;() &#123;\"exception info 1\",\"exception info 2\" &#125;); &#125; &#125;&#125; 运行代码，访问/weatherforecast，通过修改抛出异常，可看到对应的返回结果 总结 用特定的异常类或接口表示业务逻辑异常 为业务逻辑异常定义全局错误码 为未知异常定义特定的输出信息和错误码，不应该输出系统内部的异常堆栈 对已知的业务逻辑异常相应HTTP 200，这样对监控系统友好，不会区分不开真异常和逻辑异常 对于未预见的异常相应HTTP 500 为所有异常记录详细的日志","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(13) -- 中间件：掌握请求处理过程的关键","slug":"13.Middleware_document","date":"2020-04-02T10:12:00.000Z","updated":"2020-04-02T17:11:23.323Z","comments":true,"path":"2020/04/02/13.Middleware_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/13.Middleware_document/","excerpt":"","text":"核心对象 代码实现 创建项目 直接注入委托 对特定路径注册特定中间件 对特定路径注册中间件升级版 使用扩展方法来注册中间件(最佳姿势) 核心对象 IApplicationBuilder：让我们注册我们自己的中间件 RequestDelegate：我们处理整个请求的委托 代码实现创建项目创建名字为MiddlewareDemo的ASP.NET Core项目，类型为API 直接注入委托Startup.Configure方法里，在app.UseHttpsRedirection()中间件之前添加以下代码： 12345app.Use(async (context, next) =&gt;&#123; await next(); await context.Response.WriteAsync(\"Hello world -- my middleware in delegate\");&#125;); 运行代码访问/WeatherForecast，可以看到原本的json后面会添加Hello world -- my middleware in delegate这句话 对特定路径注册特定中间件注释掉上面的代码，在原处新增以下代码 12345678app.Map(\"/abc\", builder =&gt;&#123; builder.Use(async (context, next) =&gt; &#123; await next(); await context.Response.WriteAsync(\"Hello world abc -- from map middleware\"); &#125;);&#125;); 运行代码访问/WeatherForecast，结果与初始项目运行一致，访问/abc，页面会返回Hello world abc -- from map middleware 对特定路径注册中间件升级版当这个特定路径的判断比较复杂，可以使用MapWhen来注册，注释掉上一步代码，在原处新增以下代码： 12345678app.MapWhen(context =&gt; &#123; return context.Request.Query.Keys.Contains(\"abc\"); &#125;, builder =&gt;&#123; builder.Use(async (context, next) =&gt; &#123; await next(); await context.Response.WriteAsync(\"Hello world query abc -- from mapWhen middleware\"); &#125;);&#125;); 这里表示当url参数里包含abc这个函数，则触发指定的中间件，运行代码，运行代码访问/WeatherForecast，结果与初始项目运行一致，访问/WeatherForecast?abc=aaa，会在原有的返回结果后面添加Hello world query abc -- from mapWhen middleware 使用扩展方法来注册中间件(最佳姿势)自定义中间件是按约定来调用的，即中间件里需要包含一个InvokeAsync方法，方法参数为HttpContext，通常中间件不直接对外暴露，所以类的访问修饰符通常是默认的internal，然后通过IApplicationBuilder的扩展方法向外暴露 在根目录创建文件夹Middlewares/MyMiddleware，在目录下创建两个文件MyMiddleware.cs和MyMiddlewareExtension.cs，具体代码如下： MyMiddleware.cs代码： 12345678910111213141516171819202122232425262728293031using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using Microsoft.AspNetCore.Http;using Microsoft.Extensions.Logging;namespace MiddlewareDemo.Middlewares.MyMiddleware&#123; class MyMiddleware &#123; private readonly RequestDelegate _next; private readonly ILogger&lt;MyMiddleware&gt; _logger; public MyMiddleware(RequestDelegate next,ILogger&lt;MyMiddleware&gt; logger) &#123; _next = next; _logger = logger; &#125; public async Task InvokeAsync(HttpContext context) &#123; using (_logger.BeginScope(\"TraceIdentifier:&#123;TraceIdentifier&#125;\",context.TraceIdentifier)) &#123; _logger.LogDebug(\"开始执行MyMiddleware中间件\"); await _next(context); _logger.LogDebug(\"执行MyMiddleware中间件结束\"); &#125; &#125; &#125;&#125; MyMiddlewareExtension.cs代码： 123456789101112using Microsoft.AspNetCore.Builder;namespace MiddlewareDemo.Middlewares.MyMiddleware&#123; public static class MyMiddlewareExtension &#123; public static IApplicationBuilder UseMyMiddleware(this IApplicationBuilder app) &#123; return app.UseMiddleware&lt;MyMiddleware&gt;(); &#125; &#125;&#125; 因为这里使用了日志作用域，所以还需要到appsettings.json里修改以下日志配置，具体内容如下： 12345678910111213141516&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Trace\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"IncludeScopes\": true, \"LogLevel\": &#123; \"MiddlewareDemo.Middlewares.MyMiddleware.MyMiddleware\": \"Trace\" &#125; &#125; &#125;, \"AllowedHosts\": \"*\"&#125; 回到Startup.Configure，注释掉前面的测试代码，在原处新增以下代码： 1app.UseMyMiddleware(); 运行项目，访问/WeatherForecast，可以看到控制台打印出了对应的日志","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(17) -- 路由与终结点：如何规划好你的Web API","slug":"17.Routing_document","date":"2020-04-02T08:02:00.000Z","updated":"2020-04-03T08:34:59.335Z","comments":true,"path":"2020/04/02/17.Routing_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/17.Routing_document/","excerpt":"","text":"路由注册方式 路由模板的方式 RouteAttribute方式 路由约束 类型约束 范围约束 正则表达式 是否必选 自定义IRouteConstraint Url生成 LinkGenerator IUrlHelper 代码实现创建项目创建名字为RoutingDemo的ASP.NET Core项目，类型为API，为了方便演示，这里配置了swagger的组件，需要引入以下的包 1Swashbuckle.AspNetCore 然后右键项目名称-&gt;属性-&gt;生成-&gt;输出，勾选上XML文档文件 回到Startup.ConfigureServices方法，在services.AddControllers();后面新增以下代码： 1234567services.AddSwaggerGen(c =&gt;&#123; c.SwaggerDoc(\"v1\", new OpenApiInfo() &#123;Title = \"My API\", Version = \"v1\"&#125;); var xmlFile = $\"&#123;Assembly.GetExecutingAssembly().GetName().Name&#125;.xml\"; var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile); c.IncludeXmlComments(xmlPath);&#125;); 在Startup.Configure的if(env.IsDevelopment()){...}这个if判断后面，新增以下代码： 12app.UseSwagger();app.UseSwaggerUI(c =&gt; &#123; c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"My API V1\"); &#125;); 添加测试控制器新增控制器OrderController，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System;using Microsoft.AspNetCore.Mvc;using Microsoft.AspNetCore.Routing;namespace RoutingDemo.Controllers&#123; /// &lt;summary&gt; /// 订单控制器 /// &lt;/summary&gt; [Route(\"api/[controller]/[action]\")] [ApiController] public class OrderController : ControllerBase &#123; /// &lt;summary&gt; /// 订单是否存在 /// &lt;/summary&gt; /// &lt;param name=\"id\"&gt;必须可以转为long&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; //[HttpGet(\"&#123;id:MyRouteConstraint&#125;\")] [HttpGet(\"&#123;id:isLong&#125;\")] public bool OrderExist([FromRoute]string id) &#123; return true; &#125; /// &lt;summary&gt; /// 订单最大数量 /// &lt;/summary&gt; /// &lt;param name=\"id\"&gt;最大20&lt;/param&gt; /// &lt;param name=\"linkGenerator\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpGet(\"&#123;id:max(20)&#125;\")] public bool Max(long id, [FromServices] LinkGenerator linkGenerator) &#123; var a = linkGenerator.GetPathByAction(\"Reque\", \"Order\"); return true; &#125; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;para name=\"ss\"&gt;必填&lt;/para&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpGet(\"&#123;name:required&#125;\")] [Obsolete] public bool Reque(string name) &#123; return true; &#125; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=\"number\"&gt;以三个数字开始&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpGet(\"&#123;number:regex(^\\\\d&#123;&#123;3&#125;&#125;$)&#125;\")] public bool Number(string number) &#123; return true; &#125; &#125;&#125; 自定义路由约束在项目根目录新增Constraint文件夹，在文件夹里新增MyRouteConstraint.cs，具体代码如下： 1234567891011121314151617181920212223using Microsoft.AspNetCore.Http;using Microsoft.AspNetCore.Routing;namespace RoutingDemo.Constraint&#123; public class MyRouteConstraint:IRouteConstraint &#123; public bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection) &#123; if (RouteDirection.IncomingRequest == routeDirection) &#123; var v = values[routeKey]; if (long.TryParse(v.ToString(), out var value)) &#123; return true; &#125; &#125; return false; &#125; &#125;&#125; 将自定义路由约束注册到框架中，在Startup.ConfigureServices方法里追加以下代码： 1234services.AddRouting(options =&gt;&#123; options.ConstraintMap.Add(\"isLong\", typeof(MyRouteConstraint));&#125;); 运行代码，访问/swagger，即可以看到路由配置的情况 总结 Restful不是必须的 约定好API的表达契约 将API约束在特定的目录下，如/api/ 使用ObsoleteAttribute标记即将废弃的API","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(12) -- 结构化日志组件Serilog：记录对查询分析友好的日志","slug":"12.LoggingSerilog_document","date":"2020-04-02T06:12:00.000Z","updated":"2020-04-02T17:12:26.749Z","comments":true,"path":"2020/04/02/12.LoggingSerilog_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/12.LoggingSerilog_document/","excerpt":"","text":"结构化日志的好处 主要场景 代码实现 创建项目 用Serilog替换自带的日志框架 修改appsettings.json文件 输出日志 结构化日志的好处 易于检索 易于分析统计 主要场景 实现日志告警 实现上下文的关联 实现与追踪系统集成 代码实现创建项目创建名字为LoggingSerilogDemo的ASP.NET Core项目，类型为API，因为使用的日志结构化组件为Serilog，所以需要引入以下的包: 1Serilog.AspNetCore 用Serilog替换自带的日志框架修改Program类，让Serilog替换掉ASP.NET Core自带的日志框架，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.IO;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.Hosting;using Serilog;using Serilog.Formatting.Compact;namespace LoggingSerilogDemo&#123; public class Program &#123; public static IConfiguration Configuration &#123; get; &#125; = new ConfigurationBuilder() .SetBasePath(Directory.GetCurrentDirectory()) .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true) .AddJsonFile($\"appsettings&#123;Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\") ?? \"Production\"&#125;.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); public static int Main(string[] args) &#123; Log.Logger = new LoggerConfiguration() .ReadFrom.Configuration(Configuration) .MinimumLevel.Debug() .Enrich.FromLogContext() .WriteTo.Console(new RenderedCompactJsonFormatter()) .WriteTo.File(formatter: new CompactJsonFormatter(), \"logs\\\\log.txt\", rollingInterval: RollingInterval.Day) .CreateLogger(); try &#123; Log.Information(\"Starting web host\"); CreateHostBuilder(args).Build().Run(); return 0; &#125; catch (Exception ex) &#123; Log.Fatal(ex,\"Host terminated unexpectedly\"); return 1; &#125; finally &#123; Log.CloseAndFlush(); &#125; &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; webBuilder.UseStartup&lt;Startup&gt;(); &#125;) .UseSerilog(dispose: true); &#125;&#125; 代码解析： 新建Configuration静态属性，直接读取appsettings.json的配置 new LoggerConfiguration是创建一个Serilog的logger对象，调的各种方法是进行日志配置 CreateHostBuilder的时候用try...catch包住是确保应用程序从开启到结束都有日志输出，包括启动失败，最后Log.CloseAndFlush()表示应用程序结束时会释放日志资源 UseSerilog表示正式引入Serilog组件，dispose:true表示应用程序关闭之后会自动释放日志资源 修改appsettings.json文件在appsettings.json文件中新增Serilog节点，具体内容如下： 12345678910111213141516171819&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125; &#125;, \"Serilog\": &#123; \"MinimumLevel\": &#123; \"Default\": \"Information\", \"Override\": &#123; \"Microsoft\": \"Information\", \"System\": \"Information\" &#125; &#125; &#125;, \"AllowedHosts\": \"*\"&#125; 输出日志在WeatherForecastController.Get方法中新增以下代码： 1_logger.LogInformation(\"This is information log\"); 运行项目，可以看到控制台打印出了结构化的日志，同时在项目根目录也有一个logs文件夹，进入文件夹可以看到日志文件","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(16) -- 文件提供程序：让你可以将文件放在任何地方","slug":"16.FileProvider_document","date":"2020-04-02T04:30:00.000Z","updated":"2020-04-03T08:34:56.257Z","comments":true,"path":"2020/04/02/16.FileProvider_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/16.FileProvider_document/","excerpt":"","text":"核心类型 IFileProvider：用来访问各种各样文件的提供程序的接口，通过这样抽象的定义，让我们与具体的文件的读取代码进行隔离，这样的好处是我们可以从不同的地方读取文件，不仅仅是本地物理文件，也可以是嵌入式文件，甚至是云端上面的其他API提供的文件 IFileInfo IDirectoryContents 内置文件提供程序 PhysicalFileProvider：物理文件的提供程序 EmbeddedFileProvider：嵌入式的提供程序 CompositeFileProvider：组合文件的提供程序，当我们由多个数据源来提供文件的手，可以将这些源合并为一个目录 代码实现创建项目创建名字为FileProviderDemo的控制台应用，通过nuget引入以下四个包： 1234Microsoft.Extensions.FileProviders.AbstractionsMicrosoft.Extensions.FileProviders.CompositeMicrosoft.Extensions.FileProviders.EmbeddedMicrosoft.Extensions.FileProviders.Physical 创建PhysicalFileProvider在Program.Main方法中新增以下代码： 123456var phyProvider = new PhysicalFileProvider(AppDomain.CurrentDomain.BaseDirectory);var contents = phyProvider.GetDirectoryContents(\"/\");foreach (var item in contents)&#123; Console.WriteLine(item.Name);&#125; 运行代码，可以看到控制台打印出类似以下信息： 12345678FileProviderDemo.runtimeconfig.dev.jsonFileProviderDemo.runtimeconfig.jsonMicrosoft.Extensions.FileProviders.Abstractions.dllMicrosoft.Extensions.FileProviders.Composite.dllMicrosoft.Extensions.FileProviders.Embedded.dllMicrosoft.Extensions.FileProviders.Physical.dllMicrosoft.Extensions.FileSystemGlobbing.dllMicrosoft.Extensions.Primitives.dll 创建EmbeddedFileProvider在项目根目录创建一个emb.html的文件，右键emb.html文件-&gt;属性-&gt;生成操作选择为嵌入的资源，然后在上面的测试代码后面追加以下代码： 123var embProvider = new EmbeddedFileProvider(typeof(Program).Assembly);var html = embProvider.GetFileInfo(\"emb.html\");Console.WriteLine($\"获取到嵌入式文件:&#123;html.Exists&#125;\"); 运行代码可以看到除了上一步打印的信息外，还有打印出了以下信息： 1获取到嵌入式文件:True 创建CompositeFileProvider继续上面的测试代码后面新增以下代码： 1234567Console.WriteLine(\"=====↓CompositeFileProvider↓=====\");var compositeProvider = new CompositeFileProvider(phyProvider, embProvider);var comContent = compositeProvider.GetDirectoryContents(\"/\");foreach (var item in comContent)&#123; Console.WriteLine(item.Name);&#125; 运行代码可以看到除了前两步打印的信息外，还打印了以下信息： 1234567891011121314&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;↓CompositeFileProvider↓&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;FileProviderDemo.deps.jsonFileProviderDemo.dllFileProviderDemo.exeFileProviderDemo.pdbFileProviderDemo.runtimeconfig.dev.jsonFileProviderDemo.runtimeconfig.jsonMicrosoft.Extensions.FileProviders.Abstractions.dllMicrosoft.Extensions.FileProviders.Composite.dllMicrosoft.Extensions.FileProviders.Embedded.dllMicrosoft.Extensions.FileProviders.Physical.dllMicrosoft.Extensions.FileSystemGlobbing.dllMicrosoft.Extensions.Primitives.dllemb.html","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(11) -- 日志框架：聊聊记日志的最佳姿势","slug":"11.LoggingSimple_document","date":"2020-04-02T03:12:00.000Z","updated":"2020-04-02T08:49:15.050Z","comments":true,"path":"2020/04/02/11.LoggingSimple_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/11.LoggingSimple_document/","excerpt":"","text":"概念 依赖包 日志级别 日志记录器 代码示例 创建项目 手动创建日志记录器 创建配置文件appsettings.json 依赖注入创建日志记录器 关于日志作用域 日志作用域的使用场景 代码演示 注意 概念依赖包对于输出到控制台的日志框架，主要依赖包有以下： 1234Microsoft.Extensions.LoggingMicrosoft.Extensions.Logging.ConsoleMicrosoft.Extensions.Logging.DebugMicrosoft.Extensions.Logging.TraceSource 日志级别.NET Core中日志级别分7个级别，从低到高具体如下： 1Trace -&gt; Debug -&gt; Information -&gt; Warning -&gt; Error -&gt; Critical -&gt; None 在配置中如果配置指定级别，则指定级别及以上的日志会被记录，低于指定级别的日志不会被记录，举例：配置项中指定级别为Warning，则只会记录Warning、Error、Critical这些日志，Trace、Debug、Information是不会记录下来，缺省默认配置为Information，如果指定为None级别则以为着不会有日志记录 日志记录器记录日志的级别是属于某个日志记录器的，通过ILoggerFactory的对象方法CreateLogger创建一个日志记录器，传入参数就是这个日志记录去的名字，在配置相中对应配置该日志记录器的日志级别，即可指定要哪个日志记录器需要记录到哪些级别的日志 通常正常开发比较少去自己创建日志记录器，都是通过构造函数获取依赖注入的对象ILogger&lt;T&gt;，这样获取到的日志记录器的名字为项目名.类型名称，按照这个规律就可以自行配置各个日志记录器的日志记录级别，下面会有代码示例 代码示例创建项目创建名字为LoggingSimpleDemo的控制台应用，通过nuget引入以下五个包 12345Microsoft.Extensions.Configuration.JsonMicrosoft.Extensions.LoggingMicrosoft.Extensions.Logging.ConsoleMicrosoft.Extensions.Logging.DebugMicrosoft.Extensions.Logging.TraceSource 这里引用Microsoft.Extensions.Configuration.Json这个包是因为记录日志的记录要从配置项中读取 手动创建日志记录器修改Program.Main，代码如下： 1234567891011121314151617181920212223242526272829303132using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; class Program &#123; static void Main(string[] args) &#123; var configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true); var configurationRoot = configurationBuilder.Build(); var serviceCollection = new ServiceCollection(); serviceCollection.AddSingleton&lt;IConfigurationRoot&gt;(p =&gt; configurationRoot); serviceCollection.AddLogging(builder =&gt; &#123; builder.AddConfiguration(configurationRoot.GetSection(\"Logging\")); builder.AddConsole(); &#125;); var serviceProvider = serviceCollection.BuildServiceProvider(); var loggerFactory = serviceProvider.GetService&lt;ILoggerFactory&gt;(); var loggerA = loggerFactory.CreateLogger(\"LoggerA\"); loggerA.LogDebug(2001,\"This is LoggerA -- logDebug\"); loggerA.LogInformation(\"This is LoggerA -- logInformation\"); loggerA.LogError(new Exception(\"LoggerA Error\"),\"This is LoggerA -- LogError\"); &#125; &#125;&#125; Main方法中前三行代码是读取appsettings.json的配置项 new ServiceCollection()是创建一个服务容器，然后将上面读到的服务注册到服务容器中去，有服务容器来管理配置项服务生命周期 serviceCollection.AddLogging()是添加日志服务到服务容器中，builder.AddConfiguration()指的是日志使用的是配置框架里Logging的配置项，builder.AddConsole()是添加一个名字为Console的控制台日志到日志工厂中去 serviceCollection.BuildServiceProvider()是生成一个服务容器实例 serviceProvider.GetService&lt;ILoggerFactory&gt;()是从服务容器中获取一个ILoggerFactory的日志工厂对象 loggerFactory.CreateLogger(&quot;LoggerA&quot;)是创建一个名字为LoggerA的日志记录器 LogDebug、LogInformation、LogError则是记录对应级别的日志 创建配置文件appsettings.json创建文件appsettings.json，具体内容如下： 1234567891011121314&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"LogLevel\": &#123; \"LoggerA\": \"Trace\" &#125; &#125; &#125; &#125; 将appsettings.json拷贝到输出目录(可参照文件配置提供程序里的操作)，运行项目，可以看到控制台打出以下信息： 1234567dbug: LoggerA[2001] This is LoggerA -- logDebuginfo: LoggerA[0] This is LoggerA -- logInformationfail: LoggerA[0] This is LoggerA -- LogErrorSystem.Exception: LoggerA Error 可以自行调整appsettings.json里的LoggerA配置来尝试不同级别的日志记录 依赖注入创建日志记录器创建测试服务类OrderService，具体代码如下： 1234567891011121314151617181920using System;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; public class OrderService &#123; private readonly ILogger&lt;OrderService&gt; _logger; public OrderService(ILogger&lt;OrderService&gt; logger) &#123; _logger = logger; &#125; public void Show() &#123; _logger.LogInformation(\"Show Time &#123;time&#125;\",DateTime.Now); &#125; &#125;&#125; 在Program.Main方法中将OrderService注册进服务容器中，并获取出服务实例，调用Show方法，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; class Program &#123; static void Main(string[] args) &#123; var configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true); var configurationRoot = configurationBuilder.Build(); var serviceCollection = new ServiceCollection(); serviceCollection.AddSingleton&lt;IConfigurationRoot&gt;(p =&gt; configurationRoot); serviceCollection.AddTransient&lt;OrderService&gt;(); serviceCollection.AddLogging(builder =&gt; &#123; builder.AddConfiguration(configurationRoot.GetSection(\"Logging\")); builder.AddConsole(); &#125;); var serviceProvider = serviceCollection.BuildServiceProvider(); var loggerFactory = serviceProvider.GetService&lt;ILoggerFactory&gt;(); var loggerA = loggerFactory.CreateLogger(\"LoggerA\"); loggerA.LogDebug(2001,\"This is LoggerA -- logDebug\"); loggerA.LogInformation(\"This is LoggerA -- logInformation\"); loggerA.LogError(new Exception(\"LoggerA Error\"),\"This is LoggerA -- LogError\"); var orderService = serviceProvider.GetService&lt;OrderService&gt;(); orderService.Show(); Console.ReadKey(); &#125; &#125;&#125; 修改appsettings.json，具体内容如下： 123456789101112131415&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"LogLevel\": &#123; \"LoggerA\": \"Trace\", \"LoggingSimpleDemo.OrderService\": \"Trace\" &#125; &#125; &#125; &#125; 运行项目，可以看到控制台输出日志信息 123456789dbug: LoggerA[2001] This is LoggerA -- logDebuginfo: LoggerA[0] This is LoggerA -- logInformationfail: LoggerA[0] This is LoggerA -- LogErrorSystem.Exception: LoggerA Errorinfo: LoggingSimpleDemo.OrderService[0] Show Time 04&#x2F;02&#x2F;2020 12:06:46 也可以自行调整appsettings.json里的配置来尝试不同级别的日志记录 关于日志作用域日志作用域的使用场景 一个事务包含多条操作时 复杂流程的日志关联时 调用链追踪与请求处理过程对应时 代码演示将上面获取日志记录器的代码注释掉，手动获取一个Program的日志记录器，然后创建日志作用域，具体代码如下 12345678910111213141516171819202122232425262728293031323334353637383940using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;namespace LoggingSimpleDemo&#123; class Program &#123; static void Main(string[] args) &#123; var configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true); var configurationRoot = configurationBuilder.Build(); var serviceCollection = new ServiceCollection(); serviceCollection.AddSingleton&lt;IConfigurationRoot&gt;(p =&gt; configurationRoot); serviceCollection.AddTransient&lt;OrderService&gt;(); serviceCollection.AddLogging(builder =&gt; &#123; builder.AddConfiguration(configurationRoot.GetSection(\"Logging\")); builder.AddConsole(); builder.AddDebug(); &#125;); var serviceProvider = serviceCollection.BuildServiceProvider(); var loggerFactory = serviceProvider.GetService&lt;ILoggerFactory&gt;(); var logger = loggerFactory.CreateLogger&lt;Program&gt;(); using (var scope = logger.BeginScope(\"scopeId=&#123;scopeId&#125;\",Guid.NewGuid())) &#123; logger.LogTrace(\"This is Trace in scope\"); logger.LogInformation(\"This is Information in scope\"); logger.LogWarning(\"This is Warning in scope\"); logger.LogError(\"This is Error in scope\"); &#125; Console.ReadKey(); &#125; &#125;&#125; 在appsettings.json中添加IncludeScopes属性，具体代码如下： 12345678910111213141516&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125;, \"Console\": &#123; \"IncludeScopes\": true, \"LogLevel\": &#123; \"LoggerA\": \"Trace\", \"LoggingSimpleDemo.OrderService\": \"Trace\" &#125; &#125; &#125; &#125; 运行代码，可以看到控制台打印出类似以下信息： 123456789info: LoggingSimpleDemo.Program[0] &#x3D;&gt; scopeId&#x3D;40c5bb84-584d-4a4c-a56b-f3b66214e1ac This is Information in scopewarn: LoggingSimpleDemo.Program[0] &#x3D;&gt; scopeId&#x3D;40c5bb84-584d-4a4c-a56b-f3b66214e1ac This is Warning in scopefail: LoggingSimpleDemo.Program[0] &#x3D;&gt; scopeId&#x3D;40c5bb84-584d-4a4c-a56b-f3b66214e1ac This is Error in scope 在ASP.NET Core项目中，要启用日志作用域，一样只需要在配置文件中新增IncludeScopes属性即可 注意 日志记录要避免敏感信息，如密码、密钥等 日志记录的时候最好用占位符的方式传参数，可以节省不必要的字符串拼接","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(15) -- 静态文件中间件：前后端分离开发合并部署骚操作","slug":"15.StaticFiles_document","date":"2020-04-02T02:30:00.000Z","updated":"2020-04-03T08:34:52.046Z","comments":true,"path":"2020/04/02/15.StaticFiles_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/02/15.StaticFiles_document/","excerpt":"","text":"静态文件中间件的能力 代码实现 创建项目 创建测试用的静态文件 默认静态文件中间件 设置默认文件为index.html 支持目录浏览 多目录映射 功能实现 静态文件中间件的能力 支持指定相对路径 支持目录浏览 支持设置默认文档 支持多目录映射 代码实现创建项目创建名字为StaticFilesDemo的ASP.NET Core项目，类型为API 创建测试用的静态文件在根目录创建wwwroot文件夹，参照下面结构进行对应文件创建： 123456wwwroot |-- app.js |-- index.html |-- a |-- a.js |-- index.html 具体代码如下： /wwwroot/index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;静态首页&lt;/title&gt; &lt;script src=\"/app.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是静态首页 wwwroot/index.html&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; /wwwroot/app.js 1alert(\"这是/index.html\") /wwwroot/a/index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"a.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是/a/index.html&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; /wwwroot/a/a.js 1alert(\"这是/a/index.html\") 默认静态文件中间件在Startup.Configure中，将以下代码添加到app.UseHttpsRedirection();下一行 1app.UseStaticFiles(); 运行项目访问https://localhost:5001/index.html和https://localhost:5001/a/index.html可看到静态页面信息 设置默认文件为index.html能起到的效果如下： https://localhost:5001 = https://localhost:5001/index.html https://localhost:5001/a = https://localhost:5001/a/index.html 在app.UseStaticFiles();前面添加以下代码即可： 1app.UseDefaultFiles(); 运行项目访问https://localhost:5001和https://localhost:5001/a可看到静态页面信息 支持目录浏览注释掉默认文件的那个中间件，添加目录浏览的中间件，代码如下： 1app.UseDirectoryBrowser(); 然后在Startup.ConfigureServices配置目录浏览的服务，代码如下： 1services.AddDirectoryBrowser(); 运行项目访问https://localhost:5001，可以看到wwwroot的目录结构 多目录映射当文件支持存在放wwwroot这个文件夹的时候，可以使用静态文件中间件的重载来映射其他文件夹，注释掉上一步的代码，将Startup.Configure修改如下： 1234567891011121314151617181920212223public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseStaticFiles(new StaticFileOptions() &#123; FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), \"file\")) &#125;); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 在项目根目录创建file文件夹，在里面创建个file_page.html文件，随便写点东西，运行项目，访问https://localhost:5001/file_page.html，可以看到静态页内容。注意，如果出现同名文件，则先注册的路径优先权更高，如果需要在访问指定文件夹有指定url地址，可以使用StaticFileOptions对象的RequestPath属性，假设这里的RequestPath=&quot;/myfiles&quot;，则说明要想访问file文件夹的内容，路径前面得加上myfiles，例如https://localhost:5001/myfiles/file_page.html 功能实现有这样一个需求，接口里所有接口的路由都由api开始，即/api/xxx，静态文件放在默认的wwwroot文件夹中，如果访问的地址不是接口，同时也找不到对应的静态文件，则重写到/index.html页面，具体代码如下： 修改WeatherForecastController，将原本的[Route(&quot;[controller]&quot;)]修改为[Route(&quot;/api/[controller]&quot;)] 修改Startup.Configure方法，代码如下： 1234567891011121314151617181920212223242526public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseStaticFiles(); app.MapWhen(context =&gt; &#123; return !context.Request.Path.Value.StartsWith(\"/api\"); &#125;, appBuilder =&gt; &#123; var option = new RewriteOptions(); option.AddRewrite(regex: \".*\", replacement: \"/index.html\", skipRemainingRules: true); appBuilder.UseRewriter(option); appBuilder.UseStaticFiles(); &#125;); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 运行项目，访问https://localhost:5001/api/WeatherForecast，可以看到正常返回接口信息，访问https://localhost:5001/a/index.html可以看到正常访问到/a/index.html文件内容，访问https://localhost:5001/order/get则会返回/index.html文件内容","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":"特基础教程系列","slug":"StepByStep","date":"2020-04-01T14:18:00.000Z","updated":"2020-05-14T14:59:34.334Z","comments":true,"path":"2020/04/01/StepByStep/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/StepByStep/","excerpt":"","text":"Visual Studio Code 下载安装 关于安装扩展插件 关于汉化 平时写静态页流程 todo:常用的vscode插件 todo:常用的vscode代码段 Visual Studio Code下载安装下载地址：https://code.visualstudio.com/，下载之后双击安装即可 关于安装扩展插件如下图，点击左边的插件tab，输入插件名称进行搜索，然后点击install即可进行安装 关于汉化vscode的汉化包使用的也是通过插件的形式来安装，搜索chinese，找到Chinese (Simplified) Language Pack for Visual Studio Code这个插件进行安装，安装完重启即可 平时写静态页流程 一般我会在电脑指定一个盘创建一个文件夹，指定这个文件夹存放自己的源码，无论个人电脑还是公司电脑，比如G盘里创建了repo的文件夹作为我统一管理源码的文件夹 通常自己写代码会分两种级别，一种是为了学习测试而写的demo，一种是比较有一定业务逻辑需求的小项目，所以一般会在repo文件夹下再创建两个文件夹，分别为jiamiao.x.demo和jiamiao.x.project 注意一点，无论是在写demo还是写project，都不要出现类似demo1、demo2、project1、project2这种没意义的名字，以下以我写一段表单demo为例子： 在G:/repo/jiamiao.x.demo的文件夹中创建文件夹form_demo，然后再form_demo文件夹上右键，点击通过Code打开 打开之后可以看到左边有文件夹的目录，当前现在是一片空白，如下图： 接下来在vscode中操作，在FORM_DEMO下方空白处右键，点击新建文件，输入index.html回车，可以看到创建了index.html文件，在右边的编辑区则可以进行编码，只要文件扩展名.html正确，则可以代码高亮和智能提示 当静态页需要引用图片、样式、脚本等，可以在FORM_DEMO下方空白处右键，点击新建文件夹，对应输入image/style/script等名字之后回车即可 写完页面之后，可以右键index.html文件，点击Open In Default Browser(需要安装插件Open in Browser)，直接打开浏览器来查看页面效果，如下图： todo:常用的vscode插件todo:常用的vscode代码段","categories":[{"name":"StepByStep","slug":"StepByStep","permalink":"http://www.dimsum.fun/categories/StepByStep/"}],"tags":[{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://www.dimsum.fun/tags/Visual-Studio-Code/"},{"name":"特基础","slug":"特基础","permalink":"http://www.dimsum.fun/tags/%E7%89%B9%E5%9F%BA%E7%A1%80/"}]},{"title":".NET Core开发实战课程备忘(10) -- 选项框架：服务组件集成配置的最佳实现","slug":"10.Option_document","date":"2020-04-01T05:13:13.000Z","updated":"2020-04-01T09:04:58.074Z","comments":true,"path":"2020/04/01/10.Option_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/10.Option_document/","excerpt":"","text":"选项框架特性 设计原则 建议 代码实现 创建测试服务与测试服务对应的选项 修改appsettings.json 注册服务和选项 获取服务进行测试 选项框架热更新 关键类型 代码示例 IOptionsSnapshot IOptionsMonitor IOptionsMonitor监听配置变动 优化代码结构 动态修改选项值 选项框架特性 支持单例模式读取配置 支持快照 支持配置变更通知 支持运行时动态修改选项值 设计原则 接口分离原则(ISP)，我们的类不应该依赖它不使用的配置 关注点分离(SoC)，不同组件、服务、类之间的配置不应相互依赖或耦合 建议 为我们的服务设计XXXOptions 使用IOptions&lt;XXXOptions&gt;、IOptionsSnapshot&lt;XXXOptions&gt;、IOptionsMonitor&lt;XXXOptions&gt;作为服务构造函数的参数 代码实现创建名为OptionsDemo的ASP.NET Core项目，类型为API 创建测试服务与测试服务对应的选项创建OrderService.cs为了方便测试，这里将IOrderService、OrderService、OrderServiceOption都放在OrderService.cs文件中，具体代码如下： 12345678910111213141516171819202122232425262728using Microsoft.Extensions.Options;namespace OptionsDemo.Services&#123; public interface IOrderService &#123; int ShowMaxOrderCount(); &#125; public class OrderService:IOrderService &#123; private readonly IOptions&lt;OrderServiceOptions&gt; _options; public OrderService(IOptions&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.Value.MaxOrderCount; &#125; &#125; public class OrderServiceOptions &#123; public int MaxOrderCount &#123; get; set; &#125; = 100; &#125;&#125; 修改appsettings.json将项目中的appsettings.json的内容修改如下： 12345678910111213&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125; &#125;, \"AllowedHosts\": \"*\", \"OrderService\": &#123; \"MaxOrderCount\": 400 &#125; &#125; 注册服务和选项在Startup.ConfigureServices中添加以下代码： 12services.Configure&lt;OrderServiceOptions&gt;(Configuration.GetSection(\"OrderService\"));services.AddScoped&lt;IOrderService, OrderService&gt;(); 获取服务进行测试修改WeatherForecastController.Get方法，具体代码如下： 123456[HttpGet]public int Get([FromServices]IOrderService orderService)&#123; Console.WriteLine($\"orderService.ShowMaxOrderCount:&#123;orderService.ShowMaxOrderCount()&#125;\"); return 1;&#125; 运行项目，可以访问/WeatherForecast，可以看到控制台打印出以下信息： 1orderService.ShowMaxOrderCount:400 这里如果在项目运行时修改appsettings.json里配置项的值，重新访问/WeatherForecast地址，会发现控制台打印出来的值不会变，还依旧是400，这里就需要使用到下面的热更新。 选项框架热更新关键类型 单例服务(Singleton)使用IOptionsMonitor&lt;out TOptions&gt; 范围作用域类型(Scope)使用IOptionsSnapshot&lt;out TOptions&gt; 代码示例IOptionsSnapshot上个示例对OrderService注册的是Scope服务，所以这里先测试Scope对应的IOptionsSnapshot，将OrderService构造函数获取服务的类型修改为IOptionsSnapshot&lt;OrderServiceOptions&gt;，最终修改后OrderService类的代码如下： 123456789101112public class OrderService:IOrderService&#123; private readonly IOptionsSnapshot&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsSnapshot&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.Value.MaxOrderCount; &#125;&#125; 运行代码，访问/WeatherForecast，发现现在打印出来的是appsettings.json现有的值，对该配置项进行修改，保存之后重新访问/WeatherForecast，可以发现获取到的是新的值 IOptionsMonitor将OrderService构造函数获取服务的类型修改为IOptionsMonitor&lt;OrderServiceOptions&gt;，最终修改后OrderService类的代码如下： 123456789101112public class OrderService:IOrderService&#123; private readonly IOptionsMonitor&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsMonitor&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.CurrentValue.MaxOrderCount; &#125;&#125; 在Startup.ConfigureServices方法中将OrderService注册为单例模式，代码如下： 1services.AddSingleton&lt;IOrderService, OrderService&gt;(); 运行代码，访问/WeatherForecast，发现现在打印出来的是appsettings.json现有的值，对该配置项进行修改，保存之后重新访问/WeatherForecast，可以发现获取到的是新的值 IOptionsMonitor监听配置变动通过IOptionsMonitor对象的OnChange方法来注册配置变动操作，只需要在获取对象后注册相应操作即可，具体代码如下： 12345678910111213141516public class OrderService:IOrderService&#123; private readonly IOptionsMonitor&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsMonitor&lt;OrderServiceOptions&gt; options) &#123; _options = options; this._options.OnChange(changedOptions =&gt; &#123; Console.WriteLine($\"配置发生了变化,新值为:&#123;changedOptions.MaxOrderCount&#125;\"); &#125;); &#125; public int ShowMaxOrderCount() &#123; return _options.CurrentValue.MaxOrderCount; &#125;&#125; 运行代码，修改appsettings.json的值，就可以看到控制台打印出类似以下信息： 1配置发生了变化,新值为:100 优化代码结构在开发中经常会出现服务与选项一起注册的情况，为了优化代码结构，一般会为统一将一个服务的注册放到IServiceCollection的扩展方法中去。创建OrderServiceExtensions.cs，具体代码如下： 123456789101112131415using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.Configure&lt;OrderServiceOptions&gt;(configuration.GetSection(\"OrderService\")); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 将Startup.ConfigureServices修改后代码如下： 12345public void ConfigureServices(IServiceCollection services)&#123; services.AddOrderService(Configuration); services.AddControllers();&#125; 运行之后可发现效果与上面一致 动态修改选项值在注入选项之后，可动态对选项的值进行操作，这里以为MaxOrderCount的值增加100为例，修改OrderServiceExtensions，代码如下： 12345678910111213141516171819using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.Configure&lt;OrderServiceOptions&gt;(configuration.GetSection(\"OrderService\")); services.PostConfigure&lt;OrderServiceOptions&gt;(options =&gt; &#123; options.MaxOrderCount += 100; &#125;); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 运行代码，可发现获得到的值比appsettings.json里的值增加100","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(9) -- 自定义配置数据源：低成本实现定制配置方案","slug":"9.ConfigurationCustom_document","date":"2020-04-01T04:12:12.000Z","updated":"2020-04-01T09:04:52.857Z","comments":true,"path":"2020/04/01/9.ConfigurationCustom_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/9.ConfigurationCustom_document/","excerpt":"","text":"拓展步骤 代码实现 创建项目 创建自定义数据源Provider 创建自定义数据源Source 创建IConfigurationBuilder扩展方法 引用自定义配置源并监听配置源变化 拓展步骤 实现IConfigurationSource 实现IConfigurationProvider 实现AddXXX扩展方法 代码实现创建项目创建名字为ConfigurationCustomDemo的控制台应用，通过nuget引入以下两个包： 12Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.Abstractions 创建自定义数据源Provider创建MyConfigurationProvider，继承ConfigurationProvider这个抽象类，调用基类的OnReload方法能触发重新加载配置，这里因为要自动修改和触发配置，所以这个类里用了Timer对象来模拟配置变化的操作，具体代码如下： 123456789101112131415161718192021222324252627282930313233using System;using System.Timers;using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; internal class MyConfigurationProvider:ConfigurationProvider &#123; private Timer timer; public MyConfigurationProvider():base() &#123; timer = new Timer(); timer.Elapsed += Timer_Elapsed; timer.Interval = 3000; timer.Start(); &#125; private void Timer_Elapsed(object sender, ElapsedEventArgs e) &#123; Load(true); &#125; void Load(bool reload) &#123; this.Data[\"lastTime\"] = DateTime.Now.ToString(); if (reload) &#123; base.OnReload(); &#125; &#125; &#125;&#125; 创建自定义数据源Source创建MyConfigurationSource，实现IConfigurationSource接口，在Build方法直接返回上面创建的Provider，具体代码如下： 123456789101112using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; internal class MyConfigurationSource:IConfigurationSource &#123; public IConfigurationProvider Build(IConfigurationBuilder builder) &#123; return new MyConfigurationProvider(); &#125; &#125;&#125; 创建IConfigurationBuilder扩展方法可以看到上面两个类的都是用internal的访问修饰符，这是因为一般在Provider和Source都是通过拓展方法来调用，而不会将自己直接暴露被调用者，所以接下来要创建一个IConfigurationBuilder的扩展方法，代码如下： 12345678910111213using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; public static class MyConfigurationBuilderExtension &#123; public static IConfigurationBuilder AddMyConfiguration(this IConfigurationBuilder builder) &#123; builder.Add(new MyConfigurationSource()); return builder; &#125; &#125;&#125; 引用自定义配置源并监听配置源变化Program.Main方法修改如下： 12345678910111213141516171819202122232425using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.Primitives;namespace ConfigurationCustomDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddMyConfiguration(); var configurationRoot = builder.Build(); ChangeToken.OnChange(() =&gt; configurationRoot.GetReloadToken(), () =&gt; &#123; var lastTime = configurationRoot[\"lastTime\"]; Console.WriteLine($\"lastTime=&#123;lastTime&#125;\"); Console.WriteLine(\"======\"); &#125;); Console.ReadKey(); &#125; &#125;&#125; 运行代码，可以看到控制台3秒钟打印一次当前时间的效果","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(8) -- 文件配置提供程序：自由选择配置的格式","slug":"8.ConfigurationFile_document","date":"2020-04-01T03:11:11.000Z","updated":"2020-04-01T09:04:48.264Z","comments":true,"path":"2020/04/01/8.ConfigurationFile_document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/8.ConfigurationFile_document/","excerpt":"","text":"文件配置提供程序 特性 代码示例 创建项目 创建测试配置项appSetting.json 获取appSetting.json里的配置 获取ini配置文件 文件配置提供程序读取不同文件格式或从不同位置读取配置 Microsoft.Extensions.Configuration.Ini Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.UserSecrets Microsoft.Extensions.Configuration.Xml 特性 指定文件可选、必选 指定是否监视文件的变更 代码示例创建项目创建名字为ConfigurationFileDemo的控制台应用，通过nuget引入以下四个包： 1234Microsoft.Extensions.Configuration.IniMicrosoft.Extensions.Configuration.JsonMicrosoft.Extensions.Configuration.UserSecretsMicrosoft.Extensions.Configuration.Xml 这里不用引用Microsoft.Extensions.Configuration和Microsoft.Extensions.Configuration.Abstractions两个基础包，是因为其他包已经包含了两个基础包 创建测试配置项appSetting.json在项目根目录创建appSetting.json文件，内容如下： 123456&#123; \"Key1\": \"value1\", \"Key2\": \"value2\", \"Key3\": false, \"Key4\": 10&#125; 在Visual Studio 2019中通过右键appSetting.json文件-&gt;属性-复制到输出目录选择如果较新则复制 在Visual Studio Code中通过修改ConfigurationFileDemo.csproj文件，新增文件输出到配置，具体代码如下：1234567891011121314151617&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;&lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;&lt;/PropertyGroup&gt;&lt;ItemGroup&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Ini\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Json\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.UserSecrets\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Xml\" Version=\"3.1.3\" /&gt;&lt;/ItemGroup&gt;&lt;ItemGroup&gt; &lt;None Update=\"appSetting.json\"&gt; &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt; &lt;/None&gt;&lt;/ItemGroup&gt;&lt;/Project&gt; 获取appSetting.json里的配置修改Program.Main方法，内容如下：12345678910111213141516171819202122232425using System;using Microsoft.Extensions.Configuration;namespace ConfigurationFileDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddJsonFile(\"appSetting.json\",optional:false,reloadOnChange:true); var configurationRoot = builder.Build(); Console.WriteLine(\"开始了。。输入随意字符串返回配置项，直接回车推出\"); var isStop = Console.ReadLine(); while (!string.IsNullOrEmpty(isStop)) &#123; Console.WriteLine($\"Key1=&#123;configurationRoot[\"Key1\"]&#125;\"); Console.WriteLine($\"Key2=&#123;configurationRoot[\"Key2\"]&#125;\"); Console.WriteLine($\"Key3=&#123;configurationRoot[\"Key3\"]&#125;\"); Console.WriteLine($\"Key4=&#123;configurationRoot[\"Key4\"]&#125;\"); Console.WriteLine(\"=====分割线=====\"); isStop = Console.ReadLine(); &#125; &#125; &#125;&#125; optional：表示文件是否可选，false=没文件会报错，true=可以没有文件 reloadOnChange：表示监视配置文件的变动，配置文件变动会进行重新读取 运行代码，然后在控制台随意输入字符串回车，可以看到以下信息： 12345Key1&#x3D;value1Key2&#x3D;value2Key3&#x3D;FalseKey4&#x3D;10&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 进入项目根目录/bin/Debug/netcoreapp3.1里，找到appSetting.json文件，修改里面的配置值，再回到控制台输入随意字符串回车，可以看到打印出来的值已经有所变化 获取ini配置文件在项目根目录创建appSetting.ini文件，内容如下： 12Key4=Hello worldKey5=value5 类似appSetting.json那样配置拷贝到输出目录，修改Program.Main方法，在AddJsonFile方法下面新增添加ini配置源的调用，代码如下： 1builder.AddIniFile(\"appSetting.ini\", optional: false, reloadOnChange: true); 运行代码，然后在控制台输入随意字符串回车，可以看到以下信息： 123456Key1&#x3D;value1Key2&#x3D;value2Key3&#x3D;FalseKey4&#x3D;Hello worldKey5&#x3D;value5&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 可以看到ini文件里的配置已经加载进去了，同时后面加载的配置项如果与前面已经加载的配置项名称一致，会覆盖掉前面加载的配置项","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(7) -- 环境变量配置提供程序：容器环境下配置注入的最佳途径","slug":"7.ConfigurationEnvironmentVariables_Document","date":"2020-04-01T02:10:10.000Z","updated":"2020-04-01T09:04:43.281Z","comments":true,"path":"2020/04/01/7.ConfigurationEnvironmentVariables_Document/","link":"","permalink":"http://www.dimsum.fun/2020/04/01/7.ConfigurationEnvironmentVariables_Document/","excerpt":"","text":"使用场景 在Docker中运行 在Kubernetes中运行 需要设置ASP.NET Core的一些内置特殊配置时 特性 对应配置的分层键，支持用双下划线”--“代替”:“ 支持根据前缀加载 代码示例创建项目创建名字为ConfigurationEnvironmentVariablesDemo的控制台应用，通过nuget引入以下三个包： 123Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.AbstractionsMicrosoft.Extensions.Configuration.EnvironmentVariables 获取环境变量配置修改Program.Main方法，代码如下： 123456789101112131415161718using System;using Microsoft.Extensions.Configuration;namespace ConfigurationEnvironmentVariablesDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddEnvironmentVariables(); var configurationRoot = builder.Build(); Console.WriteLine($\"KEY3=&#123;configurationRoot[\"KEY3\"]&#125;\"); var section = configurationRoot.GetSection(\"SECTIONA\"); Console.WriteLine($\"SECTIONA:KEY2=&#123;section[\"KEY2\"]&#125;\"); &#125; &#125;&#125; 配置测试参数： 在Visual Studio 2019中，可以右键项目名称-&gt;属性-&gt;调试-&gt;环境变量中添加以下内容：12345&quot;DIMSUM_KEY1&quot;: &quot;dimsum_value1&quot;,&quot;KEY3&quot;: &quot;value3&quot;,&quot;KEY1&quot;: &quot;value1&quot;,&quot;SECTIONA__KEY2&quot;: &quot;value2&quot;,&quot;KEY4&quot;: &quot;value4&quot; 在Visual Studio Code中，可以编辑launchSettings.json文件，新增environmentVariables字段，具体代码如下:1234567891011121314&#123; \"profiles\": &#123; \"ConfigurationEnvironmentVariablesDemo\": &#123; \"commandName\": \"Project\", \"environmentVariables\": &#123; \"DIMSUM_KEY1\": \"dimsum_value1\", \"KEY3\": \"value3\", \"KEY1\": \"value1\", \"SECTIONA__KEY2\": \"value2\", \"KEY4\": \"value4\" &#125; &#125; &#125;&#125; 运行项目，会得到以下信息：12KEY3&#x3D;value3SECTIONA:KEY2&#x3D;value2 前缀过滤过滤指定前缀的环境变量，具体代码如下： 12345678910111213141516using System;using Microsoft.Extensions.Configuration;namespace ConfigurationEnvironmentVariablesDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddEnvironmentVariables(\"DIMSUM_\"); var configurationRoot = builder.Build(); Console.WriteLine($\"DIMSUM_KEY1=&#123;configurationRoot[\"KEY1\"]&#125;\"); &#125; &#125;&#125; 运行项目可以得到以下信息 1DIMSUM_KEY1&#x3D;dimsum_value1 说明这里获取到的是DIMSUM_KEY1这个配置，而非KEY这个配置","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(6) -- 命令行配置提供程序：最简单快捷的配置注入方法","slug":"6.ConfigurationCommandLine_document","date":"2020-03-31T07:15:15.000Z","updated":"2020-04-01T09:04:35.678Z","comments":true,"path":"2020/03/31/6.ConfigurationCommandLine_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/6.ConfigurationCommandLine_document/","excerpt":"","text":"命令行参数支持的格式 命令替换模式 代码示例 创建项目 测试支持命令行参数的三种格式 测试命令替换 命令行参数支持的格式 无前缀的key=value模式 双中横线--key=value或--key value模式 正斜杠/key=value或/key value模式 备注：等号分隔符和空格分隔符不能混用* 命令替换模式 必须以单横线-或双横线--开头 映射字典不能包含重复key 主要作用是命令缩写的作用 代码示例创建项目创建名字为ConfigurationCommandLineDemo的控制台应用，通过nuget引入以下三个包： 123Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.AbstractionsMicrosoft.Extensions.Configuration.CommandLine 测试支持命令行参数的三种格式修改Program.Main方法，代码如下： 1234567891011121314151617181920using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationCommandLineDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddCommandLine(args); var configurationRoot = builder.Build(); Console.WriteLine($\"CommandLineKey1:&#123;configurationRoot[\"CommandLineKey1\"]&#125;\"); Console.WriteLine($\"CommandLineKey2:&#123;configurationRoot[\"CommandLineKey2\"]&#125;\"); Console.WriteLine($\"CommandLineKey3:&#123;configurationRoot[\"CommandLineKey3\"]&#125;\"); Console.ReadKey(); &#125; &#125;&#125; 配置测试参数： 在Visual Studio 2019中，可以右键项目名称-&gt;属性-&gt;调试-&gt;应用程序参数中输入以下内容：1CommandLineKey1&#x3D;value1 --CommandLineKey2&#x3D;value2 &#x2F;CommandLineKey3&#x3D;value3 在Visual Studio Code中，可以编辑launchSettings.json文件，新增commandLineArgs字段，具体代码如下:12345678&#123; \"profiles\": &#123; \"ConfigurationCommandLineDemo\": &#123; \"commandName\": \"Project\", \"commandLineArgs\": \"CommandLineKey1=value1 --CommandLineKey2=value2 /CommandLineKey3=value3\" &#125; &#125;&#125; 运行项目，可以看到控制台打印出对应的键值对，类似以下信息： 123CommandLineKey1:value1CommandLineKey2:value2CommandLineKey3:value3 测试命令替换为Program.Main方法添加命令替换映射，代码如下： 123456789101112131415161718192021using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationCommandLineDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); var mapper = new Dictionary&lt;string, string&gt;() &#123;&#123;\"-k1\", \"CommandLineKey1\"&#125;&#125;; builder.AddCommandLine(args, mapper); var configurationRoot = builder.Build(); Console.WriteLine($\"CommandLineKey1:&#123;configurationRoot[\"CommandLineKey1\"]&#125;\"); Console.WriteLine($\"CommandLineKey2:&#123;configurationRoot[\"CommandLineKey2\"]&#125;\"); Console.WriteLine($\"CommandLineKey3:&#123;configurationRoot[\"CommandLineKey3\"]&#125;\"); Console.ReadKey(); &#125; &#125;&#125; mapper表示用-k1这个命令可以代替CommandLineKey1将应用参数修改为： 1CommandLineKey1&#x3D;value1 --CommandLineKey2&#x3D;value2 &#x2F;CommandLineKey3&#x3D;value3 -k1&#x3D;value4 运行项目会在控制台打印出以下信息： 123CommandLineKey1:value4CommandLineKey2:value2CommandLineKey3:value3 可以发现CommandLineKey1原本的值value1被后面的-k1的值value4所替换了，说明了替换规则生效","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(5) -- 配置框架：让服务无缝适应各种环境","slug":"5.Configuration_document","date":"2020-03-31T06:14:14.000Z","updated":"2020-04-01T09:04:29.535Z","comments":true,"path":"2020/03/31/5.Configuration_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/5.Configuration_document/","excerpt":"","text":"概念 配置框架的核心包 框架配置 配置框架核心类型 配置框架扩展点 代码实现 创建项目 完善代码 概念配置框架的核心包与依赖注入框架的核心包类似，使用的是接口实现分离的设计模式 12Microsoft.Extensions.Configuration &#x2F;&#x2F;实现包Microsoft.Extensions.Configuration.Abstractions &#x2F;&#x2F;抽象包 框架配置 以key-value字符串键值对的方式抽象了配置 支持从各种不同的数据源读取配置，比如从命令行读取、环境变量读取、从文件读取等 配置框架核心类型1234IConfigurationIConfigurationRootIConfigurationSectionIConfigurationBuilder 配置框架扩展点可以通过拓展点注入我们自己的配置源，也就是我们可以指定任意我们指定的配置源到我们的配置框架中去 12IConfigurationSourceIConfigurationProvider 代码实现创建项目创建名字为ConfigurationDemo的控制台应用，通过nuget引入以下两个包： 12Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.Abstractions 完善代码在Program.cs的Main完善测试代码，具体代码如下： 123456789101112131415161718192021222324using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddInMemoryCollection(new Dictionary&lt;string, string&gt;() &#123; &#123;\"key1\", \"value1\"&#125;, &#123;\"key2\", \"value2\"&#125;, &#123;\"sectionA:key4\", \"value4\"&#125; &#125;); var configurationRoot = builder.Build(); Console.WriteLine($\"key1=&#123;configurationRoot[\"key1\"]&#125;\"); Console.WriteLine($\"key2=&#123;configurationRoot[\"key2\"]&#125;\"); var sectionA = configurationRoot.GetSection(\"sectionA\"); Console.WriteLine($\"sectionA:key4=&#123;sectionA[\"key4\"]&#125;\"); &#125; &#125;&#125; 创建一个ConfigurationBuilder对象，添加内存配置源，然后调用Build方法来生成一个IConfigurationRoot对象，通过这个对象可以直接获取配置源的配置项，用:来区分多个层级，通过GetSetion可获取指定层级，可以依次推各个层级的键值对","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(4) -- 用Autofac增强容器能力","slug":"4.DependencyInjectionAutofac_document","date":"2020-03-31T05:13:13.000Z","updated":"2020-04-01T09:04:21.075Z","comments":true,"path":"2020/03/31/4.DependencyInjectionAutofac_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/4.DependencyInjectionAutofac_document/","excerpt":"","text":"引入Autofac增强什么能力 核心扩展点 集成Autofac 代码验证 项目与依赖 在代码中引入Autofac 创建测试服务 获取Autofac根容器 一般注册服务 基于名字注册服务 属性注入 AOP切面拦截器 创建子容器 引入Autofac增强什么能力 基于名称的注入：需要把一个服务按照名称来区分它的不同实现 属性注入：直接把服务注册到某个类的属性里面去，而不需要定义构造函数 子容器：类似原生的scope，但是功能更加丰富 基于动态代理的AOP：当我们需要在服务中注入我们额外的行为的时候 核心扩展点IServiceProviderFactory&lt;TContainerBuilder&gt;：第三方的依赖注入容器都是使用这个类来作为拓展点，把自己注入到整个框架里面来，也就是我们在使用依赖注入框架的时候，不需要关注谁家的特性谁家接口时怎么样的，我们直接使用官方核心的定义即可，不需要直接依赖这些框架 集成Autofac Autofac.Extensions.DependencyInjection Autofac.Extras.DynamicProxy 代码验证项目与依赖创建名字为DependencyInjectionAutofacDemo的ASP.NET Core项目，类型为API 通过nuget引入以下两个包 12Autofac.Extensions.DependencyInjectionAutofac.Extras.DynamicProxy 在代码中引入Autofac在Program.cs的CreateDefaultBuilder后面添加以下代码 1.UseServiceProviderFactory(new AutofacServiceProviderFactory()) UseServiceProviderFactory用来注册第三方容器的入口 在Startup中新增ConfigureContainer方法，代码如下： 123public void ConfigureContainer(ContainerBuilder builder)&#123;&#125; 至此Autofac框架引入完毕，下面要创建测试服务类 创建测试服务创建测试服务MyService.cs类，具体代码如下： 1234567891011121314151617181920212223242526using System;namespace DependencyInjectionAutofacDemo.Services&#123; public interface IMyService &#123; void ShowCode(); &#125; public class MyService : IMyService &#123; public void ShowCode() &#123; Console.WriteLine($\"MyService.ShowCode:&#123;GetHashCode()&#125;\"); &#125; &#125; public class MyServiceV2 : IMyService &#123; public MyNameService MyNameService &#123; get; set; &#125; public void ShowCode() &#123; Console.WriteLine($\"MyServiceV2.ShowCode:&#123;GetHashCode()&#125;,MyNameService是否为空:&#123;MyNameService==null&#125;\"); &#125; &#125; public class MyNameService &#123; &#125;&#125; 创建测试拦截器MyInterceptor.cs，代码如下： 123456789101112131415using System;using Castle.DynamicProxy;namespace DependencyInjectionAutofacDemo.Services&#123; public class MyInterceptor:IInterceptor &#123; public void Intercept(IInvocation invocation) &#123; Console.WriteLine($\"Intercept before,Method:&#123;invocation.Method.Name&#125;\"); invocation.Proceed(); Console.WriteLine($\"Intercept after,Method:&#123;invocation.Method.Name&#125;\"); &#125; &#125;&#125; IInterceptor 是Autofac面向切面最重要的一个接口，他可以把我们的逻辑注入到方法的切面里面去 invocation.Proceed()是指具体方法的执行，如果这句不执行，就相当于把切面方法拦截了，让具体类的方法不执行 获取Autofac根容器在Startup里新增类型为ILifetimeScope的AutofacContainer属性，然后在Configure方法中为这个属性复制为Autofac的根容器，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using Autofac;using Autofac.Extensions.DependencyInjection;using Autofac.Extras.DynamicProxy;using DependencyInjectionAutofacDemo.Services;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace DependencyInjectionAutofacDemo&#123; public class Startup &#123; public Startup(IConfiguration configuration) &#123; Configuration = configuration; &#125; public IConfiguration Configuration &#123; get; &#125; public void ConfigureServices(IServiceCollection services) &#123; services.AddControllers(); &#125; public void ConfigureContainer(ContainerBuilder builder) &#123; &#125; public ILifetimeScope AutofacContainer &#123; get; private set; &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; this.AutofacContainer = app.ApplicationServices.GetAutofacRoot(); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125; &#125;&#125; 一般注册服务在ConfigureContainer方法中进行服务注册，然后在Configure方法中获取服务实现对象，调用服务的ShowCode方法，具体代码如下: 123456789public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyService&gt;().As&lt;IMyService&gt;();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var serviceNoName = this.AutofacContainer.Resolve&lt;IMyService&gt;(); serviceNoName.ShowCode();&#125; Autofac注册服务与ASP.NET Core写法相反，先注册实现类，然后再标记这个实现类为哪种类型 运行项目会看到控制台打印了MyService对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyService.ShowCode:16336406 基于名字注册服务注释掉上一步的测试代码，一样是在ConfigureContainer方法中进行服务注册，然后在Configure方法中获取服务实现对象，调用服务的ShowCode方法，具体代码如下: 123456789public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyServiceV2&gt;().Named&lt;IMyService&gt;(\"service2\");&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.ResolveNamed&lt;IMyService&gt;(\"service2\"); service.ShowCode();&#125; 运行项目会看到控制台打印了MyServiceV2对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyServiceV2.ShowCode:16336406,MyNameService是否为空:True 属性注入注释掉上一步的测试代码，在ConfigureContainer方法中进行服务注册，注意需要先将属性的服务先进行注册，再进行调用方的服务注册，然后一样再Configure中获取对象，调用ShowCode方法 12345678910public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyNameService&gt;(); builder.RegisterType&lt;MyServiceV2&gt;().As&lt;IMyService&gt;().PropertiesAutowired();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.Resolve&lt;IMyService&gt;(); service.ShowCode();&#125; 运行项目会看到控制台打印了MyServiceV2对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyServiceV2.ShowCode:10309404,MyNameService是否为空:False 可以发现MyNameService属性已经不为空了，通过属性注入的操作注入到了服务对象中去，打断点进行调试，可以看出MyNameService类型就是上面注册的类型 AOP切面拦截器注释掉上一步的测试代码，先在ConfigureContainer方法中注册拦截器，然后在服务，并指定拦截器为刚刚所注册的拦截器，并且允许接口拦截器生效，获取服务与上一步操作一致 12345678910public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyInterceptor&gt;(); builder.RegisterType&lt;MyServiceV2&gt;().As&lt;IMyService&gt;().PropertiesAutowired().InterceptedBy(typeof(MyInterceptor)).EnableInterfaceInterceptors();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.Resolve&lt;IMyService&gt;(); service.ShowCode();&#125; 运行项目，可以看到控制台在打印出MyServiceV2的ShowCode方法所打印的信息前后，有拦截器打印出来的信息，类似信息如下： 123Intercept before,Method:ShowCodeMyServiceV2.ShowCode:25116876,MyNameService是否为空:TrueIntercept after,Method:ShowCode 创建子容器子容器主要适用于将服务注册进指定名字的容器里，这样只有在创建出指定名字的容器才可获取到服务对象，其他容器无法获得该服务对象，具体代码如下： 12345678910111213141516171819public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyNameService&gt;().InstancePerMatchingLifetimeScope(\"myScope\");&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; using (var myScope = this.AutofacContainer.BeginLifetimeScope(\"myScope\")) &#123; var service0 = myScope.Resolve&lt;MyNameService&gt;(); using (var scope = myScope.BeginLifetimeScope()) &#123; var service1 = scope.Resolve&lt;MyNameService&gt;(); var service2 = scope.Resolve&lt;MyNameService&gt;(); Console.WriteLine($\"service0=service1:&#123;service0==service1&#125;\"); Console.WriteLine($\"service1=service2:&#123;service1==service2&#125;\"); &#125; &#125;&#125; 运行代码可看到对象获取成功，并且获取到的对象在作用域内为同一个对象，类似信息如下： 12service0&#x3D;service1:Trueservice1&#x3D;service2:True 如果这时候不通过创建指定名字的容器来获得服务对象，会发现代码运行直接报错","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(3) -- 作用域与对象释放行为","slug":"3.DependencyInjectionScopeAndDisposable_document","date":"2020-03-31T04:12:12.000Z","updated":"2020-04-01T09:04:14.822Z","comments":true,"path":"2020/03/31/3.DependencyInjectionScopeAndDisposable_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/31/3.DependencyInjectionScopeAndDisposable_document/","excerpt":"","text":"实现IDisposable接口类型的释放 建议 代码验证 项目 创建测试服务 测试Transient服务的释放时机 测试Scope服务的释放时机 测试Singleton服务的释放时机 避坑 自己new服务 在跟容器获取Transient服务 实现IDisposable接口类型的释放 DI只负责释放其创建的对象实例 DI在容器或子容器释放时，释放尤其创建的对象实例 建议 避免在根容器获取实现了IDisposable接口的瞬时服务 避免手动创建实现了IDisposable对象，应该使用容器来管理其生命周期 代码验证项目创建名为DependencyInjectionScopeAndDisposableDemo的ASP.NET Core项目，类型为API 创建测试服务创建测试服务类OrderService.cs，代码如下： 123456789101112using System;namespace DependencyInjectionScopeAndDisposableDemo.Services&#123; public interface IOrderService &#123; &#125; public class DisposableOrderService : IOrderService, IDisposable &#123; public void Dispose() &#123; Console.WriteLine($\"DisposableOrderService Disposed:&#123;this.GetHashCode()&#125;\"); &#125; &#125;&#125; 测试Transient服务的释放时机在Startup.ConfigureServices里注册一个瞬时服务 1services.AddTransient&lt;IOrderService, DisposableOrderService&gt;(); 在WeatherForecastController里的Get方法通过方法参数的形式获取两个IOrderService接口对象，代码如下： 123456[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2)&#123; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 保存之后运行项目，可以看到在打印接口请求处理结束之后两个对象都被释放掉，类似以下信息 123&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:64923656DisposableOrderService Disposed:11404313 得出的结论是：transient对象会在使用后被释放 测试Scope服务的释放时机注释掉上一步注册瞬时服务的代码，重新注册一个scope服务，这里使用工厂模式，只是熟悉以下工厂模式的写法，没特殊意义 1services.AddScoped&lt;IOrderService&gt;(serviceProvider =&gt; new DisposableOrderService()); 这时运行项目，控制台会打印出一个对象被释放，因为scope服务在当前容器内为单例，下面就这个结论再次测试以下，用using创建一个服务容器出来，看是否能创建出新的服务对象，并且代码运行超过using范围，服务对象是否会被释放。在WeatherForecastController的Get方法新增创建容器和获取服务操作，代码如下： 12345678910111213[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2)&#123; Console.WriteLine(\"========1==========\"); using (var scope = HttpContext.RequestServices.CreateScope()) &#123; var service = scope.ServiceProvider.GetService&lt;IOrderService&gt;(); &#125; Console.WriteLine(\"========2==========\"); Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; HttpContext.RequestServices.CreateScope()表示从根容器中创建一个子容器出来，scope.ServiceProvider.GetService&lt;IOrderService&gt;()表示从创建出来的子容器获取IOrderService的服务实现对象，运行项目可以得到两个对象被释放的信息，类似以下信息： 12345&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:5568949&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:31307802 得出结论是：scope对象会在对象产生的容器被释放的时候同时一起释放 测试Singleton服务的释放时机注释掉上一步注册scope服务的代码，重新注册一个singleton服务，这里一样使用工厂模式 1services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt; new DisposableOrderService()); 将WeatherForecastController的Get方法修改为以下代码： 1234567891011[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2,[FromServices] IHostApplicationLifetime hostApplicationLifetime,[FromQuery]bool isStop=false)&#123; if (isStop) &#123; hostApplicationLifetime.StopApplication(); &#125; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 这里有获取了另一个服务IHostApplicationLifetime，这个服务对象控制了整个应用程序的生命周期，可以调用这个服务对象的StopApplication方法来停止应用程序，即停止整个站点，为了方便测试这里用了isStop这个参数来控制是否停止应用程序 运行项目，不管怎么刷新/WeatherForecast链接，都不会有对象被释放的信息打印出来，访问/WeatherForecast?isStop=true的时候，会看到应用程序被停止，同时打印出对象被释放的信息，类似以下信息： 12Application is shutting down...DisposableOrderService Disposed:3165221 得出结论是：scope对象只会在根容器释放的时候才会被释放，即所有单例模式的对象都会被注册在根容器上面 避坑自己new服务开始有个结论：DI只负责释放其创建的对象实例，这里进行验证以下自己new一个对象然后注入到容器中，看看是否能释放。这里注入了一个singleton对象，需注释掉上面做测试的代码，代码如下 12var myOrderService &#x3D; new DisposableOrderService();services.AddSingleton&lt;IOrderService&gt;(myOrderService); 控制器代码不用改，运行项目，访问/WeatherForecast发现不会有对象被释放，访问/WeatherForecast?isStop=true时，应用程序被停止，但是也一样没有对象被释放的信息，所以这个对象最终还是没被释放 在跟容器获取Transient服务注释掉上面的测试代码，在Startup.ConfigureServices中注册一个瞬时服务，代码如下： 1services.AddTransient&lt;IOrderService, DisposableOrderService&gt;(); 在Startup.Configure中从根容器获取瞬时服务对象，代码如下： 123456789101112131415public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var s = app.ApplicationServices.GetService&lt;IOrderService&gt;(); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 将WeatherForecastController的Get方法修改为以下代码： 1234567891011[HttpGet]public int Get([FromServices] IHostApplicationLifetime hostApplicationLifetime, [FromQuery]bool isStop = false)&#123; if (isStop) &#123; hostApplicationLifetime.StopApplication(); &#125; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 运行项目，访问/WeatherForecast接口，发现并不会有对象被释放的信息，在带上isStop=true的参数的时候，应用程序被停止，这时才有对象被释放的信息，类似信息如下： 12Application is shutting down...DisposableOrderService Disposed:41149443 得出结论：由于根容器只会在应用程序整个退出时回收，这就意味着即使这是个瞬时服务，但是应用程序不退出，这些对象会一直积累在应用程序内不得释放","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(2) -- 依赖注入：良好架构的起点","slug":"2.DependencyInjection_document","date":"2020-03-30T02:12:12.000Z","updated":"2020-04-01T09:04:05.594Z","comments":true,"path":"2020/03/30/2.DependencyInjection_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/30/2.DependencyInjection_document/","excerpt":"","text":"为什么要使用依赖注入框架(IoC框架) 依赖注入框架组件包 依赖注入框架核心类型 生命周期 代码演示 项目 示例服务类 验证不同生命周期的实现 注册不同生命周期的服务 在方法参数中获得服务进行验证 其他方式注册服务(以单例模式为例) 直接new对象 通过工厂模式注册对象 尝试注册服务 移除和替换服务 移除服务 替换服务 泛型服务注册 服务对象的获取 为什么要使用依赖注入框架(IoC框架) 借助依赖注入框架，我们可以轻松管理类之间的依赖，帮助我们在构建应用是遵循设计规则，确保代码的可维护性和可拓展性 ASP.NET Core的整个架构中，依赖注入框架提供了对象创建和生命周期管理的核心能力，各个组件相互写作，也是由依赖注入框架的能力来实现的 依赖注入框架组件包12Microsoft.Extensions.DependencyInjection.Abstractions &#x2F;&#x2F;抽象包Microsoft.Extensions.DependencyInjection &#x2F;&#x2F;具体实现 依赖注入框架核心类型1234IServiceCollection &#x2F;&#x2F;负责服务的注册ServiceDescriptor &#x2F;&#x2F;每个服务注册时的信息IServiceProvider &#x2F;&#x2F;具体的容器，也是由ServiceCollection Build出来IServiceScope &#x2F;&#x2F;表示一个容器的子容器的生命周期 生命周期123Singleton &#x2F;&#x2F;单例：在整个根容器的生命周期内获得的都是同一个单例对象Scoped &#x2F;&#x2F;作用域：在我的Scope的生命周期内，如果我的容器释放掉，则意味着我的对象释放掉，在这个生命周期范围内获得到的是一个单例对象Transient &#x2F;&#x2F;瞬时：每一次从容器里获取对象时都产生一个新的对象 代码演示项目创建名为DependencyInjectionDemo的ASP.NET Core项目，类型为API 示例服务类一共有5个示例服务类接口，分别为 1234567891011IGenericService&lt;T&gt; |-- GenericService&lt;T&gt; &#x2F;&#x2F;对应实现类IMyScopeService |-- MyScopeService &#x2F;&#x2F;对应实现类IMySingletonService |-- MySingletonService &#x2F;&#x2F;对应实现类IMyTransientService |-- MyTransientService &#x2F;&#x2F;对应实现类IOrderService |-- OrderService &#x2F;&#x2F;对应实现类 |-- OrderServiceEX &#x2F;&#x2F;对应实现类 因为是示例服务类，所以所有类和服务均没有属性和方法，纯粹为了验证服务注册和服务对象 验证不同生命周期的实现注册不同生命周期的服务在Startup.ConfigureServices方法中新增以下代码 123456// 注册Singleton服务services.AddSingleton&lt;IMySingletonService, MySingletonService&gt;();// 注册Scope服务services.AddScoped&lt;IMyScopeService, MyScopeService&gt;();// 注册Transient服务services.AddTransient&lt;IMyTransientService, MyTransientService&gt;(); 在方法参数中获得服务进行验证 修改WeatherForecastController类的Route标识为[Route(&quot;[controller]/[action]&quot;)]，方便进行测试 在WeatherForecastController新增GetService方法，代码如下：1234567891011121314151617[HttpGet]public int GetService([FromServices] IMySingletonService singletonService1, [FromServices] IMySingletonService singletonService2, [FromServices] IMyScopeService scopeService1, [FromServices] IMyScopeService scopeService2, [FromServices] IMyTransientService transientService1, [FromServices] IMyTransientService transientService2)&#123; Console.WriteLine($\"&#123;nameof(singletonService1)&#125;:&#123;singletonService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(singletonService2)&#125;:&#123;singletonService2.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(scopeService1)&#125;:&#123;scopeService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(scopeService2)&#125;:&#123;scopeService2.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(transientService1)&#125;:&#123;transientService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(transientService2)&#125;:&#123;transientService2.GetHashCode()&#125;\"); Console.WriteLine(\"=========请求结束========\"); return 1;&#125; 运行项目，访问/WeatherForecast/GetService，控制台会打印出类似以下信息1234567singletonService1:23488915singletonService2:23488915scopeService1:24854661scopeService2:24854661transientService1:38972574transientService2:14645893&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 可以看出IMySingletonService的实现对象属于同一个对象，IMyTransientService的实现对象有多个，目前看IMyScopeService的实现对象为同一个，但是再次访问/WeatherForecast/GetService接口，就可以发现IMyScopeService的实现对象为新的对象，而IMySingletonService的实现对象还是上次访问的那个，打印信息如下1234567singletonService1:23488915singletonService2:23488915scopeService1:6630602scopeService2:6630602transientService1:5024928transientService2:38414640&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 其他方式注册服务(以单例模式为例)直接new对象在Startup.ConfigureServices方法中新增以下代码 1services.AddSingleton&lt;IOrderService&gt;(new OrderService()); 通过工厂模式注册对象使用工厂模式注册对象，可以在委托中使用IServiceProvider参数，这也就意味着可以从容器里获取多个对象，然后进行组装，得到我们最终需要的实现实例，可以把工厂类设计的比较复杂，比如说我们的实现类依赖了容器里面的另外一个类的情况，或者我们期望用另外一个类来包装我们原有的实现的时候在Startup.ConfigureServices方法中新增以下代码 1234services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt;&#123; return new OrderServiceEx();&#125;); 尝试注册服务尝试注册服务有两种情况 当指定接口已有实现类，则不再注册服务，代码如下：1services.TryAddSingleton&lt;IOrderService, OrderServiceEx&gt;(); 当指定接口已有实现类，但是已注册的实现类不包含当前指定的实现类，则注册进去，如果已经包含当前的实现类，则不再注册服务，代码如下：1services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IOrderService,OrderService&gt;()); 在控制器里验证是否有多个实现类注册，可通过下面的方法验证(需要自行注释或修改Startup里面的服务注册情况)123456789[HttpGet]public int GetServiceList([FromServices] IEnumerable&lt;IOrderService&gt; orderServices)&#123; foreach (var item in orderServices) &#123; Console.WriteLine($\"获取到服务实例：&#123;item.ToString()&#125;:&#123;item.GetHashCode()&#125;\"); &#125; return 1;&#125; 移除和替换服务移除服务指的是直接从容器中移除指定接口的所有实现类，代码如下：1services.RemoveAll&lt;IOrderService&gt;(); 替换服务指的是替换指定接口的实现类，同时也会替换该服务的生命周期，代码如下：1services.Replace(ServiceDescriptor.Singleton&lt;IOrderService, OrderServiceEx&gt;()); 泛型服务注册即对泛型服务注册，代码如下： 1services.AddSingleton(typeof(IGenericService&lt;&gt;), typeof(GenericService&lt;&gt;)); 可以通过在控制器的构造函数中获取到服务对象，代码如下： 1234public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,IOrderService orderService,IGenericService&lt;IOrderService&gt; genericService)&#123; _logger = logger;&#125; 可以通过断点查看最终IGenericService的IOrderService为哪个实现类 服务对象的获取通过上面可以看出，服务对象有两种获取方式，一种是通过构造函数直接注入，一种是通过函数参数，使用[FromServices]标签来注入 一般按照使用情况来确定用哪种方式，如果整个类使用地方比较多，则使用构造函数注入，如果只有某一个方法使用，则一般使用函数参数来注入","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(1) -- ASP.NET Core的启动流程","slug":"1.StartupDemo_document","date":"2020-03-29T02:11:21.000Z","updated":"2020-04-01T09:03:58.277Z","comments":true,"path":"2020/03/29/1.StartupDemo_document/","link":"","permalink":"http://www.dimsum.fun/2020/03/29/1.StartupDemo_document/","excerpt":"","text":"课程目标 创建项目 添加日志代码 运行结果 结论 另外 课程目标主要是掌握ASP.NET Core应用程序启动的流程，同时了解启动过程中哪些方法做了哪些操作 创建项目创建ASP.NET Core Web项目，项目类型选择API，直接创建即可 添加日志代码本实例不涉及任何业务代码，纯粹只是添加日志查看各个方法的调用流程 修改Program.cs，以下直接放修改后的代码 12345678910111213141516171819202122232425262728293031323334using System;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateHostBuilder(args).Build().Run(); &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; Console.WriteLine(\"ConfigureWebHostDefaults\"); webBuilder.UseStartup&lt;Startup&gt;(); &#125;) .ConfigureServices(service =&gt; &#123; Console.WriteLine(\"ConfigureServices\"); &#125;) .ConfigureAppConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureAppConfiguration\"); &#125;) .ConfigureHostConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureHostConfiguration\"); &#125;); &#125;&#125; 修改Startup.cs，以下直接放修改后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Startup &#123; public Startup(IConfiguration configuration) &#123; Console.WriteLine(\"Startup.Ctor\"); Configuration = configuration; &#125; public IConfiguration Configuration &#123; get; &#125; public void ConfigureServices(IServiceCollection services) &#123; Console.WriteLine(\"Startup.ConfigureServices\"); services.AddControllers(); &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; Console.WriteLine(\"Startup.Configure\"); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseStaticFiles(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125; &#125;&#125; 运行结果参照上面将代码修改完，直接运行代码，控制台将打印出以下信息 1234567ConfigureWebHostDefaultsConfigureHostConfigurationConfigureAppConfigurationStartup.CtorStartup.ConfigureServicesConfigureServicesStartup.Configure 结论以下为ASP.NET Core启动运行流程 ConfigureWebHostDefaults：注册了应用程序必要的几个组件，比如说配置的组件、容器的组件等 ConfigureHostConfiguration：配置程序启动时必要的配置，比如说程序启动时所需要监听的端口、需要监听的URL地址等，在这个过程可以嵌入我们自己的配置内容注入到配置的框架中去 ConfigureAppConfiguration：嵌入我们自己的配置文件，供应用程序来读取，这些配置将来会在后续的应用程序执行过程中每个组件读取 ConfigureServices/ConfigureLogging/Startup/Startup.ConfigureServices：这些都是往容器里面来注入我们的应用的组件 Startup.Configure：注入中间件，处理HttpContext整个的请求过程 另外从代码运行来看，Startup.cs这个类可以被整合到Program.cs里的ConfigureWebHostDefaults方法中，可以直接ConfigureWebHostDefaults方法中直接使用webBuilder调用ConfigureServices和Configure两个方法具体可以参考以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateHostBuilder(args).Build().Run(); &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; Console.WriteLine(\"ConfigureWebHostDefaults\"); webBuilder.ConfigureServices(services =&gt; &#123; Console.WriteLine(\"Program.ConfigureServices\"); services.AddControllers(); &#125;); webBuilder.Configure(app =&gt; &#123; Console.WriteLine(\"Program.Configure\"); app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseStaticFiles(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125;); &#125;) .ConfigureServices(service =&gt; &#123; Console.WriteLine(\"ConfigureServices\"); &#125;) .ConfigureAppConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureAppConfiguration\"); &#125;) .ConfigureHostConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureHostConfiguration\"); &#125;); &#125;&#125; 但是为了代码结构更加合理，还是需要用Startup这个类来分离变动比较大的代码 通常是在Startup.ConfigureServices的方法里做服务注册，一般是Addxxx 在Startup.Configure决定注册那些中间件到处理过程中去","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core使用Cap","slug":"dotnet-core-cap","date":"2020-03-27T05:13:13.000Z","updated":"2020-04-01T09:05:51.498Z","comments":true,"path":"2020/03/27/dotnet-core-cap/","link":"","permalink":"http://www.dimsum.fun/2020/03/27/dotnet-core-cap/","excerpt":"","text":"准备工作 项目设定 创建ServiceA 创建ServiceB 准备工作CAP需要依赖消息队列和数据存储，支持情况如下：消息队列 123KafkaRabbitMQAzureServiceBus 数据存储 1234SqlServerMySqlPostgreSqlMongoDB 两者自行搭配选择即可，其中SqlServer和RabbitMQ在docker中的安装可参照我另一篇备忘开发常用的docker镜像 项目设定 两个服务，分别为ServiceA,ServiceB SqlServer使用CapDemo数据库，默认sa账号，密码为Today_is_20200328，端口为默认的1433端口 RabbitMQ安装地址为本机，默认端口，账号密码为admin/admin 创建ServiceA 在Visual Studio 2019中创建空白解决方案，取名为Jiamiao.x.CapDemo 在解决方案中新建Asp.net core项目，名字为Jiamiao.x.CapDemo.ServiceA，.net core版本为3.1 nuget安装以下4个包 1234DotNetCore.CAPDotNetCore.CAP.DashboardDotNetCore.CAP.RabbitMQDotNetCore.CAP.SqlServer 在Startup.cs的ConfigureServices方法中加入以下代码 1234567891011services.AddCap(options =&gt;&#123; options.UseSqlServer(\"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1\"); options.UseRabbitMQ(r =&gt; &#123; r.HostName = \"127.0.0.1\"; r.UserName = \"admin\"; r.Password = \"admin\"; &#125;); options.UseDashboard();&#125;); 此时直接运行项目，如果数据库与消息队列均能正常连接，则会在数据库中生成以下两张表 12cap.Publishedcap.Received 在Controllers/WeatherForecastController.cs中编写消息发布代码 6.1 通过构造函数依赖注入ICapPublisher对象 6.2 发布消息只需要调用ICapPublisher对象的PublishAsync或Publish方法，传入参数为队列名和消息值，全部代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace Jiamiao.x.CapDemo.ServiceA.Controllers&#123; [ApiController] [Route(\"[controller]\")] public class WeatherForecastController : ControllerBase &#123; private static readonly string[] Summaries = new[] &#123; \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\" &#125;; private readonly ILogger&lt;WeatherForecastController&gt; _logger; private readonly ICapPublisher _capPublisher; public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,ICapPublisher capPublisher) &#123; _logger = logger; _capPublisher = capPublisher; &#125; [HttpGet] public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; Get() &#123; await _capPublisher.PublishAsync(\"jiamiao.x.cap.demo.show.time\", DateTime.Now); var rng = new Random(); return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast &#123; Date = DateTime.Now.AddDays(index), TemperatureC = rng.Next(-20, 55), Summary = Summaries[rng.Next(Summaries.Length)] &#125;) .ToArray(); &#125; &#125;&#125; 编写接收消息代码，接收消息有两种方式，一种在控制器中，即代码写在***Controller.cs中，另一种是在非控制器中，一般为***Service.cs中，以下分两步执行，因为CAP在默认情况下一个服务多个地方进行订阅，只会进行一次接收，除非进行分组(后面介绍)，所以8/9两个步骤在测试时需要注释其中一个，只保留另一个 编写在控制器中接收消息的代码，直接在控制器中写对应方法，方法参数为发送消息时传入的消息值类型，方法无返回值，再加上方法标签CapSubscribe即可，具体代码如下: 123456789101112131415161718using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;using Microsoft.AspNetCore.Mvc;namespace Jiamiao.x.CapDemo.ServiceA.Controllers&#123; public class SubController : Controller &#123; [CapSubscribe(\"jiamiao.x.cap.demo.show.time\")] public void ShowTime(DateTime value) &#123; Console.WriteLine($\"接受方：SubController.ShowTime 接收到值：&#123;value&#125;\"); &#125; &#125;&#125; 做到这步可以进行一次测试，就可以发现访问/WeatherForecast这个接口，会发送一条当前时间的消息出去，同时接收方也会在控制台打印出接收到的消息 编写服务中接收消息的代码，需要注意接收消息的类需要继承ICapSubscribe接口，同时这里为了方便进行依赖注入，这里我们也自己定义了一个ISubscriberService接口，同时服务需要在Startup.cs的ConfigureServices方法中进行注册 9.1 ISubscriberService.cs代码如下 123456789101112using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;namespace Jiamiao.x.CapDemo.ServiceA.Services&#123; public interface ISubscriberService &#123; void ReceivedShowTimeMessage(DateTime value); &#125;&#125; 9.2 SubscriberService.cs代码如下 1234567891011121314151617using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;namespace Jiamiao.x.CapDemo.ServiceA.Services&#123; public class SubscriberService: ISubscriberService, ICapSubscribe &#123; [CapSubscribe(\"jiamiao.x.cap.demo.show.time\")] public void ReceivedShowTimeMessage(DateTime value) &#123; Console.WriteLine($\"接受方：SubscriberService.ReceivedShowTimeMessage 接收到值：&#123;value&#125;\"); &#125; &#125;&#125; 9.3 服务注册代码如下 1services.AddScoped&lt;ISubscriberService, SubscriberService&gt;(); 注意：这行服务注册代码需要在services.AddCap这个方法之前注册，否则CAP在进行接口扫描的时候找不到对应已经实现了ICapSubscribe接口的实现类，则无法进行订阅者注册 注释掉第8步，进行第9步的测试，效果应该与第8步一致 有时候一个消息需要多个消费者同时消费，则可以使用Group概念，消息发送代码不变，在标记CapSubscribe的时候，使用Group参数，多个Group订阅同个消息Id，消息则会对应分发到多个Group中，同个Group只能消费一次，即一个Group对一个消息Id订阅多次，也会只接收一次，具体代码如下SubscriberService.cs中新增Group参数1[CapSubscribe(\"jiamiao.x.cap.demo.show.time\",Group = \"SubscriberService\")] SubController.cs中新增Group参数1[CapSubscribe(\"jiamiao.x.cap.demo.show.time\",Group = \"SubController\")] 测试Group功能，将项目跑起来，此时再访问发送消息的api，会在控制台中打印出两条消息接收记录 创建ServiceBServiceB使用EFCore来进行配置，找ServiceA步骤2创建Jiamiao.x.CapDemo.ServiceB项目，因为.Net Core 3.1没有自带EFCore，所以这里除了CAP的4个包之外，还需要nuget安装EFCore的两个包，汇总起来需要nuget安装的包如下： 123456DotNetCore.CAPDotNetCore.CAP.DashboardDotNetCore.CAP.RabbitMQDotNetCore.CAP.SqlServerMicrosoft.EntityFrameworkCoreMicrosoft.EntityFrameworkCore.SqlServer创建ServiceDbContext.cs文件，代码如下 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using Microsoft.EntityFrameworkCore;namespace Jiamiao.x.CapDemo.ServiceB.Infrastructure&#123; public class ServiceDbContext: DbContext &#123; public ServiceDbContext(DbContextOptions&lt;ServiceDbContext&gt; options):base(options) &#123; &#125; &#125;&#125;在Startup.cs中配置EFCore和CAP，具体代码如下： 1234567891011121314151617services.AddDbContext&lt;ServiceDbContext&gt;(options =&gt;&#123; options.UseSqlServer( \"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1\");&#125;);services.AddCap(options =&gt;&#123; options.UseEntityFramework&lt;ServiceDbContext&gt;(); options.UseRabbitMQ(r =&gt; &#123; r.HostName = \"127.0.0.1\"; r.UserName = \"admin\"; r.Password = \"admin\"; &#125;); options.UseDashboard();&#125;);后续操作与ServiceA类似，需要注意：多个站点订阅同个消息Id，消息会往多个站点进行发送 附上CAP的Github地址:https://github.com/dotnetcore/CAP 还有一些配合EF的操作还没来得及写，有空再说吧","categories":[{"name":".NET","slug":"NET","permalink":"http://www.dimsum.fun/categories/NET/"}],"tags":[{"name":".NET Core","slug":"NET-Core","permalink":"http://www.dimsum.fun/tags/NET-Core/"},{"name":"CAP","slug":"CAP","permalink":"http://www.dimsum.fun/tags/CAP/"},{"name":"MicroServices","slug":"MicroServices","permalink":"http://www.dimsum.fun/tags/MicroServices/"}]},{"title":"开发常用的docker镜像","slug":"chang-yong-docker","date":"2020-03-27T04:12:12.000Z","updated":"2020-05-14T14:56:46.515Z","comments":true,"path":"2020/03/27/chang-yong-docker/","link":"","permalink":"http://www.dimsum.fun/2020/03/27/chang-yong-docker/","excerpt":"","text":"Redis Elasticsearch(集群) RabbitMq SqlServer 2017 主要用于开发阶段，不涉及生产环境配置，无权限自行添加sudo Redis 获取镜像1docker pull redis 运行Redis1docker run -p 6379:6379 -d redis:lastes redis-server Elasticsearch(集群) 说明： 这里这里使用的是Elasticsearch 7.3.0版本 集群一共有3个Container，一个Master，两个Slave 配置文件中的192.168.2.58为对应节点的IP地址 具体配置:12345678910111213141516Elasticsearch集群 |------ Master |--- 端口：9500 |--- TCP端口：9300 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data |------ Slave1 |--- 端口：9600 |--- TCP端口：9301 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data |------ Slave2 |--- 端口：9700 |--- TCP端口：9302 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data 获取镜像1docker pull elasticsearch:7.3.0 在宿主机创建各个节点的elasticsearch.yml配置文件，具体内容如下: Master节点，配置文件路径：~/var/elasticsearch/config/master/elasticsearch.yml12345678910111213141516171819# 设置支持Elasticsearch-Headhttp.cors.enabled: truehttp.cors.allow-origin: \"*\"# 设置集群Master配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: master# 节点是否为Master，设置为true的话，说明此节点为Master节点node.master: true# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9500# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9300# 手动指定可以成为Master的所有节点的Name或者IP，这些配置将会在第一次选举中进行计算cluster.initial_master_nodes: [\"master\"]# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9301\", \"192.168.2.58:9302\"] Slave1节点，配置文件路径：~/var/elasticsearch/config/slave1/elasticsearch.yml1234567891011121314# 设置集群Slave配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: slave1# 节点是否为Master，设置为true的话，说明此节点为master节点node.master: false# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9600# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9301# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9300\", \"192.168.2.58:9302\"] Slave2节点，配置文件路径：~/var/elasticsearch/config/slave2/elasticsearch.yml1234567891011121314# 设置集群Slave配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: slave2# 节点是否为Master，设置为true的话，说明此节点为master节点node.master: false# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9700# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9302# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9300\", \"192.168.2.58:9301\"] 创建3个节点的data文件夹 123~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data 运行节点 运行Master节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/master/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/master/data:/usr/share/elasticsearch/data --name esMaster -p 9500:9500 -p 9300:9300 elasticsearch:7.3.0 运行Slave1节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/slave1/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave1/data:/usr/share/elasticsearch/data --name esSlave1 -p 9600:9600 -p 9301:9301 elasticsearch:7.3.0 运行Slave2节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/slave2/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave2/data:/usr/share/elasticsearch/data --name esSlave2 -p 9700:9700 -p 9302:9302 elasticsearch:7.3.0 检查运行状态 运行docker ps查看正在运行的Container，确保以上3个容器正常运行 访问http://127.0.0.1:9500/_cat/nodes?v查看是否有3个节点信息，如果节点运行正常，应该有如下信息1234ip heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name172.17.0.2 32 96 70 3.03 0.82 0.28 di - slave1172.17.0.3 30 96 70 3.03 0.82 0.28 di - slave2172.17.0.4 33 96 70 3.03 0.82 0.28 dim * master 安装Elasticsearch-Head1docker run -d --name es-head -p 9100:9100 mobz/elasticsearch-head:5 运行成功后浏览器访问链接:http://127.0.0.1:9100，将里面的连接地址修改为:http://localhost:9500，保存即可看到3个节点的集群信息 安装IK分词软件 这部分操作3个节点均需要操作一边 ElasticSearch版本为7.3.0，对应IK分词版本为7.3,下载链接IK分词 具体操作就是将下载下来的包放在各个节点的共享卷里，然后进入ES容器内命令行，解压并将文件拷贝到plugins文件夹中，重启容器 RabbitMq 获取镜像1docker pull rabbitmq:management 运行镜像，设置用户名密码(admin/admin)1docker run -dit --name Myrabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:management 进入管理界面 http://localhost:15672 SqlServer 2017 获取镜像1docker pull mcr.microsoft.com/mssql/server:2017-latest 运行镜像，设置SA密码为Today_is_202003281docker run -e \"ACCEPT_EULA=Y\" -e \"SA_PASSWORD=Today_is_20200328\" -p 1433:1433 --name mssql -d mcr.microsoft.com/mssql/server:2017-latest","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.dimsum.fun/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.dimsum.fun/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://www.dimsum.fun/tags/elasticsearch/"}]}],"categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://www.dimsum.fun/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"事务","slug":"事务","permalink":"http://www.dimsum.fun/categories/%E4%BA%8B%E5%8A%A1/"},{"name":"Redis","slug":"Redis","permalink":"http://www.dimsum.fun/categories/Redis/"},{"name":"消息队列","slug":"消息队列","permalink":"http://www.dimsum.fun/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"C#","slug":"C","permalink":"http://www.dimsum.fun/categories/C/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/categories/SQL-Server/"},{"name":"面试","slug":"面试","permalink":"http://www.dimsum.fun/categories/%E9%9D%A2%E8%AF%95/"},{"name":"C#基础备忘","slug":"C-基础备忘","permalink":"http://www.dimsum.fun/categories/C-%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98/"},{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/categories/ASP-NET-Core/"},{"name":"Docker","slug":"Docker","permalink":"http://www.dimsum.fun/categories/Docker/"},{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://www.dimsum.fun/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"},{"name":"StepByStep","slug":"StepByStep","permalink":"http://www.dimsum.fun/categories/StepByStep/"},{"name":".NET","slug":"NET","permalink":"http://www.dimsum.fun/categories/NET/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.dimsum.fun/tags/Git/"},{"name":"事务","slug":"事务","permalink":"http://www.dimsum.fun/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"Redis","slug":"Redis","permalink":"http://www.dimsum.fun/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://www.dimsum.fun/tags/NOSQL/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://www.dimsum.fun/tags/RabbitMQ/"},{"name":"消息队列","slug":"消息队列","permalink":"http://www.dimsum.fun/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"C#","slug":"C","permalink":"http://www.dimsum.fun/tags/C/"},{"name":"多线程","slug":"多线程","permalink":"http://www.dimsum.fun/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"T-SQL","slug":"T-SQL","permalink":"http://www.dimsum.fun/tags/T-SQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://www.dimsum.fun/tags/SQL-Server/"},{"name":"面试","slug":"面试","permalink":"http://www.dimsum.fun/tags/%E9%9D%A2%E8%AF%95/"},{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://www.dimsum.fun/tags/ASP-NET-Core/"},{"name":"gRPC","slug":"gRPC","permalink":"http://www.dimsum.fun/tags/gRPC/"},{"name":"DDD","slug":"DDD","permalink":"http://www.dimsum.fun/tags/DDD/"},{"name":"CQRS","slug":"CQRS","permalink":"http://www.dimsum.fun/tags/CQRS/"},{"name":"MediatR","slug":"MediatR","permalink":"http://www.dimsum.fun/tags/MediatR/"},{"name":"EntityFramework Core","slug":"EntityFramework-Core","permalink":"http://www.dimsum.fun/tags/EntityFramework-Core/"},{"name":"ORM","slug":"ORM","permalink":"http://www.dimsum.fun/tags/ORM/"},{"name":"Docker","slug":"Docker","permalink":"http://www.dimsum.fun/tags/Docker/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://www.dimsum.fun/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"},{"name":"微服务","slug":"微服务","permalink":"http://www.dimsum.fun/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://www.dimsum.fun/tags/Visual-Studio-Code/"},{"name":"特基础","slug":"特基础","permalink":"http://www.dimsum.fun/tags/%E7%89%B9%E5%9F%BA%E7%A1%80/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://www.dimsum.fun/tags/NET-Core/"},{"name":"CAP","slug":"CAP","permalink":"http://www.dimsum.fun/tags/CAP/"},{"name":"MicroServices","slug":"MicroServices","permalink":"http://www.dimsum.fun/tags/MicroServices/"},{"name":"docker","slug":"docker","permalink":"http://www.dimsum.fun/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://www.dimsum.fun/tags/elasticsearch/"}]}