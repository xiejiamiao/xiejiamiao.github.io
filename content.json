{"meta":{"title":"dimsum","subtitle":"","description":"","author":"Jiamiao.x","url":"http://doc.dimsum.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-27T07:39:01.629Z","updated":"2020-03-27T07:22:15.606Z","comments":false,"path":"/404.html","permalink":"http://doc.dimsum.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2020-03-27T07:39:01.578Z","updated":"2020-03-27T07:22:15.608Z","comments":false,"path":"books/index.html","permalink":"http://doc.dimsum.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-27T07:39:01.605Z","updated":"2020-03-27T07:22:15.608Z","comments":false,"path":"about/index.html","permalink":"http://doc.dimsum.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2020-03-27T07:39:01.525Z","updated":"2020-03-27T07:22:15.609Z","comments":true,"path":"links/index.html","permalink":"http://doc.dimsum.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-27T07:39:01.476Z","updated":"2020-03-27T07:22:15.610Z","comments":false,"path":"tags/index.html","permalink":"http://doc.dimsum.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-27T07:39:01.549Z","updated":"2020-03-27T07:22:15.609Z","comments":false,"path":"categories/index.html","permalink":"http://doc.dimsum.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-27T07:39:01.501Z","updated":"2020-03-27T07:22:15.609Z","comments":false,"path":"repository/index.html","permalink":"http://doc.dimsum.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"特基础教程系列","slug":"StepByStep","date":"2020-04-01T14:18:00.000Z","updated":"2020-04-01T16:49:32.267Z","comments":true,"path":"2020/04/01/StepByStep/","link":"","permalink":"http://doc.dimsum.com/2020/04/01/StepByStep/","excerpt":"","text":"Visual Studio Code 下载安装 关于安装扩展插件 关于汉化 平时写静态页流程 todo:常用的vscode插件 todo:常用的vscode代码段 Visual Studio Code下载安装下载地址：https://code.visualstudio.com/，下载之后双击安装即可 关于安装扩展插件如下图，点击左边的插件tab，输入插件名称进行搜索，然后点击install即可进行安装 关于汉化vscode的汉化包使用的也是通过插件的形式来安装，搜索chinese，找到Chinese (Simplified) Language Pack for Visual Studio Code这个插件进行安装，安装完重启即可 平时写静态页流程 一般我会在电脑指定一个盘创建一个文件夹，指定这个文件夹存放自己的源码，无论个人电脑还是公司电脑，比如G盘里创建了repo的文件夹作为我统一管理源码的文件夹 通常自己写代码会分两种级别，一种是为了学习测试而写的demo，一种是比较有一定业务逻辑需求的小项目，所以一般会在repo文件夹下再创建两个文件夹，分别为jiamiao.x.demo和jiamiao.x.project 注意一点，无论是在写demo还是写project，都不要出现类似demo1、demo2、project1、project2这种没意义的名字，以下以我写一段表单demo为例子： 在G:/repo/jiamiao.x.demo的文件夹中创建文件夹form_demo，然后再form_demo文件夹上右键，点击通过Code打开 打开之后可以看到左边有文件夹的目录，当前现在是一片空白，如下图： 接下来在vscode中操作，在FORM_DEMO下方空白处右键，点击新建文件，输入index.html回车，可以看到创建了index.html文件，在右边的编辑区则可以进行编码，只要文件扩展名.html正确，则可以代码高亮和智能提示 当静态页需要引用图片、样式、脚本等，可以在FORM_DEMO下方空白处右键，点击新建文件夹，对应输入image/style/script等名字之后回车即可 写完页面之后，可以右键index.html文件，点击Open In Default Browser(需要安装插件Open in Browser)，直接打开浏览器来查看页面效果，如下图： todo:常用的vscode插件todo:常用的vscode代码段","categories":[{"name":"StepByStep","slug":"StepByStep","permalink":"http://doc.dimsum.com/categories/StepByStep/"}],"tags":[{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://doc.dimsum.com/tags/Visual-Studio-Code/"},{"name":"特基础","slug":"特基础","permalink":"http://doc.dimsum.com/tags/%E7%89%B9%E5%9F%BA%E7%A1%80/"}]},{"title":".NET Core开发实战课程备忘(10) -- 选项框架：服务组件集成配置的最佳实现","slug":"10.Option_document","date":"2020-04-01T05:13:13.000Z","updated":"2020-04-01T09:04:58.074Z","comments":true,"path":"2020/04/01/10.Option_document/","link":"","permalink":"http://doc.dimsum.com/2020/04/01/10.Option_document/","excerpt":"","text":"选项框架特性 设计原则 建议 代码实现 创建测试服务与测试服务对应的选项 修改appsettings.json 注册服务和选项 获取服务进行测试 选项框架热更新 关键类型 代码示例 IOptionsSnapshot IOptionsMonitor IOptionsMonitor监听配置变动 优化代码结构 动态修改选项值 选项框架特性 支持单例模式读取配置 支持快照 支持配置变更通知 支持运行时动态修改选项值 设计原则 接口分离原则(ISP)，我们的类不应该依赖它不使用的配置 关注点分离(SoC)，不同组件、服务、类之间的配置不应相互依赖或耦合 建议 为我们的服务设计XXXOptions 使用IOptions&lt;XXXOptions&gt;、IOptionsSnapshot&lt;XXXOptions&gt;、IOptionsMonitor&lt;XXXOptions&gt;作为服务构造函数的参数 代码实现创建名为OptionsDemo的ASP.NET Core项目，类型为API 创建测试服务与测试服务对应的选项创建OrderService.cs为了方便测试，这里将IOrderService、OrderService、OrderServiceOption都放在OrderService.cs文件中，具体代码如下： 12345678910111213141516171819202122232425262728using Microsoft.Extensions.Options;namespace OptionsDemo.Services&#123; public interface IOrderService &#123; int ShowMaxOrderCount(); &#125; public class OrderService:IOrderService &#123; private readonly IOptions&lt;OrderServiceOptions&gt; _options; public OrderService(IOptions&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.Value.MaxOrderCount; &#125; &#125; public class OrderServiceOptions &#123; public int MaxOrderCount &#123; get; set; &#125; = 100; &#125;&#125; 修改appsettings.json将项目中的appsettings.json的内容修改如下： 12345678910111213&#123; \"Logging\": &#123; \"LogLevel\": &#123; \"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" &#125; &#125;, \"AllowedHosts\": \"*\", \"OrderService\": &#123; \"MaxOrderCount\": 400 &#125; &#125; 注册服务和选项在Startup.ConfigureServices中添加以下代码： 12services.Configure&lt;OrderServiceOptions&gt;(Configuration.GetSection(\"OrderService\"));services.AddScoped&lt;IOrderService, OrderService&gt;(); 获取服务进行测试修改WeatherForecastController.Get方法，具体代码如下： 123456[HttpGet]public int Get([FromServices]IOrderService orderService)&#123; Console.WriteLine($\"orderService.ShowMaxOrderCount:&#123;orderService.ShowMaxOrderCount()&#125;\"); return 1;&#125; 运行项目，可以访问/WeatherForecast，可以看到控制台打印出以下信息： 1orderService.ShowMaxOrderCount:400 这里如果在项目运行时修改appsettings.json里配置项的值，重新访问/WeatherForecast地址，会发现控制台打印出来的值不会变，还依旧是400，这里就需要使用到下面的热更新。 选项框架热更新关键类型 单例服务(Singleton)使用IOptionsMonitor&lt;out TOptions&gt; 范围作用域类型(Scope)使用IOptionsSnapshot&lt;out TOptions&gt; 代码示例IOptionsSnapshot上个示例对OrderService注册的是Scope服务，所以这里先测试Scope对应的IOptionsSnapshot，将OrderService构造函数获取服务的类型修改为IOptionsSnapshot&lt;OrderServiceOptions&gt;，最终修改后OrderService类的代码如下： 123456789101112public class OrderService:IOrderService&#123; private readonly IOptionsSnapshot&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsSnapshot&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.Value.MaxOrderCount; &#125;&#125; 运行代码，访问/WeatherForecast，发现现在打印出来的是appsettings.json现有的值，对该配置项进行修改，保存之后重新访问/WeatherForecast，可以发现获取到的是新的值 IOptionsMonitor将OrderService构造函数获取服务的类型修改为IOptionsMonitor&lt;OrderServiceOptions&gt;，最终修改后OrderService类的代码如下： 123456789101112public class OrderService:IOrderService&#123; private readonly IOptionsMonitor&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsMonitor&lt;OrderServiceOptions&gt; options) &#123; _options = options; &#125; public int ShowMaxOrderCount() &#123; return _options.CurrentValue.MaxOrderCount; &#125;&#125; 在Startup.ConfigureServices方法中将OrderService注册为单例模式，代码如下： 1services.AddSingleton&lt;IOrderService, OrderService&gt;(); 运行代码，访问/WeatherForecast，发现现在打印出来的是appsettings.json现有的值，对该配置项进行修改，保存之后重新访问/WeatherForecast，可以发现获取到的是新的值 IOptionsMonitor监听配置变动通过IOptionsMonitor对象的OnChange方法来注册配置变动操作，只需要在获取对象后注册相应操作即可，具体代码如下： 12345678910111213141516public class OrderService:IOrderService&#123; private readonly IOptionsMonitor&lt;OrderServiceOptions&gt; _options; public OrderService(IOptionsMonitor&lt;OrderServiceOptions&gt; options) &#123; _options = options; this._options.OnChange(changedOptions =&gt; &#123; Console.WriteLine($\"配置发生了变化,新值为:&#123;changedOptions.MaxOrderCount&#125;\"); &#125;); &#125; public int ShowMaxOrderCount() &#123; return _options.CurrentValue.MaxOrderCount; &#125;&#125; 运行代码，修改appsettings.json的值，就可以看到控制台打印出类似以下信息： 1配置发生了变化,新值为:100 优化代码结构在开发中经常会出现服务与选项一起注册的情况，为了优化代码结构，一般会为统一将一个服务的注册放到IServiceCollection的扩展方法中去。创建OrderServiceExtensions.cs，具体代码如下： 123456789101112131415using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.Configure&lt;OrderServiceOptions&gt;(configuration.GetSection(\"OrderService\")); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 将Startup.ConfigureServices修改后代码如下： 12345public void ConfigureServices(IServiceCollection services)&#123; services.AddOrderService(Configuration); services.AddControllers();&#125; 运行之后可发现效果与上面一致 动态修改选项值在注入选项之后，可动态对选项的值进行操作，这里以为MaxOrderCount的值增加100为例，修改OrderServiceExtensions，代码如下： 12345678910111213141516171819using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;namespace OptionsDemo.Services&#123; public static class OrderServiceExtensions &#123; public static IServiceCollection AddOrderService(this IServiceCollection services, IConfiguration configuration) &#123; services.Configure&lt;OrderServiceOptions&gt;(configuration.GetSection(\"OrderService\")); services.PostConfigure&lt;OrderServiceOptions&gt;(options =&gt; &#123; options.MaxOrderCount += 100; &#125;); services.AddSingleton&lt;IOrderService, OrderService&gt;(); return services; &#125; &#125;&#125; 运行代码，可发现获得到的值比appsettings.json里的值增加100","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(9) -- 自定义配置数据源：低成本实现定制配置方案","slug":"9.ConfigurationCustom_document","date":"2020-04-01T04:12:12.000Z","updated":"2020-04-01T09:04:52.857Z","comments":true,"path":"2020/04/01/9.ConfigurationCustom_document/","link":"","permalink":"http://doc.dimsum.com/2020/04/01/9.ConfigurationCustom_document/","excerpt":"","text":"拓展步骤 代码实现 创建项目 创建自定义数据源Provider 创建自定义数据源Source 创建IConfigurationBuilder扩展方法 引用自定义配置源并监听配置源变化 拓展步骤 实现IConfigurationSource 实现IConfigurationProvider 实现AddXXX扩展方法 代码实现创建项目创建名字为ConfigurationCustomDemo的控制台应用，通过nuget引入以下两个包： 12Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.Abstractions 创建自定义数据源Provider创建MyConfigurationProvider，继承ConfigurationProvider这个抽象类，调用基类的OnReload方法能触发重新加载配置，这里因为要自动修改和触发配置，所以这个类里用了Timer对象来模拟配置变化的操作，具体代码如下： 123456789101112131415161718192021222324252627282930313233using System;using System.Timers;using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; internal class MyConfigurationProvider:ConfigurationProvider &#123; private Timer timer; public MyConfigurationProvider():base() &#123; timer = new Timer(); timer.Elapsed += Timer_Elapsed; timer.Interval = 3000; timer.Start(); &#125; private void Timer_Elapsed(object sender, ElapsedEventArgs e) &#123; Load(true); &#125; void Load(bool reload) &#123; this.Data[\"lastTime\"] = DateTime.Now.ToString(); if (reload) &#123; base.OnReload(); &#125; &#125; &#125;&#125; 创建自定义数据源Source创建MyConfigurationSource，实现IConfigurationSource接口，在Build方法直接返回上面创建的Provider，具体代码如下： 123456789101112using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; internal class MyConfigurationSource:IConfigurationSource &#123; public IConfigurationProvider Build(IConfigurationBuilder builder) &#123; return new MyConfigurationProvider(); &#125; &#125;&#125; 创建IConfigurationBuilder扩展方法可以看到上面两个类的都是用internal的访问修饰符，这是因为一般在Provider和Source都是通过拓展方法来调用，而不会将自己直接暴露被调用者，所以接下来要创建一个IConfigurationBuilder的扩展方法，代码如下： 12345678910111213using Microsoft.Extensions.Configuration;namespace ConfigurationCustomDemo&#123; public static class MyConfigurationBuilderExtension &#123; public static IConfigurationBuilder AddMyConfiguration(this IConfigurationBuilder builder) &#123; builder.Add(new MyConfigurationSource()); return builder; &#125; &#125;&#125; 引用自定义配置源并监听配置源变化Program.Main方法修改如下： 12345678910111213141516171819202122232425using System;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.Primitives;namespace ConfigurationCustomDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddMyConfiguration(); var configurationRoot = builder.Build(); ChangeToken.OnChange(() =&gt; configurationRoot.GetReloadToken(), () =&gt; &#123; var lastTime = configurationRoot[\"lastTime\"]; Console.WriteLine($\"lastTime=&#123;lastTime&#125;\"); Console.WriteLine(\"======\"); &#125;); Console.ReadKey(); &#125; &#125;&#125; 运行代码，可以看到控制台3秒钟打印一次当前时间的效果","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(8) -- 文件配置提供程序：自由选择配置的格式","slug":"8.ConfigurationFile_document","date":"2020-04-01T03:11:11.000Z","updated":"2020-04-01T09:04:48.264Z","comments":true,"path":"2020/04/01/8.ConfigurationFile_document/","link":"","permalink":"http://doc.dimsum.com/2020/04/01/8.ConfigurationFile_document/","excerpt":"","text":"文件配置提供程序 特性 代码示例 创建项目 创建测试配置项appSetting.json 获取appSetting.json里的配置 获取ini配置文件 文件配置提供程序读取不同文件格式或从不同位置读取配置 Microsoft.Extensions.Configuration.Ini Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.UserSecrets Microsoft.Extensions.Configuration.Xml 特性 指定文件可选、必选 指定是否监视文件的变更 代码示例创建项目创建名字为ConfigurationFileDemo的控制台应用，通过nuget引入以下四个包： 1234Microsoft.Extensions.Configuration.IniMicrosoft.Extensions.Configuration.JsonMicrosoft.Extensions.Configuration.UserSecretsMicrosoft.Extensions.Configuration.Xml 这里不用引用Microsoft.Extensions.Configuration和Microsoft.Extensions.Configuration.Abstractions两个基础包，是因为其他包已经包含了两个基础包 创建测试配置项appSetting.json在项目根目录创建appSetting.json文件，内容如下： 123456&#123; \"Key1\": \"value1\", \"Key2\": \"value2\", \"Key3\": false, \"Key4\": 10&#125; 在Visual Studio 2019中通过右键appSetting.json文件-&gt;属性-复制到输出目录选择如果较新则复制 在Visual Studio Code中通过修改ConfigurationFileDemo.csproj文件，新增文件输出到配置，具体代码如下：1234567891011121314151617&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;&lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;&lt;/PropertyGroup&gt;&lt;ItemGroup&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Ini\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Json\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.UserSecrets\" Version=\"3.1.3\" /&gt; &lt;PackageReference Include=\"Microsoft.Extensions.Configuration.Xml\" Version=\"3.1.3\" /&gt;&lt;/ItemGroup&gt;&lt;ItemGroup&gt; &lt;None Update=\"appSetting.json\"&gt; &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt; &lt;/None&gt;&lt;/ItemGroup&gt;&lt;/Project&gt; 获取appSetting.json里的配置修改Program.Main方法，内容如下：12345678910111213141516171819202122232425using System;using Microsoft.Extensions.Configuration;namespace ConfigurationFileDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddJsonFile(\"appSetting.json\",optional:false,reloadOnChange:true); var configurationRoot = builder.Build(); Console.WriteLine(\"开始了。。输入随意字符串返回配置项，直接回车推出\"); var isStop = Console.ReadLine(); while (!string.IsNullOrEmpty(isStop)) &#123; Console.WriteLine($\"Key1=&#123;configurationRoot[\"Key1\"]&#125;\"); Console.WriteLine($\"Key2=&#123;configurationRoot[\"Key2\"]&#125;\"); Console.WriteLine($\"Key3=&#123;configurationRoot[\"Key3\"]&#125;\"); Console.WriteLine($\"Key4=&#123;configurationRoot[\"Key4\"]&#125;\"); Console.WriteLine(\"=====分割线=====\"); isStop = Console.ReadLine(); &#125; &#125; &#125;&#125; optional：表示文件是否可选，false=没文件会报错，true=可以没有文件 reloadOnChange：表示监视配置文件的变动，配置文件变动会进行重新读取 运行代码，然后在控制台随意输入字符串回车，可以看到以下信息： 12345Key1&#x3D;value1Key2&#x3D;value2Key3&#x3D;FalseKey4&#x3D;10&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 进入项目根目录/bin/Debug/netcoreapp3.1里，找到appSetting.json文件，修改里面的配置值，再回到控制台输入随意字符串回车，可以看到打印出来的值已经有所变化 获取ini配置文件在项目根目录创建appSetting.ini文件，内容如下： 12Key4=Hello worldKey5=value5 类似appSetting.json那样配置拷贝到输出目录，修改Program.Main方法，在AddJsonFile方法下面新增添加ini配置源的调用，代码如下： 1builder.AddIniFile(\"appSetting.ini\", optional: false, reloadOnChange: true); 运行代码，然后在控制台输入随意字符串回车，可以看到以下信息： 123456Key1&#x3D;value1Key2&#x3D;value2Key3&#x3D;FalseKey4&#x3D;Hello worldKey5&#x3D;value5&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 可以看到ini文件里的配置已经加载进去了，同时后面加载的配置项如果与前面已经加载的配置项名称一致，会覆盖掉前面加载的配置项","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(7) -- 环境变量配置提供程序：容器环境下配置注入的最佳途径","slug":"7.ConfigurationEnvironmentVariables_Document","date":"2020-04-01T02:10:10.000Z","updated":"2020-04-01T09:04:43.281Z","comments":true,"path":"2020/04/01/7.ConfigurationEnvironmentVariables_Document/","link":"","permalink":"http://doc.dimsum.com/2020/04/01/7.ConfigurationEnvironmentVariables_Document/","excerpt":"","text":"使用场景 在Docker中运行 在Kubernetes中运行 需要设置ASP.NET Core的一些内置特殊配置时 特性 对应配置的分层键，支持用双下划线”--“代替”:“ 支持根据前缀加载 代码示例创建项目创建名字为ConfigurationEnvironmentVariablesDemo的控制台应用，通过nuget引入以下三个包： 123Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.AbstractionsMicrosoft.Extensions.Configuration.EnvironmentVariables 获取环境变量配置修改Program.Main方法，代码如下： 123456789101112131415161718using System;using Microsoft.Extensions.Configuration;namespace ConfigurationEnvironmentVariablesDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddEnvironmentVariables(); var configurationRoot = builder.Build(); Console.WriteLine($\"KEY3=&#123;configurationRoot[\"KEY3\"]&#125;\"); var section = configurationRoot.GetSection(\"SECTIONA\"); Console.WriteLine($\"SECTIONA:KEY2=&#123;section[\"KEY2\"]&#125;\"); &#125; &#125;&#125; 配置测试参数： 在Visual Studio 2019中，可以右键项目名称-&gt;属性-&gt;调试-&gt;环境变量中添加以下内容：12345&quot;DIMSUM_KEY1&quot;: &quot;dimsum_value1&quot;,&quot;KEY3&quot;: &quot;value3&quot;,&quot;KEY1&quot;: &quot;value1&quot;,&quot;SECTIONA__KEY2&quot;: &quot;value2&quot;,&quot;KEY4&quot;: &quot;value4&quot; 在Visual Studio Code中，可以编辑launchSettings.json文件，新增environmentVariables字段，具体代码如下:1234567891011121314&#123; \"profiles\": &#123; \"ConfigurationEnvironmentVariablesDemo\": &#123; \"commandName\": \"Project\", \"environmentVariables\": &#123; \"DIMSUM_KEY1\": \"dimsum_value1\", \"KEY3\": \"value3\", \"KEY1\": \"value1\", \"SECTIONA__KEY2\": \"value2\", \"KEY4\": \"value4\" &#125; &#125; &#125;&#125; 运行项目，会得到以下信息：12KEY3&#x3D;value3SECTIONA:KEY2&#x3D;value2 前缀过滤过滤指定前缀的环境变量，具体代码如下： 12345678910111213141516using System;using Microsoft.Extensions.Configuration;namespace ConfigurationEnvironmentVariablesDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddEnvironmentVariables(\"DIMSUM_\"); var configurationRoot = builder.Build(); Console.WriteLine($\"DIMSUM_KEY1=&#123;configurationRoot[\"KEY1\"]&#125;\"); &#125; &#125;&#125; 运行项目可以得到以下信息 1DIMSUM_KEY1&#x3D;dimsum_value1 说明这里获取到的是DIMSUM_KEY1这个配置，而非KEY这个配置","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(6) -- 命令行配置提供程序：最简单快捷的配置注入方法","slug":"6.ConfigurationCommandLine_document","date":"2020-03-31T07:15:15.000Z","updated":"2020-04-01T09:04:35.678Z","comments":true,"path":"2020/03/31/6.ConfigurationCommandLine_document/","link":"","permalink":"http://doc.dimsum.com/2020/03/31/6.ConfigurationCommandLine_document/","excerpt":"","text":"命令行参数支持的格式 命令替换模式 代码示例 创建项目 测试支持命令行参数的三种格式 测试命令替换 命令行参数支持的格式 无前缀的key=value模式 双中横线--key=value或--key value模式 正斜杠/key=value或/key value模式 备注：等号分隔符和空格分隔符不能混用* 命令替换模式 必须以单横线-或双横线--开头 映射字典不能包含重复key 主要作用是命令缩写的作用 代码示例创建项目创建名字为ConfigurationCommandLineDemo的控制台应用，通过nuget引入以下三个包： 123Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.AbstractionsMicrosoft.Extensions.Configuration.CommandLine 测试支持命令行参数的三种格式修改Program.Main方法，代码如下： 1234567891011121314151617181920using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationCommandLineDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddCommandLine(args); var configurationRoot = builder.Build(); Console.WriteLine($\"CommandLineKey1:&#123;configurationRoot[\"CommandLineKey1\"]&#125;\"); Console.WriteLine($\"CommandLineKey2:&#123;configurationRoot[\"CommandLineKey2\"]&#125;\"); Console.WriteLine($\"CommandLineKey3:&#123;configurationRoot[\"CommandLineKey3\"]&#125;\"); Console.ReadKey(); &#125; &#125;&#125; 配置测试参数： 在Visual Studio 2019中，可以右键项目名称-&gt;属性-&gt;调试-&gt;应用程序参数中输入以下内容：1CommandLineKey1&#x3D;value1 --CommandLineKey2&#x3D;value2 &#x2F;CommandLineKey3&#x3D;value3 在Visual Studio Code中，可以编辑launchSettings.json文件，新增commandLineArgs字段，具体代码如下:12345678&#123; \"profiles\": &#123; \"ConfigurationCommandLineDemo\": &#123; \"commandName\": \"Project\", \"commandLineArgs\": \"CommandLineKey1=value1 --CommandLineKey2=value2 /CommandLineKey3=value3\" &#125; &#125;&#125; 运行项目，可以看到控制台打印出对应的键值对，类似以下信息： 123CommandLineKey1:value1CommandLineKey2:value2CommandLineKey3:value3 测试命令替换为Program.Main方法添加命令替换映射，代码如下： 123456789101112131415161718192021using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationCommandLineDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); var mapper = new Dictionary&lt;string, string&gt;() &#123;&#123;\"-k1\", \"CommandLineKey1\"&#125;&#125;; builder.AddCommandLine(args, mapper); var configurationRoot = builder.Build(); Console.WriteLine($\"CommandLineKey1:&#123;configurationRoot[\"CommandLineKey1\"]&#125;\"); Console.WriteLine($\"CommandLineKey2:&#123;configurationRoot[\"CommandLineKey2\"]&#125;\"); Console.WriteLine($\"CommandLineKey3:&#123;configurationRoot[\"CommandLineKey3\"]&#125;\"); Console.ReadKey(); &#125; &#125;&#125; mapper表示用-k1这个命令可以代替CommandLineKey1将应用参数修改为： 1CommandLineKey1&#x3D;value1 --CommandLineKey2&#x3D;value2 &#x2F;CommandLineKey3&#x3D;value3 -k1&#x3D;value4 运行项目会在控制台打印出以下信息： 123CommandLineKey1:value4CommandLineKey2:value2CommandLineKey3:value3 可以发现CommandLineKey1原本的值value1被后面的-k1的值value4所替换了，说明了替换规则生效","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(5) -- 配置框架：让服务无缝适应各种环境","slug":"5.Configuration_document","date":"2020-03-31T06:14:14.000Z","updated":"2020-04-01T09:04:29.535Z","comments":true,"path":"2020/03/31/5.Configuration_document/","link":"","permalink":"http://doc.dimsum.com/2020/03/31/5.Configuration_document/","excerpt":"","text":"概念 配置框架的核心包 框架配置 配置框架核心类型 配置框架扩展点 代码实现 创建项目 完善代码 概念配置框架的核心包与依赖注入框架的核心包类似，使用的是接口实现分离的设计模式 12Microsoft.Extensions.Configuration &#x2F;&#x2F;实现包Microsoft.Extensions.Configuration.Abstractions &#x2F;&#x2F;抽象包 框架配置 以key-value字符串键值对的方式抽象了配置 支持从各种不同的数据源读取配置，比如从命令行读取、环境变量读取、从文件读取等 配置框架核心类型1234IConfigurationIConfigurationRootIConfigurationSectionIConfigurationBuilder 配置框架扩展点可以通过拓展点注入我们自己的配置源，也就是我们可以指定任意我们指定的配置源到我们的配置框架中去 12IConfigurationSourceIConfigurationProvider 代码实现创建项目创建名字为ConfigurationDemo的控制台应用，通过nuget引入以下两个包： 12Microsoft.Extensions.ConfigurationMicrosoft.Extensions.Configuration.Abstractions 完善代码在Program.cs的Main完善测试代码，具体代码如下： 123456789101112131415161718192021222324using System;using System.Collections.Generic;using Microsoft.Extensions.Configuration;namespace ConfigurationDemo&#123; class Program &#123; static void Main(string[] args) &#123; var builder = new ConfigurationBuilder(); builder.AddInMemoryCollection(new Dictionary&lt;string, string&gt;() &#123; &#123;\"key1\", \"value1\"&#125;, &#123;\"key2\", \"value2\"&#125;, &#123;\"sectionA:key4\", \"value4\"&#125; &#125;); var configurationRoot = builder.Build(); Console.WriteLine($\"key1=&#123;configurationRoot[\"key1\"]&#125;\"); Console.WriteLine($\"key2=&#123;configurationRoot[\"key2\"]&#125;\"); var sectionA = configurationRoot.GetSection(\"sectionA\"); Console.WriteLine($\"sectionA:key4=&#123;sectionA[\"key4\"]&#125;\"); &#125; &#125;&#125; 创建一个ConfigurationBuilder对象，添加内存配置源，然后调用Build方法来生成一个IConfigurationRoot对象，通过这个对象可以直接获取配置源的配置项，用:来区分多个层级，通过GetSetion可获取指定层级，可以依次推各个层级的键值对","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(4) -- 用Autofac增强容器能力","slug":"4.DependencyInjectionAutofac_document","date":"2020-03-31T05:13:13.000Z","updated":"2020-04-01T09:04:21.075Z","comments":true,"path":"2020/03/31/4.DependencyInjectionAutofac_document/","link":"","permalink":"http://doc.dimsum.com/2020/03/31/4.DependencyInjectionAutofac_document/","excerpt":"","text":"引入Autofac增强什么能力 核心扩展点 集成Autofac 代码验证 项目与依赖 在代码中引入Autofac 创建测试服务 获取Autofac根容器 一般注册服务 基于名字注册服务 属性注入 AOP切面拦截器 创建子容器 引入Autofac增强什么能力 基于名称的注入：需要把一个服务按照名称来区分它的不同实现 属性注入：直接把服务注册到某个类的属性里面去，而不需要定义构造函数 子容器：类似原生的scope，但是功能更加丰富 基于动态代理的AOP：当我们需要在服务中注入我们额外的行为的时候 核心扩展点IServiceProviderFactory&lt;TContainerBuilder&gt;：第三方的依赖注入容器都是使用这个类来作为拓展点，把自己注入到整个框架里面来，也就是我们在使用依赖注入框架的时候，不需要关注谁家的特性谁家接口时怎么样的，我们直接使用官方核心的定义即可，不需要直接依赖这些框架 集成Autofac Autofac.Extensions.DependencyInjection Autofac.Extras.DynamicProxy 代码验证项目与依赖创建名字为DependencyInjectionAutofacDemo的ASP.NET Core项目，类型为API 通过nuget引入以下两个包 12Autofac.Extensions.DependencyInjectionAutofac.Extras.DynamicProxy 在代码中引入Autofac在Program.cs的CreateDefaultBuilder后面添加以下代码 1.UseServiceProviderFactory(new AutofacServiceProviderFactory()) UseServiceProviderFactory用来注册第三方容器的入口 在Startup中新增ConfigureContainer方法，代码如下： 123public void ConfigureContainer(ContainerBuilder builder)&#123;&#125; 至此Autofac框架引入完毕，下面要创建测试服务类 创建测试服务创建测试服务MyService.cs类，具体代码如下： 1234567891011121314151617181920212223242526using System;namespace DependencyInjectionAutofacDemo.Services&#123; public interface IMyService &#123; void ShowCode(); &#125; public class MyService : IMyService &#123; public void ShowCode() &#123; Console.WriteLine($\"MyService.ShowCode:&#123;GetHashCode()&#125;\"); &#125; &#125; public class MyServiceV2 : IMyService &#123; public MyNameService MyNameService &#123; get; set; &#125; public void ShowCode() &#123; Console.WriteLine($\"MyServiceV2.ShowCode:&#123;GetHashCode()&#125;,MyNameService是否为空:&#123;MyNameService==null&#125;\"); &#125; &#125; public class MyNameService &#123; &#125;&#125; 创建测试拦截器MyInterceptor.cs，代码如下： 123456789101112131415using System;using Castle.DynamicProxy;namespace DependencyInjectionAutofacDemo.Services&#123; public class MyInterceptor:IInterceptor &#123; public void Intercept(IInvocation invocation) &#123; Console.WriteLine($\"Intercept before,Method:&#123;invocation.Method.Name&#125;\"); invocation.Proceed(); Console.WriteLine($\"Intercept after,Method:&#123;invocation.Method.Name&#125;\"); &#125; &#125;&#125; IInterceptor 是Autofac面向切面最重要的一个接口，他可以把我们的逻辑注入到方法的切面里面去 invocation.Proceed()是指具体方法的执行，如果这句不执行，就相当于把切面方法拦截了，让具体类的方法不执行 获取Autofac根容器在Startup里新增类型为ILifetimeScope的AutofacContainer属性，然后在Configure方法中为这个属性复制为Autofac的根容器，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using Autofac;using Autofac.Extensions.DependencyInjection;using Autofac.Extras.DynamicProxy;using DependencyInjectionAutofacDemo.Services;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace DependencyInjectionAutofacDemo&#123; public class Startup &#123; public Startup(IConfiguration configuration) &#123; Configuration = configuration; &#125; public IConfiguration Configuration &#123; get; &#125; public void ConfigureServices(IServiceCollection services) &#123; services.AddControllers(); &#125; public void ConfigureContainer(ContainerBuilder builder) &#123; &#125; public ILifetimeScope AutofacContainer &#123; get; private set; &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; this.AutofacContainer = app.ApplicationServices.GetAutofacRoot(); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125; &#125;&#125; 一般注册服务在ConfigureContainer方法中进行服务注册，然后在Configure方法中获取服务实现对象，调用服务的ShowCode方法，具体代码如下: 123456789public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyService&gt;().As&lt;IMyService&gt;();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var serviceNoName = this.AutofacContainer.Resolve&lt;IMyService&gt;(); serviceNoName.ShowCode();&#125; Autofac注册服务与ASP.NET Core写法相反，先注册实现类，然后再标记这个实现类为哪种类型 运行项目会看到控制台打印了MyService对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyService.ShowCode:16336406 基于名字注册服务注释掉上一步的测试代码，一样是在ConfigureContainer方法中进行服务注册，然后在Configure方法中获取服务实现对象，调用服务的ShowCode方法，具体代码如下: 123456789public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyServiceV2&gt;().Named&lt;IMyService&gt;(\"service2\");&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.ResolveNamed&lt;IMyService&gt;(\"service2\"); service.ShowCode();&#125; 运行项目会看到控制台打印了MyServiceV2对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyServiceV2.ShowCode:16336406,MyNameService是否为空:True 属性注入注释掉上一步的测试代码，在ConfigureContainer方法中进行服务注册，注意需要先将属性的服务先进行注册，再进行调用方的服务注册，然后一样再Configure中获取对象，调用ShowCode方法 12345678910public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyNameService&gt;(); builder.RegisterType&lt;MyServiceV2&gt;().As&lt;IMyService&gt;().PropertiesAutowired();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.Resolve&lt;IMyService&gt;(); service.ShowCode();&#125; 运行项目会看到控制台打印了MyServiceV2对象调用ShowCode方法时候打印的信息，类似信息如下： 1MyServiceV2.ShowCode:10309404,MyNameService是否为空:False 可以发现MyNameService属性已经不为空了，通过属性注入的操作注入到了服务对象中去，打断点进行调试，可以看出MyNameService类型就是上面注册的类型 AOP切面拦截器注释掉上一步的测试代码，先在ConfigureContainer方法中注册拦截器，然后在服务，并指定拦截器为刚刚所注册的拦截器，并且允许接口拦截器生效，获取服务与上一步操作一致 12345678910public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyInterceptor&gt;(); builder.RegisterType&lt;MyServiceV2&gt;().As&lt;IMyService&gt;().PropertiesAutowired().InterceptedBy(typeof(MyInterceptor)).EnableInterfaceInterceptors();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var service = this.AutofacContainer.Resolve&lt;IMyService&gt;(); service.ShowCode();&#125; 运行项目，可以看到控制台在打印出MyServiceV2的ShowCode方法所打印的信息前后，有拦截器打印出来的信息，类似信息如下： 123Intercept before,Method:ShowCodeMyServiceV2.ShowCode:25116876,MyNameService是否为空:TrueIntercept after,Method:ShowCode 创建子容器子容器主要适用于将服务注册进指定名字的容器里，这样只有在创建出指定名字的容器才可获取到服务对象，其他容器无法获得该服务对象，具体代码如下： 12345678910111213141516171819public void ConfigureContainer(ContainerBuilder builder)&#123; builder.RegisterType&lt;MyNameService&gt;().InstancePerMatchingLifetimeScope(\"myScope\");&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; using (var myScope = this.AutofacContainer.BeginLifetimeScope(\"myScope\")) &#123; var service0 = myScope.Resolve&lt;MyNameService&gt;(); using (var scope = myScope.BeginLifetimeScope()) &#123; var service1 = scope.Resolve&lt;MyNameService&gt;(); var service2 = scope.Resolve&lt;MyNameService&gt;(); Console.WriteLine($\"service0=service1:&#123;service0==service1&#125;\"); Console.WriteLine($\"service1=service2:&#123;service1==service2&#125;\"); &#125; &#125;&#125; 运行代码可看到对象获取成功，并且获取到的对象在作用域内为同一个对象，类似信息如下： 12service0&#x3D;service1:Trueservice1&#x3D;service2:True 如果这时候不通过创建指定名字的容器来获得服务对象，会发现代码运行直接报错","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(3) -- 作用域与对象释放行为","slug":"3.DependencyInjectionScopeAndDisposable_document","date":"2020-03-31T04:12:12.000Z","updated":"2020-04-01T09:04:14.822Z","comments":true,"path":"2020/03/31/3.DependencyInjectionScopeAndDisposable_document/","link":"","permalink":"http://doc.dimsum.com/2020/03/31/3.DependencyInjectionScopeAndDisposable_document/","excerpt":"","text":"实现IDisposable接口类型的释放 建议 代码验证 项目 创建测试服务 测试Transient服务的释放时机 测试Scope服务的释放时机 测试Singleton服务的释放时机 避坑 自己new服务 在跟容器获取Transient服务 实现IDisposable接口类型的释放 DI只负责释放其创建的对象实例 DI在容器或子容器释放时，释放尤其创建的对象实例 建议 避免在根容器获取实现了IDisposable接口的瞬时服务 避免手动创建实现了IDisposable对象，应该使用容器来管理其生命周期 代码验证项目创建名为DependencyInjectionScopeAndDisposableDemo的ASP.NET Core项目，类型为API 创建测试服务创建测试服务类OrderService.cs，代码如下： 123456789101112using System;namespace DependencyInjectionScopeAndDisposableDemo.Services&#123; public interface IOrderService &#123; &#125; public class DisposableOrderService : IOrderService, IDisposable &#123; public void Dispose() &#123; Console.WriteLine($\"DisposableOrderService Disposed:&#123;this.GetHashCode()&#125;\"); &#125; &#125;&#125; 测试Transient服务的释放时机在Startup.ConfigureServices里注册一个瞬时服务 1services.AddTransient&lt;IOrderService, DisposableOrderService&gt;(); 在WeatherForecastController里的Get方法通过方法参数的形式获取两个IOrderService接口对象，代码如下： 123456[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2)&#123; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 保存之后运行项目，可以看到在打印接口请求处理结束之后两个对象都被释放掉，类似以下信息 123&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:64923656DisposableOrderService Disposed:11404313 得出的结论是：transient对象会在使用后被释放 测试Scope服务的释放时机注释掉上一步注册瞬时服务的代码，重新注册一个scope服务，这里使用工厂模式，只是熟悉以下工厂模式的写法，没特殊意义 1services.AddScoped&lt;IOrderService&gt;(serviceProvider =&gt; new DisposableOrderService()); 这时运行项目，控制台会打印出一个对象被释放，因为scope服务在当前容器内为单例，下面就这个结论再次测试以下，用using创建一个服务容器出来，看是否能创建出新的服务对象，并且代码运行超过using范围，服务对象是否会被释放。在WeatherForecastController的Get方法新增创建容器和获取服务操作，代码如下： 12345678910111213[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2)&#123; Console.WriteLine(\"========1==========\"); using (var scope = HttpContext.RequestServices.CreateScope()) &#123; var service = scope.ServiceProvider.GetService&lt;IOrderService&gt;(); &#125; Console.WriteLine(\"========2==========\"); Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; HttpContext.RequestServices.CreateScope()表示从根容器中创建一个子容器出来，scope.ServiceProvider.GetService&lt;IOrderService&gt;()表示从创建出来的子容器获取IOrderService的服务实现对象，运行项目可以得到两个对象被释放的信息，类似以下信息： 12345&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:5568949&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;DisposableOrderService Disposed:31307802 得出结论是：scope对象会在对象产生的容器被释放的时候同时一起释放 测试Singleton服务的释放时机注释掉上一步注册scope服务的代码，重新注册一个singleton服务，这里一样使用工厂模式 1services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt; new DisposableOrderService()); 将WeatherForecastController的Get方法修改为以下代码： 1234567891011[HttpGet]public int Get([FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2,[FromServices] IHostApplicationLifetime hostApplicationLifetime,[FromQuery]bool isStop=false)&#123; if (isStop) &#123; hostApplicationLifetime.StopApplication(); &#125; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 这里有获取了另一个服务IHostApplicationLifetime，这个服务对象控制了整个应用程序的生命周期，可以调用这个服务对象的StopApplication方法来停止应用程序，即停止整个站点，为了方便测试这里用了isStop这个参数来控制是否停止应用程序 运行项目，不管怎么刷新/WeatherForecast链接，都不会有对象被释放的信息打印出来，访问/WeatherForecast?isStop=true的时候，会看到应用程序被停止，同时打印出对象被释放的信息，类似以下信息： 12Application is shutting down...DisposableOrderService Disposed:3165221 得出结论是：scope对象只会在根容器释放的时候才会被释放，即所有单例模式的对象都会被注册在根容器上面 避坑自己new服务开始有个结论：DI只负责释放其创建的对象实例，这里进行验证以下自己new一个对象然后注入到容器中，看看是否能释放。这里注入了一个singleton对象，需注释掉上面做测试的代码，代码如下 12var myOrderService &#x3D; new DisposableOrderService();services.AddSingleton&lt;IOrderService&gt;(myOrderService); 控制器代码不用改，运行项目，访问/WeatherForecast发现不会有对象被释放，访问/WeatherForecast?isStop=true时，应用程序被停止，但是也一样没有对象被释放的信息，所以这个对象最终还是没被释放 在跟容器获取Transient服务注释掉上面的测试代码，在Startup.ConfigureServices中注册一个瞬时服务，代码如下： 1services.AddTransient&lt;IOrderService, DisposableOrderService&gt;(); 在Startup.Configure中从根容器获取瞬时服务对象，代码如下： 123456789101112131415public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; var s = app.ApplicationServices.GetService&lt;IOrderService&gt;(); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;);&#125; 将WeatherForecastController的Get方法修改为以下代码： 1234567891011[HttpGet]public int Get([FromServices] IHostApplicationLifetime hostApplicationLifetime, [FromQuery]bool isStop = false)&#123; if (isStop) &#123; hostApplicationLifetime.StopApplication(); &#125; Console.WriteLine(\"=====接口请求处理结束====\"); return 1;&#125; 运行项目，访问/WeatherForecast接口，发现并不会有对象被释放的信息，在带上isStop=true的参数的时候，应用程序被停止，这时才有对象被释放的信息，类似信息如下： 12Application is shutting down...DisposableOrderService Disposed:41149443 得出结论：由于根容器只会在应用程序整个退出时回收，这就意味着即使这是个瞬时服务，但是应用程序不退出，这些对象会一直积累在应用程序内不得释放","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(2) -- 依赖注入：良好架构的起点","slug":"2.DependencyInjection_document","date":"2020-03-30T02:12:12.000Z","updated":"2020-04-01T09:04:05.594Z","comments":true,"path":"2020/03/30/2.DependencyInjection_document/","link":"","permalink":"http://doc.dimsum.com/2020/03/30/2.DependencyInjection_document/","excerpt":"","text":"为什么要使用依赖注入框架(IoC框架) 依赖注入框架组件包 依赖注入框架核心类型 生命周期 代码演示 项目 示例服务类 验证不同生命周期的实现 注册不同生命周期的服务 在方法参数中获得服务进行验证 其他方式注册服务(以单例模式为例) 直接new对象 通过工厂模式注册对象 尝试注册服务 移除和替换服务 移除服务 替换服务 泛型服务注册 服务对象的获取 为什么要使用依赖注入框架(IoC框架) 借助依赖注入框架，我们可以轻松管理类之间的依赖，帮助我们在构建应用是遵循设计规则，确保代码的可维护性和可拓展性 ASP.NET Core的整个架构中，依赖注入框架提供了对象创建和生命周期管理的核心能力，各个组件相互写作，也是由依赖注入框架的能力来实现的 依赖注入框架组件包12Microsoft.Extensions.DependencyInjection.Abstractions &#x2F;&#x2F;抽象包Microsoft.Extensions.DependencyInjection &#x2F;&#x2F;具体实现 依赖注入框架核心类型1234IServiceCollection &#x2F;&#x2F;负责服务的注册ServiceDescriptor &#x2F;&#x2F;每个服务注册时的信息IServiceProvider &#x2F;&#x2F;具体的容器，也是由ServiceCollection Build出来IServiceScope &#x2F;&#x2F;表示一个容器的子容器的生命周期 生命周期123Singleton &#x2F;&#x2F;单例：在整个根容器的生命周期内获得的都是同一个单例对象Scoped &#x2F;&#x2F;作用域：在我的Scope的生命周期内，如果我的容器释放掉，则意味着我的对象释放掉，在这个生命周期范围内获得到的是一个单例对象Transient &#x2F;&#x2F;瞬时：每一次从容器里获取对象时都产生一个新的对象 代码演示项目创建名为DependencyInjectionDemo的ASP.NET Core项目，类型为API 示例服务类一共有5个示例服务类接口，分别为 1234567891011IGenericService&lt;T&gt; |-- GenericService&lt;T&gt; &#x2F;&#x2F;对应实现类IMyScopeService |-- MyScopeService &#x2F;&#x2F;对应实现类IMySingletonService |-- MySingletonService &#x2F;&#x2F;对应实现类IMyTransientService |-- MyTransientService &#x2F;&#x2F;对应实现类IOrderService |-- OrderService &#x2F;&#x2F;对应实现类 |-- OrderServiceEX &#x2F;&#x2F;对应实现类 因为是示例服务类，所以所有类和服务均没有属性和方法，纯粹为了验证服务注册和服务对象 验证不同生命周期的实现注册不同生命周期的服务在Startup.ConfigureServices方法中新增以下代码 123456// 注册Singleton服务services.AddSingleton&lt;IMySingletonService, MySingletonService&gt;();// 注册Scope服务services.AddScoped&lt;IMyScopeService, MyScopeService&gt;();// 注册Transient服务services.AddTransient&lt;IMyTransientService, MyTransientService&gt;(); 在方法参数中获得服务进行验证 修改WeatherForecastController类的Route标识为[Route(&quot;[controller]/[action]&quot;)]，方便进行测试 在WeatherForecastController新增GetService方法，代码如下：1234567891011121314151617[HttpGet]public int GetService([FromServices] IMySingletonService singletonService1, [FromServices] IMySingletonService singletonService2, [FromServices] IMyScopeService scopeService1, [FromServices] IMyScopeService scopeService2, [FromServices] IMyTransientService transientService1, [FromServices] IMyTransientService transientService2)&#123; Console.WriteLine($\"&#123;nameof(singletonService1)&#125;:&#123;singletonService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(singletonService2)&#125;:&#123;singletonService2.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(scopeService1)&#125;:&#123;scopeService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(scopeService2)&#125;:&#123;scopeService2.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(transientService1)&#125;:&#123;transientService1.GetHashCode()&#125;\"); Console.WriteLine($\"&#123;nameof(transientService2)&#125;:&#123;transientService2.GetHashCode()&#125;\"); Console.WriteLine(\"=========请求结束========\"); return 1;&#125; 运行项目，访问/WeatherForecast/GetService，控制台会打印出类似以下信息1234567singletonService1:23488915singletonService2:23488915scopeService1:24854661scopeService2:24854661transientService1:38972574transientService2:14645893&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 可以看出IMySingletonService的实现对象属于同一个对象，IMyTransientService的实现对象有多个，目前看IMyScopeService的实现对象为同一个，但是再次访问/WeatherForecast/GetService接口，就可以发现IMyScopeService的实现对象为新的对象，而IMySingletonService的实现对象还是上次访问的那个，打印信息如下1234567singletonService1:23488915singletonService2:23488915scopeService1:6630602scopeService2:6630602transientService1:5024928transientService2:38414640&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 其他方式注册服务(以单例模式为例)直接new对象在Startup.ConfigureServices方法中新增以下代码 1services.AddSingleton&lt;IOrderService&gt;(new OrderService()); 通过工厂模式注册对象使用工厂模式注册对象，可以在委托中使用IServiceProvider参数，这也就意味着可以从容器里获取多个对象，然后进行组装，得到我们最终需要的实现实例，可以把工厂类设计的比较复杂，比如说我们的实现类依赖了容器里面的另外一个类的情况，或者我们期望用另外一个类来包装我们原有的实现的时候在Startup.ConfigureServices方法中新增以下代码 1234services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt;&#123; return new OrderServiceEx();&#125;); 尝试注册服务尝试注册服务有两种情况 当指定接口已有实现类，则不再注册服务，代码如下：1services.TryAddSingleton&lt;IOrderService, OrderServiceEx&gt;(); 当指定接口已有实现类，但是已注册的实现类不包含当前指定的实现类，则注册进去，如果已经包含当前的实现类，则不再注册服务，代码如下：1services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IOrderService,OrderService&gt;()); 在控制器里验证是否有多个实现类注册，可通过下面的方法验证(需要自行注释或修改Startup里面的服务注册情况)123456789[HttpGet]public int GetServiceList([FromServices] IEnumerable&lt;IOrderService&gt; orderServices)&#123; foreach (var item in orderServices) &#123; Console.WriteLine($\"获取到服务实例：&#123;item.ToString()&#125;:&#123;item.GetHashCode()&#125;\"); &#125; return 1;&#125; 移除和替换服务移除服务指的是直接从容器中移除指定接口的所有实现类，代码如下：1services.RemoveAll&lt;IOrderService&gt;(); 替换服务指的是替换指定接口的实现类，同时也会替换该服务的生命周期，代码如下：1services.Replace(ServiceDescriptor.Singleton&lt;IOrderService, OrderServiceEx&gt;()); 泛型服务注册即对泛型服务注册，代码如下： 1services.AddSingleton(typeof(IGenericService&lt;&gt;), typeof(GenericService&lt;&gt;)); 可以通过在控制器的构造函数中获取到服务对象，代码如下： 1234public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,IOrderService orderService,IGenericService&lt;IOrderService&gt; genericService)&#123; _logger = logger;&#125; 可以通过断点查看最终IGenericService的IOrderService为哪个实现类 服务对象的获取通过上面可以看出，服务对象有两种获取方式，一种是通过构造函数直接注入，一种是通过函数参数，使用[FromServices]标签来注入 一般按照使用情况来确定用哪种方式，如果整个类使用地方比较多，则使用构造函数注入，如果只有某一个方法使用，则一般使用函数参数来注入","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core开发实战课程备忘(1) -- ASP.NET Core的启动流程","slug":"1.StartupDemo_document","date":"2020-03-29T02:11:21.000Z","updated":"2020-04-01T09:03:58.277Z","comments":true,"path":"2020/03/29/1.StartupDemo_document/","link":"","permalink":"http://doc.dimsum.com/2020/03/29/1.StartupDemo_document/","excerpt":"","text":"课程目标 创建项目 添加日志代码 运行结果 结论 另外 课程目标主要是掌握ASP.NET Core应用程序启动的流程，同时了解启动过程中哪些方法做了哪些操作 创建项目创建ASP.NET Core Web项目，项目类型选择API，直接创建即可 添加日志代码本实例不涉及任何业务代码，纯粹只是添加日志查看各个方法的调用流程 修改Program.cs，以下直接放修改后的代码 12345678910111213141516171819202122232425262728293031323334using System;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateHostBuilder(args).Build().Run(); &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; Console.WriteLine(\"ConfigureWebHostDefaults\"); webBuilder.UseStartup&lt;Startup&gt;(); &#125;) .ConfigureServices(service =&gt; &#123; Console.WriteLine(\"ConfigureServices\"); &#125;) .ConfigureAppConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureAppConfiguration\"); &#125;) .ConfigureHostConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureHostConfiguration\"); &#125;); &#125;&#125; 修改Startup.cs，以下直接放修改后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Startup &#123; public Startup(IConfiguration configuration) &#123; Console.WriteLine(\"Startup.Ctor\"); Configuration = configuration; &#125; public IConfiguration Configuration &#123; get; &#125; public void ConfigureServices(IServiceCollection services) &#123; Console.WriteLine(\"Startup.ConfigureServices\"); services.AddControllers(); &#125; public void Configure(IApplicationBuilder app, IWebHostEnvironment env) &#123; Console.WriteLine(\"Startup.Configure\"); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseStaticFiles(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125; &#125;&#125; 运行结果参照上面将代码修改完，直接运行代码，控制台将打印出以下信息 1234567ConfigureWebHostDefaultsConfigureHostConfigurationConfigureAppConfigurationStartup.CtorStartup.ConfigureServicesConfigureServicesStartup.Configure 结论以下为ASP.NET Core启动运行流程 ConfigureWebHostDefaults：注册了应用程序必要的几个组件，比如说配置的组件、容器的组件等 ConfigureHostConfiguration：配置程序启动时必要的配置，比如说程序启动时所需要监听的端口、需要监听的URL地址等，在这个过程可以嵌入我们自己的配置内容注入到配置的框架中去 ConfigureAppConfiguration：嵌入我们自己的配置文件，供应用程序来读取，这些配置将来会在后续的应用程序执行过程中每个组件读取 ConfigureServices/ConfigureLogging/Startup/Startup.ConfigureServices：这些都是往容器里面来注入我们的应用的组件 Startup.Configure：注入中间件，处理HttpContext整个的请求过程 另外从代码运行来看，Startup.cs这个类可以被整合到Program.cs里的ConfigureWebHostDefaults方法中，可以直接ConfigureWebHostDefaults方法中直接使用webBuilder调用ConfigureServices和Configure两个方法具体可以参考以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace StartupDemo&#123; public class Program &#123; public static void Main(string[] args) &#123; CreateHostBuilder(args).Build().Run(); &#125; public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; Console.WriteLine(\"ConfigureWebHostDefaults\"); webBuilder.ConfigureServices(services =&gt; &#123; Console.WriteLine(\"Program.ConfigureServices\"); services.AddControllers(); &#125;); webBuilder.Configure(app =&gt; &#123; Console.WriteLine(\"Program.Configure\"); app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseStaticFiles(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); &#125;); &#125;) .ConfigureServices(service =&gt; &#123; Console.WriteLine(\"ConfigureServices\"); &#125;) .ConfigureAppConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureAppConfiguration\"); &#125;) .ConfigureHostConfiguration(builder =&gt; &#123; Console.WriteLine(\"ConfigureHostConfiguration\"); &#125;); &#125;&#125; 但是为了代码结构更加合理，还是需要用Startup这个类来分离变动比较大的代码 通常是在Startup.ConfigureServices的方法里做服务注册，一般是Addxxx 在Startup.Configure决定注册那些中间件到处理过程中去","categories":[{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"}]},{"title":".NET Core使用Cap","slug":"dotnet-core-cap","date":"2020-03-27T05:13:13.000Z","updated":"2020-04-01T09:05:51.498Z","comments":true,"path":"2020/03/27/dotnet-core-cap/","link":"","permalink":"http://doc.dimsum.com/2020/03/27/dotnet-core-cap/","excerpt":"","text":"准备工作 项目设定 创建ServiceA 创建ServiceB 准备工作CAP需要依赖消息队列和数据存储，支持情况如下：消息队列 123KafkaRabbitMQAzureServiceBus 数据存储 1234SqlServerMySqlPostgreSqlMongoDB 两者自行搭配选择即可，其中SqlServer和RabbitMQ在docker中的安装可参照我另一篇备忘开发常用的docker镜像 项目设定 两个服务，分别为ServiceA,ServiceB SqlServer使用CapDemo数据库，默认sa账号，密码为Today_is_20200328，端口为默认的1433端口 RabbitMQ安装地址为本机，默认端口，账号密码为admin/admin 创建ServiceA 在Visual Studio 2019中创建空白解决方案，取名为Jiamiao.x.CapDemo 在解决方案中新建Asp.net core项目，名字为Jiamiao.x.CapDemo.ServiceA，.net core版本为3.1 nuget安装以下4个包 1234DotNetCore.CAPDotNetCore.CAP.DashboardDotNetCore.CAP.RabbitMQDotNetCore.CAP.SqlServer 在Startup.cs的ConfigureServices方法中加入以下代码 1234567891011services.AddCap(options =&gt;&#123; options.UseSqlServer(\"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1\"); options.UseRabbitMQ(r =&gt; &#123; r.HostName = \"127.0.0.1\"; r.UserName = \"admin\"; r.Password = \"admin\"; &#125;); options.UseDashboard();&#125;); 此时直接运行项目，如果数据库与消息队列均能正常连接，则会在数据库中生成以下两张表 12cap.Publishedcap.Received 在Controllers/WeatherForecastController.cs中编写消息发布代码 6.1 通过构造函数依赖注入ICapPublisher对象 6.2 发布消息只需要调用ICapPublisher对象的PublishAsync或Publish方法，传入参数为队列名和消息值，全部代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Logging;namespace Jiamiao.x.CapDemo.ServiceA.Controllers&#123; [ApiController] [Route(\"[controller]\")] public class WeatherForecastController : ControllerBase &#123; private static readonly string[] Summaries = new[] &#123; \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\" &#125;; private readonly ILogger&lt;WeatherForecastController&gt; _logger; private readonly ICapPublisher _capPublisher; public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,ICapPublisher capPublisher) &#123; _logger = logger; _capPublisher = capPublisher; &#125; [HttpGet] public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; Get() &#123; await _capPublisher.PublishAsync(\"jiamiao.x.cap.demo.show.time\", DateTime.Now); var rng = new Random(); return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast &#123; Date = DateTime.Now.AddDays(index), TemperatureC = rng.Next(-20, 55), Summary = Summaries[rng.Next(Summaries.Length)] &#125;) .ToArray(); &#125; &#125;&#125; 编写接收消息代码，接收消息有两种方式，一种在控制器中，即代码写在***Controller.cs中，另一种是在非控制器中，一般为***Service.cs中，以下分两步执行，因为CAP在默认情况下一个服务多个地方进行订阅，只会进行一次接收，除非进行分组(后面介绍)，所以8/9两个步骤在测试时需要注释其中一个，只保留另一个 编写在控制器中接收消息的代码，直接在控制器中写对应方法，方法参数为发送消息时传入的消息值类型，方法无返回值，再加上方法标签CapSubscribe即可，具体代码如下: 123456789101112131415161718using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;using Microsoft.AspNetCore.Mvc;namespace Jiamiao.x.CapDemo.ServiceA.Controllers&#123; public class SubController : Controller &#123; [CapSubscribe(\"jiamiao.x.cap.demo.show.time\")] public void ShowTime(DateTime value) &#123; Console.WriteLine($\"接受方：SubController.ShowTime 接收到值：&#123;value&#125;\"); &#125; &#125;&#125; 做到这步可以进行一次测试，就可以发现访问/WeatherForecast这个接口，会发送一条当前时间的消息出去，同时接收方也会在控制台打印出接收到的消息 编写服务中接收消息的代码，需要注意接收消息的类需要继承ICapSubscribe接口，同时这里为了方便进行依赖注入，这里我们也自己定义了一个ISubscriberService接口，同时服务需要在Startup.cs的ConfigureServices方法中进行注册 9.1 ISubscriberService.cs代码如下 123456789101112using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;namespace Jiamiao.x.CapDemo.ServiceA.Services&#123; public interface ISubscriberService &#123; void ReceivedShowTimeMessage(DateTime value); &#125;&#125; 9.2 SubscriberService.cs代码如下 1234567891011121314151617using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using DotNetCore.CAP;namespace Jiamiao.x.CapDemo.ServiceA.Services&#123; public class SubscriberService: ISubscriberService, ICapSubscribe &#123; [CapSubscribe(\"jiamiao.x.cap.demo.show.time\")] public void ReceivedShowTimeMessage(DateTime value) &#123; Console.WriteLine($\"接受方：SubscriberService.ReceivedShowTimeMessage 接收到值：&#123;value&#125;\"); &#125; &#125;&#125; 9.3 服务注册代码如下 1services.AddScoped&lt;ISubscriberService, SubscriberService&gt;(); 注意：这行服务注册代码需要在services.AddCap这个方法之前注册，否则CAP在进行接口扫描的时候找不到对应已经实现了ICapSubscribe接口的实现类，则无法进行订阅者注册 注释掉第8步，进行第9步的测试，效果应该与第8步一致 有时候一个消息需要多个消费者同时消费，则可以使用Group概念，消息发送代码不变，在标记CapSubscribe的时候，使用Group参数，多个Group订阅同个消息Id，消息则会对应分发到多个Group中，同个Group只能消费一次，即一个Group对一个消息Id订阅多次，也会只接收一次，具体代码如下SubscriberService.cs中新增Group参数1[CapSubscribe(\"jiamiao.x.cap.demo.show.time\",Group = \"SubscriberService\")] SubController.cs中新增Group参数1[CapSubscribe(\"jiamiao.x.cap.demo.show.time\",Group = \"SubController\")] 测试Group功能，将项目跑起来，此时再访问发送消息的api，会在控制台中打印出两条消息接收记录 创建ServiceBServiceB使用EFCore来进行配置，找ServiceA步骤2创建Jiamiao.x.CapDemo.ServiceB项目，因为.Net Core 3.1没有自带EFCore，所以这里除了CAP的4个包之外，还需要nuget安装EFCore的两个包，汇总起来需要nuget安装的包如下： 123456DotNetCore.CAPDotNetCore.CAP.DashboardDotNetCore.CAP.RabbitMQDotNetCore.CAP.SqlServerMicrosoft.EntityFrameworkCoreMicrosoft.EntityFrameworkCore.SqlServer创建ServiceDbContext.cs文件，代码如下 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using Microsoft.EntityFrameworkCore;namespace Jiamiao.x.CapDemo.ServiceB.Infrastructure&#123; public class ServiceDbContext: DbContext &#123; public ServiceDbContext(DbContextOptions&lt;ServiceDbContext&gt; options):base(options) &#123; &#125; &#125;&#125;在Startup.cs中配置EFCore和CAP，具体代码如下： 1234567891011121314151617services.AddDbContext&lt;ServiceDbContext&gt;(options =&gt;&#123; options.UseSqlServer( \"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1\");&#125;);services.AddCap(options =&gt;&#123; options.UseEntityFramework&lt;ServiceDbContext&gt;(); options.UseRabbitMQ(r =&gt; &#123; r.HostName = \"127.0.0.1\"; r.UserName = \"admin\"; r.Password = \"admin\"; &#125;); options.UseDashboard();&#125;);后续操作与ServiceA类似，需要注意：多个站点订阅同个消息Id，消息会往多个站点进行发送 附上CAP的Github地址:https://github.com/dotnetcore/CAP 还有一些配合EF的操作还没来得及写，有空再说吧","categories":[{"name":".NET","slug":"NET","permalink":"http://doc.dimsum.com/categories/NET/"}],"tags":[{"name":".NET Core","slug":"NET-Core","permalink":"http://doc.dimsum.com/tags/NET-Core/"},{"name":"CAP","slug":"CAP","permalink":"http://doc.dimsum.com/tags/CAP/"},{"name":"MicroServices","slug":"MicroServices","permalink":"http://doc.dimsum.com/tags/MicroServices/"}]},{"title":"开发常用的docker镜像","slug":"chang-yong-docker","date":"2020-03-27T04:12:12.000Z","updated":"2020-04-01T09:05:19.348Z","comments":true,"path":"2020/03/27/chang-yong-docker/","link":"","permalink":"http://doc.dimsum.com/2020/03/27/chang-yong-docker/","excerpt":"","text":"Redis Elasticsearch(集群) RabbitMq SqlServer 2017 主要用于开发阶段，不涉及生产环境配置，无权限自行添加sudo Redis 获取镜像1docker pull redis 运行Redis1docker run -p 6379:6379 -d redis:lastes redis-server Elasticsearch(集群) 说明： 这里这里使用的是Elasticsearch 7.3.0版本 集群一共有3个Container，一个Master，两个Slave 配置文件中的192.168.2.58为对应节点的IP地址 具体配置:12345678910111213141516Elasticsearch集群 |------ Master |--- 端口：9500 |--- TCP端口：9300 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data |------ Slave1 |--- 端口：9600 |--- TCP端口：9301 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data |------ Slave2 |--- 端口：9700 |--- TCP端口：9302 |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;elasticsearch.yml |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data 获取镜像1docker pull elasticsearch:7.3.0 在宿主机创建各个节点的elasticsearch.yml配置文件，具体内容如下: Master节点，配置文件路径：~/var/elasticsearch/config/master/elasticsearch.yml12345678910111213141516171819# 设置支持Elasticsearch-Headhttp.cors.enabled: truehttp.cors.allow-origin: \"*\"# 设置集群Master配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: master# 节点是否为Master，设置为true的话，说明此节点为Master节点node.master: true# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9500# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9300# 手动指定可以成为Master的所有节点的Name或者IP，这些配置将会在第一次选举中进行计算cluster.initial_master_nodes: [\"master\"]# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9301\", \"192.168.2.58:9302\"] Slave1节点，配置文件路径：~/var/elasticsearch/config/slave1/elasticsearch.yml1234567891011121314# 设置集群Slave配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: slave1# 节点是否为Master，设置为true的话，说明此节点为master节点node.master: false# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9600# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9301# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9300\", \"192.168.2.58:9302\"] Slave2节点，配置文件路径：~/var/elasticsearch/config/slave2/elasticsearch.yml1234567891011121314# 设置集群Slave配置信息cluster.name: myEsCluster# 节点的名字，一般为Master或者Slavenode.name: slave2# 节点是否为Master，设置为true的话，说明此节点为master节点node.master: false# 设置对外服务的Http端口，默认为 9200，可以修改默认设置http.port: 9700# 设置节点间交互的TCP端口，默认是9300transport.tcp.port: 9302# 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)network.host: 0.0.0.0# 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IPdiscovery.seed_hosts: [\"192.168.2.58:9300\", \"192.168.2.58:9301\"] 创建3个节点的data文件夹 123~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data 运行节点 运行Master节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/master/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/master/data:/usr/share/elasticsearch/data --name esMaster -p 9500:9500 -p 9300:9300 elasticsearch:7.3.0 运行Slave1节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/slave1/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave1/data:/usr/share/elasticsearch/data --name esSlave1 -p 9600:9600 -p 9301:9301 elasticsearch:7.3.0 运行Slave2节点1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -v ~/var/elasticsearch/config/slave2/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave2/data:/usr/share/elasticsearch/data --name esSlave2 -p 9700:9700 -p 9302:9302 elasticsearch:7.3.0 检查运行状态 运行docker ps查看正在运行的Container，确保以上3个容器正常运行 访问http://127.0.0.1:9500/_cat/nodes?v查看是否有3个节点信息，如果节点运行正常，应该有如下信息1234ip heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name172.17.0.2 32 96 70 3.03 0.82 0.28 di - slave1172.17.0.3 30 96 70 3.03 0.82 0.28 di - slave2172.17.0.4 33 96 70 3.03 0.82 0.28 dim * master 安装Elasticsearch-Head1docker run -d --name es-head -p 9100:9100 mobz/elasticsearch-head:5 运行成功后浏览器访问链接:http://127.0.0.1:9100，将里面的连接地址修改为:http://localhost:9500，保存即可看到3个节点的集群信息 安装IK分词软件 这部分操作3个节点均需要操作一边 ElasticSearch版本为7.3.0，对应IK分词版本为7.3,下载链接IK分词 具体操作就是将下载下来的包放在各个节点的共享卷里，然后进入ES容器内命令行，解压并将文件拷贝到plugins文件夹中，重启容器 RabbitMq 获取镜像1docker pull rabbitmq:management 运行镜像，设置用户名密码(admin/admin)1docker run -dit --name Myrabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:managemen 进入管理界面 http://localhost:15672 SqlServer 2017 获取镜像1docker pull mcr.microsoft.com/mssql/server:2017-latest 运行镜像，设置SA密码为Today_is_202003281docker run -e \"ACCEPT_EULA=Y\" -e \"SA_PASSWORD=Today_is_20200328\" -p 1433:1433 --name mssql -d mcr.microsoft.com/mssql/server:2017-latest","categories":[{"name":"Docker","slug":"Docker","permalink":"http://doc.dimsum.com/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://doc.dimsum.com/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://doc.dimsum.com/tags/elasticsearch/"}]}],"categories":[{"name":"StepByStep","slug":"StepByStep","permalink":"http://doc.dimsum.com/categories/StepByStep/"},{"name":".NET Core开发实战课程备忘","slug":"NET-Core开发实战课程备忘","permalink":"http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"},{"name":".NET","slug":"NET","permalink":"http://doc.dimsum.com/categories/NET/"},{"name":"Docker","slug":"Docker","permalink":"http://doc.dimsum.com/categories/Docker/"}],"tags":[{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://doc.dimsum.com/tags/Visual-Studio-Code/"},{"name":"特基础","slug":"特基础","permalink":"http://doc.dimsum.com/tags/%E7%89%B9%E5%9F%BA%E7%A1%80/"},{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"http://doc.dimsum.com/tags/ASP-NET-Core/"},{"name":"教程备忘","slug":"教程备忘","permalink":"http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"},{"name":".NET Core","slug":"NET-Core","permalink":"http://doc.dimsum.com/tags/NET-Core/"},{"name":"CAP","slug":"CAP","permalink":"http://doc.dimsum.com/tags/CAP/"},{"name":"MicroServices","slug":"MicroServices","permalink":"http://doc.dimsum.com/tags/MicroServices/"},{"name":"docker","slug":"docker","permalink":"http://doc.dimsum.com/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://doc.dimsum.com/tags/elasticsearch/"}]}