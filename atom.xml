<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dimsum</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://doc.dimsum.com/"/>
  <updated>2020-03-31T10:18:35.342Z</updated>
  <id>http://doc.dimsum.com/</id>
  
  <author>
    <name>Jiamiao.x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>.NET Core开发实战课程备忘(4) -- 用Autofac增强容器能力</title>
    <link href="http://doc.dimsum.com/2020/03/31/DependencyInjectionAutofac_document/"/>
    <id>http://doc.dimsum.com/2020/03/31/DependencyInjectionAutofac_document/</id>
    <published>2020-03-30T16:00:00.000Z</published>
    <updated>2020-03-31T10:18:35.342Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e5%bc%95%e5%85%a5autofac%e5%a2%9e%e5%bc%ba%e4%bb%80%e4%b9%88%e8%83%bd%e5%8a%9b">引入Autofac增强什么能力</a></li><li><a href="#%e6%a0%b8%e5%bf%83%e6%89%a9%e5%b1%95%e7%82%b9">核心扩展点</a></li><li><a href="#%e9%9b%86%e6%88%90autofac">集成Autofac</a></li><li><a href="#%e4%bb%a3%e7%a0%81%e9%aa%8c%e8%af%81">代码验证</a><ul><li><a href="#%e9%a1%b9%e7%9b%ae%e4%b8%8e%e4%be%9d%e8%b5%96">项目与依赖</a></li><li><a href="#%e5%9c%a8%e4%bb%a3%e7%a0%81%e4%b8%ad%e5%bc%95%e5%85%a5autofac">在代码中引入<code>Autofac</code></a></li><li><a href="#%e5%88%9b%e5%bb%ba%e6%b5%8b%e8%af%95%e6%9c%8d%e5%8a%a1">创建测试服务</a></li><li><a href="#%e8%8e%b7%e5%8f%96autofac%e6%a0%b9%e5%ae%b9%e5%99%a8">获取<code>Autofac</code>根容器</a></li><li><a href="#%e4%b8%80%e8%88%ac%e6%b3%a8%e5%86%8c%e6%9c%8d%e5%8a%a1">一般注册服务</a></li><li><a href="#%e5%9f%ba%e4%ba%8e%e5%90%8d%e5%ad%97%e6%b3%a8%e5%86%8c%e6%9c%8d%e5%8a%a1">基于名字注册服务</a></li><li><a href="#%e5%b1%9e%e6%80%a7%e6%b3%a8%e5%85%a5">属性注入</a></li><li><a href="#aop%e5%88%87%e9%9d%a2%e6%8b%a6%e6%88%aa%e5%99%a8">AOP切面拦截器</a></li><li><a href="#%e5%88%9b%e5%bb%ba%e5%ad%90%e5%ae%b9%e5%99%a8">创建子容器</a></li></ul></li></ul><h1 id="引入Autofac增强什么能力"><a href="#引入Autofac增强什么能力" class="headerlink" title="引入Autofac增强什么能力"></a>引入Autofac增强什么能力</h1><ul><li>基于名称的注入：需要把一个服务按照名称来区分它的不同实现</li><li>属性注入：直接把服务注册到某个类的属性里面去，而不需要定义构造函数</li><li>子容器：类似原生的scope，但是功能更加丰富</li><li>基于动态代理的AOP：当我们需要在服务中注入我们额外的行为的时候</li></ul><h1 id="核心扩展点"><a href="#核心扩展点" class="headerlink" title="核心扩展点"></a>核心扩展点</h1><p><code>IServiceProviderFactory&lt;TContainerBuilder&gt;</code>：第三方的依赖注入容器都是使用这个类来作为拓展点，把自己注入到整个框架里面来，也就是我们在使用依赖注入框架的时候，不需要关注谁家的特性谁家接口时怎么样的，我们直接使用官方核心的定义即可，不需要直接依赖这些框架</p><h1 id="集成Autofac"><a href="#集成Autofac" class="headerlink" title="集成Autofac"></a>集成Autofac</h1><ul><li><code>Autofac.Extensions.DependencyInjection</code></li><li><code>Autofac.Extras.DynamicProxy</code></li></ul><h1 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h1><h2 id="项目与依赖"><a href="#项目与依赖" class="headerlink" title="项目与依赖"></a>项目与依赖</h2><p>创建名字为<code>DependencyInjectionAutofacDemo</code>的<code>ASP.NET Core</code>项目，类型为<code>API</code></p><p>通过<code>nuget</code>引入以下两个包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Autofac.Extensions.DependencyInjection</span><br><span class="line">Autofac.Extras.DynamicProxy</span><br></pre></td></tr></table></figure><h2 id="在代码中引入Autofac"><a href="#在代码中引入Autofac" class="headerlink" title="在代码中引入Autofac"></a>在代码中引入<code>Autofac</code></h2><p>在<code>Program.cs</code>的<code>CreateDefaultBuilder</code>后面添加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.UseServiceProviderFactory(new AutofacServiceProviderFactory())</span><br></pre></td></tr></table></figure><p><code>UseServiceProviderFactory</code>用来注册第三方容器的入口</p><p>在<code>Startup</code>中新增<code>ConfigureContainer</code>方法，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureContainer</span>(<span class="params">ContainerBuilder builder</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此<code>Autofac</code>框架引入完毕，下面要创建测试服务类</p><h2 id="创建测试服务"><a href="#创建测试服务" class="headerlink" title="创建测试服务"></a>创建测试服务</h2><p>创建测试服务<code>MyService.cs</code>类，具体代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DependencyInjectionAutofacDemo.Services</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ShowCode</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyService</span> : <span class="title">IMyService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowCode</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"MyService.ShowCode:<span class="subst">&#123;GetHashCode()&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyServiceV2</span> : <span class="title">IMyService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> MyNameService MyNameService &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowCode</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"MyServiceV2.ShowCode:<span class="subst">&#123;GetHashCode()&#125;</span>,MyNameService是否为空:<span class="subst">&#123;MyNameService==<span class="literal">null</span>&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyNameService</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试拦截器<code>MyInterceptor.cs</code>，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Castle.DynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DependencyInjectionAutofacDemo.Services</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyInterceptor</span>:<span class="title">IInterceptor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Intercept</span>(<span class="params">IInvocation invocation</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"Intercept before,Method:<span class="subst">&#123;invocation.Method.Name&#125;</span>"</span>);</span><br><span class="line">            invocation.Proceed();</span><br><span class="line">            Console.WriteLine(<span class="string">$"Intercept after,Method:<span class="subst">&#123;invocation.Method.Name&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>IInterceptor 是Autofac面向切面最重要的一个接口，他可以把我们的逻辑注入到方法的切面里面去</li><li><code>invocation.Proceed()</code>是指具体方法的执行，如果这句不执行，就相当于把切面方法拦截了，让具体类的方法不执行</li></ul><h2 id="获取Autofac根容器"><a href="#获取Autofac根容器" class="headerlink" title="获取Autofac根容器"></a>获取<code>Autofac</code>根容器</h2><p>在<code>Startup</code>里新增类型为<code>ILifetimeScope</code>的<code>AutofacContainer</code>属性，然后在<code>Configure</code>方法中为这个属性复制为<code>Autofac</code>的根容器，具体代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Autofac;</span><br><span class="line"><span class="keyword">using</span> Autofac.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Autofac.Extras.DynamicProxy;</span><br><span class="line"><span class="keyword">using</span> DependencyInjectionAutofacDemo.Services;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Hosting;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DependencyInjectionAutofacDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Startup</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> IConfiguration Configuration &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            services.AddControllers();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureContainer</span>(<span class="params">ContainerBuilder builder</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ILifetimeScope AutofacContainer &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.AutofacContainer = app.ApplicationServices.GetAutofacRoot();</span><br><span class="line">            <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">            &#123;</span><br><span class="line">                app.UseDeveloperExceptionPage();</span><br><span class="line">            &#125;</span><br><span class="line">            app.UseHttpsRedirection();</span><br><span class="line">            app.UseRouting();</span><br><span class="line">            app.UseAuthorization();</span><br><span class="line">            app.UseEndpoints(endpoints =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                endpoints.MapControllers();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一般注册服务"><a href="#一般注册服务" class="headerlink" title="一般注册服务"></a>一般注册服务</h2><p>在<code>ConfigureContainer</code>方法中进行服务注册，然后在<code>Configure</code>方法中获取服务实现对象，调用服务的<code>ShowCode</code>方法，具体代码如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureContainer</span>(<span class="params">ContainerBuilder builder</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    builder.RegisterType&lt;MyService&gt;().As&lt;IMyService&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> serviceNoName = <span class="keyword">this</span>.AutofacContainer.Resolve&lt;IMyService&gt;();</span><br><span class="line">    serviceNoName.ShowCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Autofac注册服务与<code>ASP.NET Core</code>写法相反，先注册实现类，然后再标记这个实现类为哪种类型</strong></p><p>运行项目会看到控制台打印了<code>MyService</code>对象调用<code>ShowCode</code>方法时候打印的信息，类似信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyService.ShowCode:16336406</span><br></pre></td></tr></table></figure><h2 id="基于名字注册服务"><a href="#基于名字注册服务" class="headerlink" title="基于名字注册服务"></a>基于名字注册服务</h2><p>注释掉上一步的测试代码，一样是在<code>ConfigureContainer</code>方法中进行服务注册，然后在<code>Configure</code>方法中获取服务实现对象，调用服务的<code>ShowCode</code>方法，具体代码如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureContainer</span>(<span class="params">ContainerBuilder builder</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    builder.RegisterType&lt;MyServiceV2&gt;().Named&lt;IMyService&gt;(<span class="string">"service2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> service = <span class="keyword">this</span>.AutofacContainer.ResolveNamed&lt;IMyService&gt;(<span class="string">"service2"</span>);</span><br><span class="line">    service.ShowCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行项目会看到控制台打印了<code>MyServiceV2</code>对象调用<code>ShowCode</code>方法时候打印的信息，类似信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyServiceV2.ShowCode:16336406,MyNameService是否为空:True</span><br></pre></td></tr></table></figure><h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><p>注释掉上一步的测试代码，在<code>ConfigureContainer</code>方法中进行服务注册，注意需要先将属性的服务先进行注册，再进行调用方的服务注册，然后一样再<code>Configure</code>中获取对象，调用<code>ShowCode</code>方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureContainer</span>(<span class="params">ContainerBuilder builder</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    builder.RegisterType&lt;MyNameService&gt;();</span><br><span class="line">    builder.RegisterType&lt;MyServiceV2&gt;().As&lt;IMyService&gt;().PropertiesAutowired();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> service = <span class="keyword">this</span>.AutofacContainer.Resolve&lt;IMyService&gt;();</span><br><span class="line">    service.ShowCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行项目会看到控制台打印了<code>MyServiceV2</code>对象调用<code>ShowCode</code>方法时候打印的信息，类似信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyServiceV2.ShowCode:10309404,MyNameService是否为空:False</span><br></pre></td></tr></table></figure><p>可以发现<code>MyNameService</code>属性已经不为空了，通过属性注入的操作注入到了服务对象中去，打断点进行调试，可以看出<code>MyNameService</code>类型就是上面注册的类型</p><h2 id="AOP切面拦截器"><a href="#AOP切面拦截器" class="headerlink" title="AOP切面拦截器"></a>AOP切面拦截器</h2><p>注释掉上一步的测试代码，先在<code>ConfigureContainer</code>方法中注册拦截器，然后在服务，并指定拦截器为刚刚所注册的拦截器，并且允许接口拦截器生效，获取服务与上一步操作一致</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureContainer</span>(<span class="params">ContainerBuilder builder</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    builder.RegisterType&lt;MyInterceptor&gt;();</span><br><span class="line">    builder.RegisterType&lt;MyServiceV2&gt;().As&lt;IMyService&gt;().PropertiesAutowired().InterceptedBy(<span class="keyword">typeof</span>(MyInterceptor)).EnableInterfaceInterceptors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> service = <span class="keyword">this</span>.AutofacContainer.Resolve&lt;IMyService&gt;();</span><br><span class="line">    service.ShowCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行项目，可以看到控制台在打印出<code>MyServiceV2</code>的<code>ShowCode</code>方法所打印的信息前后，有拦截器打印出来的信息，类似信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intercept before,Method:ShowCode</span><br><span class="line">MyServiceV2.ShowCode:25116876,MyNameService是否为空:True</span><br><span class="line">Intercept after,Method:ShowCode</span><br></pre></td></tr></table></figure><h2 id="创建子容器"><a href="#创建子容器" class="headerlink" title="创建子容器"></a>创建子容器</h2><p>子容器主要适用于将服务注册进指定名字的容器里，这样只有在创建出指定名字的容器才可获取到服务对象，其他容器无法获得该服务对象，具体代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureContainer</span>(<span class="params">ContainerBuilder builder</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    builder.RegisterType&lt;MyNameService&gt;().InstancePerMatchingLifetimeScope(<span class="string">"myScope"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> myScope = <span class="keyword">this</span>.AutofacContainer.BeginLifetimeScope(<span class="string">"myScope"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> service0 = myScope.Resolve&lt;MyNameService&gt;();</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> scope = myScope.BeginLifetimeScope())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> service1 = scope.Resolve&lt;MyNameService&gt;();</span><br><span class="line">            <span class="keyword">var</span> service2 = scope.Resolve&lt;MyNameService&gt;();</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">$"service0=service1:<span class="subst">&#123;service0==service1&#125;</span>"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$"service1=service2:<span class="subst">&#123;service1==service2&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码可看到对象获取成功，并且获取到的对象在作用域内为同一个对象，类似信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service0&#x3D;service1:True</span><br><span class="line">service1&#x3D;service2:True</span><br></pre></td></tr></table></figure><p>如果这时候不通过创建指定名字的容器来获得服务对象，会发现代码运行直接报错</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e5%bc%95%e5%85%a5autofac%e5%a2%9e%e5%bc%ba%e4%bb%80%e4%b9%88%e8%83%bd%e5%8a%9b&quot;&gt;引入Autofac增强什么能力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%
      
    
    </summary>
    
    
      <category term=".NET Core开发实战课程备忘" scheme="http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"/>
    
    
      <category term="ASP.NET Core" scheme="http://doc.dimsum.com/tags/ASP-NET-Core/"/>
    
      <category term="教程备忘" scheme="http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>.NET Core开发实战课程备忘(3) -- 作用域与对象释放行为</title>
    <link href="http://doc.dimsum.com/2020/03/31/DependencyInjectionScopeAndDisposable_document/"/>
    <id>http://doc.dimsum.com/2020/03/31/DependencyInjectionScopeAndDisposable_document/</id>
    <published>2020-03-30T16:00:00.000Z</published>
    <updated>2020-03-31T04:28:11.520Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e5%ae%9e%e7%8e%b0idisposable%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b%e7%9a%84%e9%87%8a%e6%94%be">实现<code>IDisposable</code>接口类型的释放</a></li><li><a href="#%e5%bb%ba%e8%ae%ae">建议</a></li><li><a href="#%e4%bb%a3%e7%a0%81%e9%aa%8c%e8%af%81">代码验证</a><ul><li><a href="#%e9%a1%b9%e7%9b%ae">项目</a></li><li><a href="#%e5%88%9b%e5%bb%ba%e6%b5%8b%e8%af%95%e6%9c%8d%e5%8a%a1">创建测试服务</a></li><li><a href="#%e6%b5%8b%e8%af%95transient%e6%9c%8d%e5%8a%a1%e7%9a%84%e9%87%8a%e6%94%be%e6%97%b6%e6%9c%ba">测试<code>Transient</code>服务的释放时机</a></li><li><a href="#%e6%b5%8b%e8%af%95scope%e6%9c%8d%e5%8a%a1%e7%9a%84%e9%87%8a%e6%94%be%e6%97%b6%e6%9c%ba">测试<code>Scope</code>服务的释放时机</a></li><li><a href="#%e6%b5%8b%e8%af%95singleton%e6%9c%8d%e5%8a%a1%e7%9a%84%e9%87%8a%e6%94%be%e6%97%b6%e6%9c%ba">测试<code>Singleton</code>服务的释放时机</a></li></ul></li><li><a href="#%e9%81%bf%e5%9d%91">避坑</a><ul><li><a href="#%e8%87%aa%e5%b7%b1new%e6%9c%8d%e5%8a%a1">自己<code>new</code>服务</a></li><li><a href="#%e5%9c%a8%e8%b7%9f%e5%ae%b9%e5%99%a8%e8%8e%b7%e5%8f%96transient%e6%9c%8d%e5%8a%a1">在跟容器获取<code>Transient</code>服务</a></li></ul></li></ul><h1 id="实现IDisposable接口类型的释放"><a href="#实现IDisposable接口类型的释放" class="headerlink" title="实现IDisposable接口类型的释放"></a>实现<code>IDisposable</code>接口类型的释放</h1><ul><li><code>DI</code>只负责释放其创建的对象实例</li><li><code>DI</code>在容器或子容器释放时，释放尤其创建的对象实例</li></ul><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><ul><li>避免在根容器获取实现了<code>IDisposable</code>接口的瞬时服务</li><li>避免手动创建实现了<code>IDisposable</code>对象，应该使用容器来管理其生命周期</li></ul><h1 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h1><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>创建名为<code>DependencyInjectionScopeAndDisposableDemo</code>的<code>ASP.NET Core</code>项目，类型为<code>API</code></p><h2 id="创建测试服务"><a href="#创建测试服务" class="headerlink" title="创建测试服务"></a>创建测试服务</h2><p>创建测试服务类<code>OrderService.cs</code>，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DependencyInjectionScopeAndDisposableDemo.Services</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IOrderService</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DisposableOrderService</span> : <span class="title">IOrderService</span>, <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"DisposableOrderService Disposed:<span class="subst">&#123;<span class="keyword">this</span>.GetHashCode()&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试Transient服务的释放时机"><a href="#测试Transient服务的释放时机" class="headerlink" title="测试Transient服务的释放时机"></a>测试<code>Transient</code>服务的释放时机</h2><p>在<code>Startup.ConfigureServices</code>里注册一个瞬时服务</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddTransient&lt;IOrderService, DisposableOrderService&gt;();</span><br></pre></td></tr></table></figure><p>在<code>WeatherForecastController</code>里的<code>Get</code>方法通过方法参数的形式获取两个<code>IOrderService</code>接口对象，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Get</span>(<span class="params">[FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"=====接口请求处理结束===="</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存之后运行项目，可以看到在打印接口请求处理结束之后两个对象都被释放掉，类似以下信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">DisposableOrderService Disposed:64923656</span><br><span class="line">DisposableOrderService Disposed:11404313</span><br></pre></td></tr></table></figure><p>得出的结论是：<strong>transient</strong>对象会在使用后被释放</p><h2 id="测试Scope服务的释放时机"><a href="#测试Scope服务的释放时机" class="headerlink" title="测试Scope服务的释放时机"></a>测试<code>Scope</code>服务的释放时机</h2><p>注释掉上一步注册瞬时服务的代码，重新注册一个<code>scope</code>服务，这里使用工厂模式，只是熟悉以下工厂模式的写法，没特殊意义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;IOrderService&gt;(serviceProvider =&gt; <span class="keyword">new</span> DisposableOrderService());</span><br></pre></td></tr></table></figure><p>这时运行项目，控制台会打印出一个对象被释放，因为<code>scope</code>服务在当前容器内为单例，下面就这个结论再次测试以下，用using创建一个服务容器出来，看是否能创建出新的服务对象，并且代码运行超过using范围，服务对象是否会被释放。在<code>WeatherForecastController</code>的<code>Get</code>方法新增创建容器和获取服务操作，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Get</span>(<span class="params">[FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"========1=========="</span>);</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> scope = HttpContext.RequestServices.CreateScope())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> service = scope.ServiceProvider.GetService&lt;IOrderService&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">"========2=========="</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">"=====接口请求处理结束===="</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpContext.RequestServices.CreateScope()</code>表示从根容器中创建一个子容器出来，<code>scope.ServiceProvider.GetService&lt;IOrderService&gt;()</code>表示从创建出来的子容器获取<code>IOrderService</code>的服务实现对象，运行项目可以得到两个对象被释放的信息，类似以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">DisposableOrderService Disposed:5568949</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;接口请求处理结束&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">DisposableOrderService Disposed:31307802</span><br></pre></td></tr></table></figure><p>得出结论是：<strong>scope</strong>对象会在对象产生的容器被释放的时候同时一起释放</p><h2 id="测试Singleton服务的释放时机"><a href="#测试Singleton服务的释放时机" class="headerlink" title="测试Singleton服务的释放时机"></a>测试<code>Singleton</code>服务的释放时机</h2><p>注释掉上一步注册scope服务的代码，重新注册一个<code>singleton</code>服务，这里一样使用工厂模式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt; <span class="keyword">new</span> DisposableOrderService());</span><br></pre></td></tr></table></figure><p>将<code>WeatherForecastController</code>的<code>Get</code>方法修改为以下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Get</span>(<span class="params">[FromServices] IOrderService orderService1, [FromServices] IOrderService orderService2,[FromServices] IHostApplicationLifetime hostApplicationLifetime,[FromQuery]<span class="keyword">bool</span> isStop=<span class="literal">false</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isStop)</span><br><span class="line">    &#123;</span><br><span class="line">        hostApplicationLifetime.StopApplication();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">"=====接口请求处理结束===="</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有获取了另一个服务<code>IHostApplicationLifetime</code>，这个服务对象控制了整个应用程序的生命周期，可以调用这个服务对象的<code>StopApplication</code>方法来停止应用程序，即停止整个站点，为了方便测试这里用了<code>isStop</code>这个参数来控制是否停止应用程序</p><p>运行项目，不管怎么刷新<code>/WeatherForecast</code>链接，都不会有对象被释放的信息打印出来，访问<code>/WeatherForecast?isStop=true</code>的时候，会看到应用程序被停止，同时打印出对象被释放的信息，类似以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Application is shutting down...</span><br><span class="line">DisposableOrderService Disposed:3165221</span><br></pre></td></tr></table></figure><p>得出结论是：<strong>scope对象只会在根容器释放的时候才会被释放，即所有单例模式的对象都会被注册在根容器上面</strong></p><h1 id="避坑"><a href="#避坑" class="headerlink" title="避坑"></a>避坑</h1><h2 id="自己new服务"><a href="#自己new服务" class="headerlink" title="自己new服务"></a>自己<code>new</code>服务</h2><p>开始有个结论：<code>DI</code>只负责释放其创建的对象实例，这里进行验证以下自己new一个对象然后注入到容器中，看看是否能释放。这里注入了一个<code>singleton</code>对象，需注释掉上面做测试的代码，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myOrderService &#x3D; new DisposableOrderService();</span><br><span class="line">services.AddSingleton&lt;IOrderService&gt;(myOrderService);</span><br></pre></td></tr></table></figure><p>控制器代码不用改，运行项目，访问<code>/WeatherForecast</code>发现不会有对象被释放，访问<code>/WeatherForecast?isStop=true</code>时，应用程序被停止，但是也一样没有对象被释放的信息，所以这个对象最终还是没被释放</p><h2 id="在跟容器获取Transient服务"><a href="#在跟容器获取Transient服务" class="headerlink" title="在跟容器获取Transient服务"></a>在跟容器获取<code>Transient</code>服务</h2><p>注释掉上面的测试代码，在<code>Startup.ConfigureServices</code>中注册一个瞬时服务，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddTransient&lt;IOrderService, DisposableOrderService&gt;();</span><br></pre></td></tr></table></figure><p>在<code>Startup.Configure</code>中从根容器获取瞬时服务对象，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = app.ApplicationServices.GetService&lt;IOrderService&gt;();</span><br><span class="line">    <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseDeveloperExceptionPage();</span><br><span class="line">    &#125;</span><br><span class="line">    app.UseHttpsRedirection();</span><br><span class="line">    app.UseRouting();</span><br><span class="line">    app.UseAuthorization();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapControllers();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>WeatherForecastController</code>的<code>Get</code>方法修改为以下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Get</span>(<span class="params">[FromServices] IHostApplicationLifetime hostApplicationLifetime, [FromQuery]<span class="keyword">bool</span> isStop = <span class="literal">false</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isStop)</span><br><span class="line">    &#123;</span><br><span class="line">        hostApplicationLifetime.StopApplication();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">"=====接口请求处理结束===="</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行项目，访问<code>/WeatherForecast</code>接口，发现并不会有对象被释放的信息，在带上<code>isStop=true</code>的参数的时候，应用程序被停止，这时才有对象被释放的信息，类似信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Application is shutting down...</span><br><span class="line">DisposableOrderService Disposed:41149443</span><br></pre></td></tr></table></figure><p>得出结论：<strong>由于根容器只会在应用程序整个退出时回收，这就意味着即使这是个瞬时服务，但是应用程序不退出，这些对象会一直积累在应用程序内不得释放</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e5%ae%9e%e7%8e%b0idisposable%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b%e7%9a%84%e9%87%8a%e6%94%be&quot;&gt;实现&lt;code&gt;IDisposable&lt;/code&gt;接
      
    
    </summary>
    
    
      <category term=".NET Core开发实战课程备忘" scheme="http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"/>
    
    
      <category term="ASP.NET Core" scheme="http://doc.dimsum.com/tags/ASP-NET-Core/"/>
    
      <category term="教程备忘" scheme="http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>.NET Core开发实战课程备忘(2) -- 依赖注入：良好架构的起点</title>
    <link href="http://doc.dimsum.com/2020/03/30/DependencyInjection_document/"/>
    <id>http://doc.dimsum.com/2020/03/30/DependencyInjection_document/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T16:34:23.805Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e6%a1%86%e6%9e%b6ioc%e6%a1%86%e6%9e%b6">为什么要使用依赖注入框架(IoC框架)</a><ul><li><a href="#%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e6%a1%86%e6%9e%b6%e7%bb%84%e4%bb%b6%e5%8c%85">依赖注入框架组件包</a></li><li><a href="#%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e6%a1%86%e6%9e%b6%e6%a0%b8%e5%bf%83%e7%b1%bb%e5%9e%8b">依赖注入框架核心类型</a></li><li><a href="#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">生命周期</a></li></ul></li><li><a href="#%e4%bb%a3%e7%a0%81%e6%bc%94%e7%a4%ba">代码演示</a><ul><li><a href="#%e9%a1%b9%e7%9b%ae">项目</a></li><li><a href="#%e7%a4%ba%e4%be%8b%e6%9c%8d%e5%8a%a1%e7%b1%bb">示例服务类</a></li><li><a href="#%e9%aa%8c%e8%af%81%e4%b8%8d%e5%90%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e7%9a%84%e5%ae%9e%e7%8e%b0">验证不同生命周期的实现</a><ul><li><a href="#%e6%b3%a8%e5%86%8c%e4%b8%8d%e5%90%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e7%9a%84%e6%9c%8d%e5%8a%a1">注册不同生命周期的服务</a></li><li><a href="#%e5%9c%a8%e6%96%b9%e6%b3%95%e5%8f%82%e6%95%b0%e4%b8%ad%e8%8e%b7%e5%be%97%e6%9c%8d%e5%8a%a1%e8%bf%9b%e8%a1%8c%e9%aa%8c%e8%af%81">在方法参数中获得服务进行验证</a></li></ul></li><li><a href="#%e5%85%b6%e4%bb%96%e6%96%b9%e5%bc%8f%e6%b3%a8%e5%86%8c%e6%9c%8d%e5%8a%a1%e4%bb%a5%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e4%b8%ba%e4%be%8b">其他方式注册服务(以单例模式为例)</a><ul><li><a href="#%e7%9b%b4%e6%8e%a5new%e5%af%b9%e8%b1%a1">直接new对象</a></li><li><a href="#%e9%80%9a%e8%bf%87%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f%e6%b3%a8%e5%86%8c%e5%af%b9%e8%b1%a1">通过工厂模式注册对象</a></li></ul></li><li><a href="#%e5%b0%9d%e8%af%95%e6%b3%a8%e5%86%8c%e6%9c%8d%e5%8a%a1">尝试注册服务</a></li><li><a href="#%e7%a7%bb%e9%99%a4%e5%92%8c%e6%9b%bf%e6%8d%a2%e6%9c%8d%e5%8a%a1">移除和替换服务</a><ul><li><a href="#%e7%a7%bb%e9%99%a4%e6%9c%8d%e5%8a%a1">移除服务</a></li><li><a href="#%e6%9b%bf%e6%8d%a2%e6%9c%8d%e5%8a%a1">替换服务</a></li></ul></li><li><a href="#%e6%b3%9b%e5%9e%8b%e6%9c%8d%e5%8a%a1%e6%b3%a8%e5%86%8c">泛型服务注册</a></li></ul></li><li><a href="#%e6%9c%8d%e5%8a%a1%e5%af%b9%e8%b1%a1%e7%9a%84%e8%8e%b7%e5%8f%96">服务对象的获取</a></li></ul><h1 id="为什么要使用依赖注入框架-IoC框架"><a href="#为什么要使用依赖注入框架-IoC框架" class="headerlink" title="为什么要使用依赖注入框架(IoC框架)"></a>为什么要使用依赖注入框架(IoC框架)</h1><ul><li>借助依赖注入框架，我们可以轻松管理类之间的依赖，帮助我们在构建应用是遵循设计规则，确保代码的可维护性和可拓展性</li><li>ASP.NET Core的整个架构中，依赖注入框架提供了对象创建和生命周期管理的核心能力，各个组件相互写作，也是由依赖注入框架的能力来实现的</li></ul><h2 id="依赖注入框架组件包"><a href="#依赖注入框架组件包" class="headerlink" title="依赖注入框架组件包"></a>依赖注入框架组件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Extensions.DependencyInjection.Abstractions &#x2F;&#x2F;抽象包</span><br><span class="line">Microsoft.Extensions.DependencyInjection  &#x2F;&#x2F;具体实现</span><br></pre></td></tr></table></figure><h2 id="依赖注入框架核心类型"><a href="#依赖注入框架核心类型" class="headerlink" title="依赖注入框架核心类型"></a>依赖注入框架核心类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IServiceCollection &#x2F;&#x2F;负责服务的注册</span><br><span class="line">ServiceDescriptor &#x2F;&#x2F;每个服务注册时的信息</span><br><span class="line">IServiceProvider  &#x2F;&#x2F;具体的容器，也是由ServiceCollection Build出来</span><br><span class="line">IServiceScope  &#x2F;&#x2F;表示一个容器的子容器的生命周期</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Singleton  &#x2F;&#x2F;单例：在整个根容器的生命周期内获得的都是同一个单例对象</span><br><span class="line">Scoped     &#x2F;&#x2F;作用域：在我的Scope的生命周期内，如果我的容器释放掉，则意味着我的对象释放掉，在这个生命周期范围内获得到的是一个单例对象</span><br><span class="line">Transient  &#x2F;&#x2F;瞬时：每一次从容器里获取对象时都产生一个新的对象</span><br></pre></td></tr></table></figure><h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>创建名为<code>DependencyInjectionDemo</code>的<code>ASP.NET Core</code>项目，类型为<code>API</code></p><h2 id="示例服务类"><a href="#示例服务类" class="headerlink" title="示例服务类"></a>示例服务类</h2><p>一共有5个示例服务类接口，分别为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IGenericService&lt;T&gt;</span><br><span class="line">    |-- GenericService&lt;T&gt;   &#x2F;&#x2F;对应实现类</span><br><span class="line">IMyScopeService</span><br><span class="line">    |-- MyScopeService      &#x2F;&#x2F;对应实现类</span><br><span class="line">IMySingletonService</span><br><span class="line">    |-- MySingletonService  &#x2F;&#x2F;对应实现类</span><br><span class="line">IMyTransientService</span><br><span class="line">    |-- MyTransientService  &#x2F;&#x2F;对应实现类</span><br><span class="line">IOrderService</span><br><span class="line">    |-- OrderService        &#x2F;&#x2F;对应实现类</span><br><span class="line">    |-- OrderServiceEX      &#x2F;&#x2F;对应实现类</span><br></pre></td></tr></table></figure><p>因为是示例服务类，所以所有类和服务均没有属性和方法，纯粹为了验证服务注册和服务对象</p><h2 id="验证不同生命周期的实现"><a href="#验证不同生命周期的实现" class="headerlink" title="验证不同生命周期的实现"></a>验证不同生命周期的实现</h2><h3 id="注册不同生命周期的服务"><a href="#注册不同生命周期的服务" class="headerlink" title="注册不同生命周期的服务"></a>注册不同生命周期的服务</h3><p>在<code>Startup.ConfigureServices</code>方法中新增以下代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册Singleton服务</span></span><br><span class="line">services.AddSingleton&lt;IMySingletonService, MySingletonService&gt;();</span><br><span class="line"><span class="comment">// 注册Scope服务</span></span><br><span class="line">services.AddScoped&lt;IMyScopeService, MyScopeService&gt;();</span><br><span class="line"><span class="comment">// 注册Transient服务</span></span><br><span class="line">services.AddTransient&lt;IMyTransientService, MyTransientService&gt;();</span><br></pre></td></tr></table></figure><h3 id="在方法参数中获得服务进行验证"><a href="#在方法参数中获得服务进行验证" class="headerlink" title="在方法参数中获得服务进行验证"></a>在方法参数中获得服务进行验证</h3><ol><li>修改<code>WeatherForecastController</code>类的<code>Route</code>标识为<code>[Route(&quot;[controller]/[action]&quot;)]</code>，方便进行测试</li><li>在<code>WeatherForecastController</code>新增<code>GetService</code>方法，代码如下：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetService</span>(<span class="params">[FromServices] IMySingletonService singletonService1,</span></span></span><br><span class="line"><span class="function"><span class="params">    [FromServices] IMySingletonService singletonService2,</span></span></span><br><span class="line"><span class="function"><span class="params">    [FromServices] IMyScopeService scopeService1,</span></span></span><br><span class="line"><span class="function"><span class="params">    [FromServices] IMyScopeService scopeService2,</span></span></span><br><span class="line"><span class="function"><span class="params">    [FromServices] IMyTransientService transientService1,</span></span></span><br><span class="line"><span class="function"><span class="params">    [FromServices] IMyTransientService transientService2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(singletonService1)&#125;</span>:<span class="subst">&#123;singletonService1.GetHashCode()&#125;</span>"</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(singletonService2)&#125;</span>:<span class="subst">&#123;singletonService2.GetHashCode()&#125;</span>"</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(scopeService1)&#125;</span>:<span class="subst">&#123;scopeService1.GetHashCode()&#125;</span>"</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(scopeService2)&#125;</span>:<span class="subst">&#123;scopeService2.GetHashCode()&#125;</span>"</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(transientService1)&#125;</span>:<span class="subst">&#123;transientService1.GetHashCode()&#125;</span>"</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(transientService2)&#125;</span>:<span class="subst">&#123;transientService2.GetHashCode()&#125;</span>"</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"=========请求结束========"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行项目，访问<code>/WeatherForecast/GetService</code>，控制台会打印出类似以下信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">singletonService1:23488915</span><br><span class="line">singletonService2:23488915</span><br><span class="line">scopeService1:24854661</span><br><span class="line">scopeService2:24854661</span><br><span class="line">transientService1:38972574</span><br><span class="line">transientService2:14645893</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>可以看出<code>IMySingletonService</code>的实现对象属于同一个对象，<code>IMyTransientService</code>的实现对象有多个，目前看<code>IMyScopeService</code>的实现对象为同一个，但是再次访问<code>/WeatherForecast/GetService</code>接口，就可以发现<code>IMyScopeService</code>的实现对象为新的对象，而<code>IMySingletonService</code>的实现对象还是上次访问的那个，打印信息如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">singletonService1:23488915</span><br><span class="line">singletonService2:23488915</span><br><span class="line">scopeService1:6630602</span><br><span class="line">scopeService2:6630602</span><br><span class="line">transientService1:5024928</span><br><span class="line">transientService2:38414640</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他方式注册服务-以单例模式为例"><a href="#其他方式注册服务-以单例模式为例" class="headerlink" title="其他方式注册服务(以单例模式为例)"></a>其他方式注册服务(以单例模式为例)</h2><h3 id="直接new对象"><a href="#直接new对象" class="headerlink" title="直接new对象"></a>直接new对象</h3><p>在<code>Startup.ConfigureServices</code>方法中新增以下代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton&lt;IOrderService&gt;(<span class="keyword">new</span> OrderService());</span><br></pre></td></tr></table></figure><h3 id="通过工厂模式注册对象"><a href="#通过工厂模式注册对象" class="headerlink" title="通过工厂模式注册对象"></a>通过工厂模式注册对象</h3><p>使用工厂模式注册对象，可以在委托中使用IServiceProvider参数，这也就意味着可以从容器里获取多个对象，然后进行组装，得到我们最终需要的实现实例，可以把工厂类设计的比较复杂，比如说我们的实现类依赖了容器里面的另外一个类的情况，或者我们期望用另外一个类来包装我们原有的实现的时候<br>在<code>Startup.ConfigureServices</code>方法中新增以下代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton&lt;IOrderService&gt;(serviceProvider =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderServiceEx();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="尝试注册服务"><a href="#尝试注册服务" class="headerlink" title="尝试注册服务"></a>尝试注册服务</h2><p>尝试注册服务有两种情况</p><ol><li>当指定接口已有实现类，则不再注册服务，代码如下：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.TryAddSingleton&lt;IOrderService, OrderServiceEx&gt;();</span><br></pre></td></tr></table></figure></li><li>当指定接口已有实现类，但是已注册的实现类不包含当前指定的实现类，则注册进去，如果已经包含当前的实现类，则不再注册服务，代码如下：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IOrderService,OrderService&gt;());</span><br></pre></td></tr></table></figure>在控制器里验证是否有多个实现类注册，可通过下面的方法验证(需要自行注释或修改Startup里面的服务注册情况)<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetServiceList</span>(<span class="params">[FromServices] IEnumerable&lt;IOrderService&gt; orderServices</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> orderServices)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"获取到服务实例：<span class="subst">&#123;item.ToString()&#125;</span>:<span class="subst">&#123;item.GetHashCode()&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移除和替换服务"><a href="#移除和替换服务" class="headerlink" title="移除和替换服务"></a>移除和替换服务</h2><h3 id="移除服务"><a href="#移除服务" class="headerlink" title="移除服务"></a>移除服务</h3>指的是直接从容器中移除指定接口的所有实现类，代码如下：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.RemoveAll&lt;IOrderService&gt;();</span><br></pre></td></tr></table></figure><h3 id="替换服务"><a href="#替换服务" class="headerlink" title="替换服务"></a>替换服务</h3>指的是替换指定接口的实现类，同时也会替换该服务的生命周期，代码如下：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.Replace(ServiceDescriptor.Singleton&lt;IOrderService, OrderServiceEx&gt;());</span><br></pre></td></tr></table></figure></li></ol><h2 id="泛型服务注册"><a href="#泛型服务注册" class="headerlink" title="泛型服务注册"></a>泛型服务注册</h2><p>即对泛型服务注册，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton(<span class="keyword">typeof</span>(IGenericService&lt;&gt;), <span class="keyword">typeof</span>(GenericService&lt;&gt;));</span><br></pre></td></tr></table></figure><p>可以通过在控制器的构造函数中获取到服务对象，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeatherForecastController</span>(<span class="params">ILogger&lt;WeatherForecastController&gt; logger,IOrderService orderService,IGenericService&lt;IOrderService&gt; genericService</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _logger = logger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过断点查看最终<code>IGenericService</code>的<code>IOrderService</code>为哪个实现类</p><h1 id="服务对象的获取"><a href="#服务对象的获取" class="headerlink" title="服务对象的获取"></a>服务对象的获取</h1><p>通过上面可以看出，服务对象有两种获取方式，一种是通过构造函数直接注入，一种是通过函数参数，使用<code>[FromServices]</code>标签来注入</p><p><strong>一般按照使用情况来确定用哪种方式，如果整个类使用地方比较多，则使用构造函数注入，如果只有某一个方法使用，则一般使用函数参数来注入</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e6%a1%86%e6%9e%b6ioc%e6%a1%86%
      
    
    </summary>
    
    
      <category term=".NET Core开发实战课程备忘" scheme="http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"/>
    
    
      <category term="ASP.NET Core" scheme="http://doc.dimsum.com/tags/ASP-NET-Core/"/>
    
      <category term="教程备忘" scheme="http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>.NET Core开发实战课程备忘(1) -- ASP.NET Core的启动流程</title>
    <link href="http://doc.dimsum.com/2020/03/30/StartupDemo_document/"/>
    <id>http://doc.dimsum.com/2020/03/30/StartupDemo_document/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T16:33:21.980Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e8%af%be%e7%a8%8b%e7%9b%ae%e6%a0%87">课程目标</a></li><li><a href="#%e5%88%9b%e5%bb%ba%e9%a1%b9%e7%9b%ae">创建项目</a></li><li><a href="#%e6%b7%bb%e5%8a%a0%e6%97%a5%e5%bf%97%e4%bb%a3%e7%a0%81">添加日志代码</a></li><li><a href="#%e8%bf%90%e8%a1%8c%e7%bb%93%e6%9e%9c">运行结果</a></li><li><a href="#%e7%bb%93%e8%ae%ba">结论</a></li><li><a href="#%e5%8f%a6%e5%a4%96">另外</a></li></ul><h1 id="课程目标"><a href="#课程目标" class="headerlink" title="课程目标"></a>课程目标</h1><p>主要是掌握<code>ASP.NET Core</code>应用程序启动的流程，同时了解启动过程中哪些方法做了哪些操作</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>创建<code>ASP.NET Core Web</code>项目，项目类型选择<code>API</code>，直接创建即可</p><h1 id="添加日志代码"><a href="#添加日志代码" class="headerlink" title="添加日志代码"></a>添加日志代码</h1><p>本实例不涉及任何业务代码，纯粹只是添加日志查看各个方法的调用流程</p><p>修改<code>Program.cs</code>，以下直接放修改后的代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Hosting;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StartupDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CreateHostBuilder(args).Build().Run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"ConfigureWebHostDefaults"</span>);</span><br><span class="line">                    webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureServices(service =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"ConfigureServices"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureAppConfiguration(builder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"ConfigureAppConfiguration"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureHostConfiguration(builder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"ConfigureHostConfiguration"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>Startup.cs</code>，以下直接放修改后的代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Hosting;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StartupDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Startup</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Startup.Ctor"</span>);</span><br><span class="line">            Configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> IConfiguration Configuration &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Startup.ConfigureServices"</span>);</span><br><span class="line">            services.AddControllers();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Startup.Configure"</span>);</span><br><span class="line">            <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">            &#123;</span><br><span class="line">                app.UseDeveloperExceptionPage();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            app.UseHttpsRedirection();</span><br><span class="line"></span><br><span class="line">            app.UseRouting();</span><br><span class="line"></span><br><span class="line">            app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">            app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">            app.UseEndpoints(endpoints =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                endpoints.MapControllers();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>参照上面将代码修改完，直接运行代码，控制台将打印出以下信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConfigureWebHostDefaults</span><br><span class="line">ConfigureHostConfiguration</span><br><span class="line">ConfigureAppConfiguration</span><br><span class="line">Startup.Ctor</span><br><span class="line">Startup.ConfigureServices</span><br><span class="line">ConfigureServices</span><br><span class="line">Startup.Configure</span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>以下为<code>ASP.NET Core</code>启动运行流程</p><ul><li><code>ConfigureWebHostDefaults</code>：注册了应用程序必要的几个组件，比如说配置的组件、容器的组件等</li><li><code>ConfigureHostConfiguration</code>：配置程序启动时必要的配置，比如说程序启动时所需要监听的端口、需要监听的URL地址等，在这个过程可以嵌入我们自己的配置内容注入到配置的框架中去</li><li><code>ConfigureAppConfiguration</code>：嵌入我们自己的配置文件，供应用程序来读取，这些配置将来会在后续的应用程序执行过程中每个组件读取</li><li><code>ConfigureServices/ConfigureLogging/Startup/Startup.ConfigureServices</code>：这些都是往容器里面来注入我们的应用的组件</li><li><code>Startup.Configure</code>：注入中间件，处理HttpContext整个的请求过程</li></ul><h1 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h1><p>从代码运行来看，<code>Startup.cs</code>这个类可以被整合到<code>Program.cs</code>里的<code>ConfigureWebHostDefaults</code>方法中，<br>可以直接<code>ConfigureWebHostDefaults</code>方法中直接使用<code>webBuilder</code>调用<code>ConfigureServices</code>和<code>Configure</code>两个方法<br>具体可以参考以下代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Hosting;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StartupDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CreateHostBuilder(args).Build().Run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"ConfigureWebHostDefaults"</span>);</span><br><span class="line">                    webBuilder.ConfigureServices(services =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">"Program.ConfigureServices"</span>);</span><br><span class="line">                        services.AddControllers();</span><br><span class="line">                    &#125;);</span><br><span class="line">                    webBuilder.Configure(app =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">"Program.Configure"</span>);</span><br><span class="line">                        app.UseHttpsRedirection();</span><br><span class="line">                        app.UseRouting();</span><br><span class="line">                        app.UseAuthorization();</span><br><span class="line">                        app.UseStaticFiles();</span><br><span class="line">                        app.UseEndpoints(endpoints =&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            endpoints.MapControllers();</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureServices(service =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"ConfigureServices"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureAppConfiguration(builder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"ConfigureAppConfiguration"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureHostConfiguration(builder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"ConfigureHostConfiguration"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是为了代码结构更加合理，还是需要用<code>Startup</code>这个类来分离变动比较大的代码</strong></p><p><strong>通常是在Startup.ConfigureServices的方法里做服务注册，一般是Addxxx</strong></p><p><strong>在Startup.Configure决定注册那些中间件到处理过程中去</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e8%af%be%e7%a8%8b%e7%9b%ae%e6%a0%87&quot;&gt;课程目标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e5%88%9b%e5%bb%ba%e9%a1%b9%e7%9b%ae&quot;&gt;创建项目&lt;/a&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term=".NET Core开发实战课程备忘" scheme="http://doc.dimsum.com/categories/NET-Core%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B%E5%A4%87%E5%BF%98/"/>
    
    
      <category term="ASP.NET Core" scheme="http://doc.dimsum.com/tags/ASP-NET-Core/"/>
    
      <category term="教程备忘" scheme="http://doc.dimsum.com/tags/%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>开发常用的docker镜像</title>
    <link href="http://doc.dimsum.com/2020/03/27/chang-yong-docker/"/>
    <id>http://doc.dimsum.com/2020/03/27/chang-yong-docker/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-03-28T16:58:35.771Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#redis">Redis</a></li><li><a href="#elasticsearch%e9%9b%86%e7%be%a4">Elasticsearch(集群)</a></li><li><a href="#rabbitmq">RabbitMq</a></li><li><a href="#sqlserver-2017">SqlServer 2017</a></li></ul><p>主要用于开发阶段，不涉及生产环境配置，无权限自行添加<code>sudo</code></p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ol><li>获取镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></li><li>运行Redis<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -d redis:lastes redis-server</span><br></pre></td></tr></table></figure></li></ol><h1 id="Elasticsearch-集群"><a href="#Elasticsearch-集群" class="headerlink" title="Elasticsearch(集群)"></a>Elasticsearch(集群)</h1><ol start="0"><li>说明：<ul><li>这里这里使用的是Elasticsearch 7.3.0版本</li><li>集群一共有3个Container，一个Master，两个Slave</li><li>配置文件中的<code>192.168.2.58</code>为对应节点的IP地址</li><li>具体配置:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Elasticsearch集群</span><br><span class="line">    |------ Master</span><br><span class="line">        |--- 端口：9500</span><br><span class="line">        |--- TCP端口：9300</span><br><span class="line">        |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;elasticsearch.yml</span><br><span class="line">        |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data</span><br><span class="line">    |------ Slave1</span><br><span class="line">        |--- 端口：9600</span><br><span class="line">        |--- TCP端口：9301</span><br><span class="line">        |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;elasticsearch.yml</span><br><span class="line">        |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data</span><br><span class="line">    |------ Slave2</span><br><span class="line">        |--- 端口：9700</span><br><span class="line">        |--- TCP端口：9302</span><br><span class="line">        |--- 配置文件目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;elasticsearch.yml</span><br><span class="line">        |--- 共享卷目录：~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data</span><br></pre></td></tr></table></figure></li></ul></li><li>获取镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.3.0</span><br></pre></td></tr></table></figure></li><li>在宿主机创建各个节点的<code>elasticsearch.yml</code>配置文件，具体内容如下:<ul><li>Master节点，配置文件路径：<code>~/var/elasticsearch/config/master/elasticsearch.yml</code><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置支持Elasticsearch-Head</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"><span class="comment"># 设置集群Master配置信息</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">myEsCluster</span></span><br><span class="line"><span class="comment"># 节点的名字，一般为Master或者Slave</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">master</span></span><br><span class="line"><span class="comment"># 节点是否为Master，设置为true的话，说明此节点为Master节点</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 设置对外服务的Http端口，默认为 9200，可以修改默认设置</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9500</span></span><br><span class="line"><span class="comment"># 设置节点间交互的TCP端口，默认是9300</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="comment"># 手动指定可以成为Master的所有节点的Name或者IP，这些配置将会在第一次选举中进行计算</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["master"]</span></span><br><span class="line"><span class="comment"># 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IP</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["192.168.2.58:9301",</span> <span class="string">"192.168.2.58:9302"</span><span class="string">]</span></span><br></pre></td></tr></table></figure></li><li>Slave1节点，配置文件路径：<code>~/var/elasticsearch/config/slave1/elasticsearch.yml</code><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置集群Slave配置信息</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">myEsCluster</span></span><br><span class="line"><span class="comment"># 节点的名字，一般为Master或者Slave</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">slave1</span></span><br><span class="line"><span class="comment"># 节点是否为Master，设置为true的话，说明此节点为master节点</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 设置对外服务的Http端口，默认为 9200，可以修改默认设置</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9600</span></span><br><span class="line"><span class="comment"># 设置节点间交互的TCP端口，默认是9300</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9301</span></span><br><span class="line"><span class="comment"># 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IP</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["192.168.2.58:9300",</span> <span class="string">"192.168.2.58:9302"</span><span class="string">]</span></span><br></pre></td></tr></table></figure></li><li>Slave2节点，配置文件路径：<code>~/var/elasticsearch/config/slave2/elasticsearch.yml</code><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置集群Slave配置信息</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">myEsCluster</span></span><br><span class="line"><span class="comment"># 节点的名字，一般为Master或者Slave</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">slave2</span></span><br><span class="line"><span class="comment"># 节点是否为Master，设置为true的话，说明此节点为master节点</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 设置对外服务的Http端口，默认为 9200，可以修改默认设置</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9700</span></span><br><span class="line"><span class="comment"># 设置节点间交互的TCP端口，默认是9300</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9302</span></span><br><span class="line"><span class="comment"># 设置网络，如果是本机的话就是127.0.0.1，其他服务器配置对应的IP地址即可(0.0.0.0支持外网访问)</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 集群发现节点信息，一般为其他节点IP加交互端口，这里一般填主机IP</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["192.168.2.58:9300",</span> <span class="string">"192.168.2.58:9301"</span><span class="string">]</span></span><br></pre></td></tr></table></figure></li></ul></li><li>创建3个节点的<code>data</code>文件夹 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;master&#x2F;data</span><br><span class="line">~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave1&#x2F;data</span><br><span class="line">~&#x2F;var&#x2F;elasticsearch&#x2F;config&#x2F;slave2&#x2F;data</span><br></pre></td></tr></table></figure></li><li>运行节点<ul><li>运行Master节点<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e ES_JAVA_OPTS=<span class="string">"-Xms256m -Xmx256m"</span> -d -v ~/var/elasticsearch/config/master/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/master/data:/usr/share/elasticsearch/data --name esMaster -p 9500:9500 -p 9300:9300 elasticsearch:7.3.0</span><br></pre></td></tr></table></figure></li><li>运行Slave1节点<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e ES_JAVA_OPTS=<span class="string">"-Xms256m -Xmx256m"</span> -d -v ~/var/elasticsearch/config/slave1/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave1/data:/usr/share/elasticsearch/data --name esSlave1 -p 9600:9600 -p 9301:9301 elasticsearch:7.3.0</span><br></pre></td></tr></table></figure></li><li>运行Slave2节点<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e ES_JAVA_OPTS=<span class="string">"-Xms256m -Xmx256m"</span> -d -v ~/var/elasticsearch/config/slave2/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v ~/var/elasticsearch/config/slave2/data:/usr/share/elasticsearch/data --name esSlave2 -p 9700:9700 -p 9302:9302 elasticsearch:7.3.0</span><br></pre></td></tr></table></figure></li></ul></li><li>检查运行状态<ul><li>运行<code>docker ps</code>查看正在运行的Container，确保以上3个容器正常运行</li><li>访问<code>http://127.0.0.1:9500/_cat/nodes?v</code>查看是否有3个节点信息，如果节点运行正常，应该有如下信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip         heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name</span><br><span class="line">172.17.0.2           32          96  70    3.03    0.82     0.28 di        -      slave1</span><br><span class="line">172.17.0.3           30          96  70    3.03    0.82     0.28 di        -      slave2</span><br><span class="line">172.17.0.4           33          96  70    3.03    0.82     0.28 dim       *      master</span><br></pre></td></tr></table></figure></li></ul></li><li>安装<code>Elasticsearch-Head</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name es-head -p 9100:9100 mobz/elasticsearch-head:5</span><br></pre></td></tr></table></figure>运行成功后浏览器访问链接:<code>http://127.0.0.1:9100</code>，将里面的连接地址修改为:<code>http://localhost:9500</code>，保存即可看到3个节点的集群信息</li><li>安装<code>IK</code>分词软件<ul><li>这部分操作3个节点均需要操作一边</li><li>ElasticSearch版本为7.3.0，对应IK分词版本为7.3,下载链接<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.3.0/elasticsearch-analysis-ik-7.3.0.zip" target="_blank" rel="noopener">IK分词</a></li><li>具体操作就是将下载下来的包放在各个节点的共享卷里，然后进入ES容器内命令行，解压并将文件拷贝到plugins文件夹中，重启容器</li></ul></li></ol><h1 id="RabbitMq"><a href="#RabbitMq" class="headerlink" title="RabbitMq"></a>RabbitMq</h1><ol><li>获取镜像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure></li><li>运行镜像，设置用户名密码(admin/admin)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name Myrabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:managemen</span><br></pre></td></tr></table></figure></li><li>进入管理界面 <code>http://localhost:15672</code></li></ol><h1 id="SqlServer-2017"><a href="#SqlServer-2017" class="headerlink" title="SqlServer 2017"></a>SqlServer 2017</h1><ol><li>获取镜像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mcr.microsoft.com/mssql/server:2017-latest</span><br></pre></td></tr></table></figure></li><li>运行镜像，设置<code>SA</code>密码为<code>Today_is_20200328</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e <span class="string">"ACCEPT_EULA=Y"</span> -e <span class="string">"SA_PASSWORD=Today_is_20200328"</span> -p 1433:1433 --name mssql -d mcr.microsoft.com/mssql/server:2017-latest</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#redis&quot;&gt;Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#elasticsearch%e9%9b%86%e7%be%a4&quot;&gt;Elasticsearch(集群)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#rabbitmq&quot;&gt;R
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://doc.dimsum.com/categories/Docker/"/>
    
    
      <category term="docker" scheme="http://doc.dimsum.com/tags/docker/"/>
    
      <category term="elasticsearch" scheme="http://doc.dimsum.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>.NET Core使用Cap</title>
    <link href="http://doc.dimsum.com/2020/03/27/dotnet-core-cap/"/>
    <id>http://doc.dimsum.com/2020/03/27/dotnet-core-cap/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-03-28T17:05:59.262Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c">准备工作</a></li><li><a href="#%e9%a1%b9%e7%9b%ae%e8%ae%be%e5%ae%9a">项目设定</a></li><li><a href="#%e5%88%9b%e5%bb%baservicea">创建ServiceA</a></li><li><a href="#%e5%88%9b%e5%bb%baserviceb">创建ServiceB</a></li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p><code>CAP</code>需要依赖消息队列和数据存储，支持情况如下：<br>消息队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Kafka</span><br><span class="line">RabbitMQ</span><br><span class="line">AzureServiceBus</span><br></pre></td></tr></table></figure><p>数据存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SqlServer</span><br><span class="line">MySql</span><br><span class="line">PostgreSql</span><br><span class="line">MongoDB</span><br></pre></td></tr></table></figure><p>两者自行搭配选择即可，其中<code>SqlServer</code>和<code>RabbitMQ</code>在docker中的安装可参照我另一篇备忘<a href="https://xiejiamiao.github.io/2020/03/27/chang-yong-docker/" target="_blank" rel="noopener">开发常用的docker镜像</a></p><h1 id="项目设定"><a href="#项目设定" class="headerlink" title="项目设定"></a>项目设定</h1><ul><li>两个服务，分别为<code>ServiceA</code>,<code>ServiceB</code></li><li><code>SqlServer</code>使用<code>CapDemo</code>数据库，默认<code>sa</code>账号，密码为<code>Today_is_20200328</code>，端口为默认的<code>1433</code>端口</li><li><code>RabbitMQ</code>安装地址为本机，默认端口，账号密码为<code>admin/admin</code></li></ul><h1 id="创建ServiceA"><a href="#创建ServiceA" class="headerlink" title="创建ServiceA"></a>创建ServiceA</h1><ol><li>在<code>Visual Studio 2019</code>中创建空白解决方案，取名为<code>Jiamiao.x.CapDemo</code></li><li>在解决方案中新建<code>Asp.net core</code>项目，名字为<code>Jiamiao.x.CapDemo.ServiceA</code>，<code>.net core</code>版本为<code>3.1</code></li><li><code>nuget</code>安装以下4个包 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DotNetCore.CAP</span><br><span class="line">DotNetCore.CAP.Dashboard</span><br><span class="line">DotNetCore.CAP.RabbitMQ</span><br><span class="line">DotNetCore.CAP.SqlServer</span><br></pre></td></tr></table></figure></li><li>在<code>Startup.cs</code>的<code>ConfigureServices</code>方法中加入以下代码 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">services.AddCap(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.UseSqlServer(<span class="string">"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1"</span>);</span><br><span class="line">    options.UseRabbitMQ(r =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        r.HostName = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        r.UserName = <span class="string">"admin"</span>;</span><br><span class="line">        r.Password = <span class="string">"admin"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    options.UseDashboard();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>此时直接运行项目，如果数据库与消息队列均能正常连接，则会在数据库中生成以下两张表 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cap.Published</span><br><span class="line">cap.Received</span><br></pre></td></tr></table></figure></li><li>在<code>Controllers/WeatherForecastController.cs</code>中编写消息发布代码<br> 6.1 通过构造函数依赖注入<code>ICapPublisher</code>对象<br> 6.2 发布消息只需要调用<code>ICapPublisher</code>对象的<code>PublishAsync</code>或<code>Publish</code>方法，传入参数为队列名和消息值，全部代码如下: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> DotNetCore.CAP;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Jiamiao.x.CapDemo.ServiceA.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecastController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span>[] Summaries = <span class="keyword">new</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"Freezing"</span>, <span class="string">"Bracing"</span>, <span class="string">"Chilly"</span>, <span class="string">"Cool"</span>, <span class="string">"Mild"</span>, <span class="string">"Warm"</span>, <span class="string">"Balmy"</span>, <span class="string">"Hot"</span>, <span class="string">"Sweltering"</span>, <span class="string">"Scorching"</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WeatherForecastController&gt; _logger;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ICapPublisher _capPublisher;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WeatherForecastController</span>(<span class="params">ILogger&lt;WeatherForecastController&gt; logger,ICapPublisher capPublisher</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _logger = logger;</span><br><span class="line">            _capPublisher = capPublisher;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; Get()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> _capPublisher.PublishAsync(<span class="string">"jiamiao.x.cap.demo.show.time"</span>, DateTime.Now);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> rng = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">return</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>).Select(index =&gt; <span class="keyword">new</span> WeatherForecast</span><br><span class="line">            &#123;</span><br><span class="line">                Date = DateTime.Now.AddDays(index),</span><br><span class="line">                TemperatureC = rng.Next(<span class="number">-20</span>, <span class="number">55</span>),</span><br><span class="line">                Summary = Summaries[rng.Next(Summaries.Length)]</span><br><span class="line">            &#125;)</span><br><span class="line">            .ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编写接收消息代码，接收消息有两种方式，一种在控制器中，即代码写在<code>***Controller.cs</code>中，另一种是在非控制器中，一般为<code>***Service.cs</code>中，以下分两步执行，因为<code>CAP</code>在默认情况下一个服务多个地方进行订阅，只会进行一次接收，除非进行分组(后面介绍)，所以<code>8/9</code>两个步骤在测试时需要注释其中一个，只保留另一个</li><li>编写在控制器中接收消息的代码，直接在控制器中写对应方法，方法参数为发送消息时传入的消息值类型，方法无返回值，再加上方法标签<code>CapSubscribe</code>即可，具体代码如下: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> DotNetCore.CAP;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Jiamiao.x.CapDemo.ServiceA.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubController</span> : <span class="title">Controller</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">CapSubscribe(<span class="meta-string">"jiamiao.x.cap.demo.show.time"</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowTime</span>(<span class="params">DateTime <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"接受方：SubController.ShowTime   接收到值：<span class="subst">&#123;<span class="keyword">value</span>&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>做到这步可以进行一次测试，就可以发现访问<code>/WeatherForecast</code>这个接口，会发送一条当前时间的消息出去，同时接收方也会在控制台打印出接收到的消息</strong></li><li>编写服务中接收消息的代码，需要注意接收消息的类需要继承<code>ICapSubscribe</code>接口，同时这里为了方便进行依赖注入，这里我们也自己定义了一个<code>ISubscriberService</code>接口，同时服务需要在<code>Startup.cs</code>的<code>ConfigureServices</code>方法中进行注册<br> 9.1 <code>ISubscriberService.cs</code>代码如下 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Jiamiao.x.CapDemo.ServiceA.Services</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISubscriberService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ReceivedShowTimeMessage</span>(<span class="params">DateTime <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 9.2 <code>SubscriberService.cs</code>代码如下 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> DotNetCore.CAP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Jiamiao.x.CapDemo.ServiceA.Services</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubscriberService</span>: <span class="title">ISubscriberService</span>, <span class="title">ICapSubscribe</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">CapSubscribe(<span class="meta-string">"jiamiao.x.cap.demo.show.time"</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReceivedShowTimeMessage</span>(<span class="params">DateTime <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"接受方：SubscriberService.ReceivedShowTimeMessage   接收到值：<span class="subst">&#123;<span class="keyword">value</span>&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 9.3 服务注册代码如下 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;ISubscriberService, SubscriberService&gt;();</span><br></pre></td></tr></table></figure> <strong>注意：这行服务注册代码需要在<code>services.AddCap</code>这个方法之前注册，否则<code>CAP</code>在进行接口扫描的时候找不到对应已经实现了<code>ICapSubscribe</code>接口的实现类，则无法进行订阅者注册</strong><br> <strong>注释掉第8步，进行第9步的测试，效果应该与第8步一致</strong></li><li>有时候一个消息需要多个消费者同时消费，则可以使用<code>Group</code>概念，消息发送代码不变，在标记<code>CapSubscribe</code>的时候，使用<code>Group</code>参数，多个Group订阅同个消息Id，消息则会对应分发到多个Group中，同个Group只能消费一次，即一个Group对一个消息Id订阅多次，也会只接收一次，具体代码如下<br>SubscriberService.cs中新增Group参数<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CapSubscribe(<span class="meta-string">"jiamiao.x.cap.demo.show.time"</span>,Group = <span class="meta-string">"SubscriberService"</span>)</span>]</span><br></pre></td></tr></table></figure>SubController.cs中新增Group参数<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CapSubscribe(<span class="meta-string">"jiamiao.x.cap.demo.show.time"</span>,Group = <span class="meta-string">"SubController"</span>)</span>]</span><br></pre></td></tr></table></figure></li><li>测试Group功能，将项目跑起来，此时再访问发送消息的api，会在控制台中打印出两条消息接收记录</li></ol><h1 id="创建ServiceB"><a href="#创建ServiceB" class="headerlink" title="创建ServiceB"></a>创建ServiceB</h1><p>ServiceB使用<code>EFCore</code>来进行配置，找<code>ServiceA</code>步骤2创建<code>Jiamiao.x.CapDemo.ServiceB</code>项目，因为<code>.Net Core 3.1</code>没有自带<code>EFCore</code>，所以这里除了<code>CAP</code>的4个包之外，还需要nuget安装<code>EFCore</code>的两个包，汇总起来需要nuget安装的包如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DotNetCore.CAP</span><br><span class="line">DotNetCore.CAP.Dashboard</span><br><span class="line">DotNetCore.CAP.RabbitMQ</span><br><span class="line">DotNetCore.CAP.SqlServer</span><br><span class="line">Microsoft.EntityFrameworkCore</span><br><span class="line">Microsoft.EntityFrameworkCore.SqlServer</span><br></pre></td></tr></table></figure><br>创建<code>ServiceDbContext.cs</code>文件，代码如下<br>    <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Jiamiao.x.CapDemo.ServiceB.Infrastructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceDbContext</span>(<span class="params">DbContextOptions&lt;ServiceDbContext&gt; options</span>):<span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在<code>Startup.cs</code>中配置<code>EFCore</code>和<code>CAP</code>，具体代码如下：<br>    <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">services.AddDbContext&lt;ServiceDbContext&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.UseSqlServer(</span><br><span class="line">        <span class="string">"Password=Today_is_20200328;Persist Security Info=True;User ID=sa;Initial Catalog=CapDemo;Data Source=127.0.0.1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">services.AddCap(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.UseEntityFramework&lt;ServiceDbContext&gt;();</span><br><span class="line">    options.UseRabbitMQ(r =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        r.HostName = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        r.UserName = <span class="string">"admin"</span>;</span><br><span class="line">        r.Password = <span class="string">"admin"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    options.UseDashboard();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>后续操作与<code>ServiceA</code>类似，需要注意：<strong>多个站点订阅同个消息Id，消息会往多个站点进行发送</strong></p><blockquote><p>附上CAP的Github地址:<a href="https://github.com/dotnetcore/CAP" target="_blank" rel="noopener">https://github.com/dotnetcore/CAP</a></p></blockquote><p><em>还有一些配合EF的操作还没来得及写，有空再说吧</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c&quot;&gt;准备工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e9%a1%b9%e7%9b%ae%e8%ae%be%e5%ae%9a&quot;&gt;项目设定&lt;/a&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term=".NET" scheme="http://doc.dimsum.com/categories/NET/"/>
    
    
      <category term=".NET Core" scheme="http://doc.dimsum.com/tags/NET-Core/"/>
    
      <category term="CAP" scheme="http://doc.dimsum.com/tags/CAP/"/>
    
      <category term="MicroServices" scheme="http://doc.dimsum.com/tags/MicroServices/"/>
    
  </entry>
  
</feed>
