<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dimsum</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.dimsum.fun/"/>
  <updated>2020-06-04T16:43:59.913Z</updated>
  <id>http://www.dimsum.fun/</id>
  
  <author>
    <name>Jiamiao.x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git常用命令备忘</title>
    <link href="http://www.dimsum.fun/2020/06/03/50.Git_document/"/>
    <id>http://www.dimsum.fun/2020/06/03/50.Git_document/</id>
    <published>2020-06-03T08:02:00.000Z</published>
    <updated>2020-06-04T16:43:59.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地仓库版本切换"><a href="#本地仓库版本切换" class="headerlink" title="本地仓库版本切换"></a>本地仓库版本切换</h1><ul><li>查询当前本版以前的所有提交记录：<code>git log --pretty=oneline</code></li><li>查询所有版本记录：<code>git reflog</code></li><li>代码切换到指定目录：<code>git reset --hard 版本号</code></li></ul><h1 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h1><ul><li>推送本地仓库代码到远程仓库：<code>git push</code></li><li>拉取远程仓库代码：<code>git pull</code></li></ul><h1 id="分支常用命令"><a href="#分支常用命令" class="headerlink" title="分支常用命令"></a>分支常用命令</h1><ul><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch 分支名</code></li><li>切换分支：<code>git checkout 分支名</code></li><li>创建再切换到新建的分支：<code>git checkout -b 分支名</code></li><li>删除分支：<code>git branch -d 分支名</code>  <strong>不能删除当前正在使用的分支</strong></li><li>合并分支：<code>git merge 被合并的分支名</code></li></ul><h1 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本地仓库版本切换&quot;&gt;&lt;a href=&quot;#本地仓库版本切换&quot; class=&quot;headerlink&quot; title=&quot;本地仓库版本切换&quot;&gt;&lt;/a&gt;本地仓库版本切换&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;查询当前本版以前的所有提交记录：&lt;code&gt;git log --pretty=o
      
    
    </summary>
    
    
      <category term="版本控制" scheme="http://www.dimsum.fun/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Git" scheme="http://www.dimsum.fun/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="http://www.dimsum.fun/2020/06/03/49.Transaction01/"/>
    <id>http://www.dimsum.fun/2020/06/03/49.Transaction01/</id>
    <published>2020-06-03T01:55:00.000Z</published>
    <updated>2020-06-04T16:43:59.912Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#概念">概念</a><ul><li><a href="#定义">定义</a></li><li><a href="#组成">组成</a></li><li><a href="#目的">目的</a></li></ul></li><li><a href="#特性">特性</a><ul><li><a href="#原子性actomicity">原子性(Actomicity)</a></li><li><a href="#一致性consistency">一致性(Consistency)</a></li><li><a href="#隔离性isolation">隔离性(Isolation)</a></li><li><a href="#持久性durability">持久性(Durability)</a></li></ul></li><li><a href="#事务隔离">事务隔离</a><ul><li><a href="#事务并发导致的异常">事务并发导致的异常</a><ul><li><a href="#回滚丢失update-lost">回滚丢失(Update Lost)</a></li><li><a href="#覆盖丢失second-uupdate-lost">覆盖丢失(Second Uupdate Lost)</a></li><li><a href="#脏读">脏读</a></li><li><a href="#不可重复读">不可重复读</a></li><li><a href="#幻读">幻读</a></li></ul></li><li><a href="#事务隔离级别">事务隔离级别</a><ul><li><a href="#读未提交">读未提交</a></li><li><a href="#读已提交">读已提交</a></li><li><a href="#可重复读">可重复读</a></li><li><a href="#串行化">串行化</a></li></ul></li><li><a href="#事务隔离级别与并发异常">事务隔离级别与并发异常</a></li></ul></li><li><a href="#mysql操作">MySql操作</a><ul><li><a href="#常用命令">常用命令</a></li></ul></li></ul><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>数据库事务</strong>是<strong>访问</strong>并可能<strong>更新</strong>数据库中各种<strong>数据项</strong>的一个<strong>程序执行单元(unit)</strong></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>一个数据库事务通常包含对数据库进行<strong>读</strong>或<strong>写</strong>的一个<strong>操作序列</strong></p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol><li>为数据库操作提供了一个<strong>从失败中恢复到正常状态的方法</strong>，同时提供了数据库即使在<strong>异常状态下仍能保持一致性的方法</strong></li><li>当多个应用程序在并发访问数据库时，可以在这些<strong>应用程序之间提供一个隔离方法，以防止</strong>彼此的<strong>操作相互干扰</strong></li></ol><p><strong>总结：事务的目的就是要提供3种方法：1.失败恢复方法，2.保持一致性的方法，3.操作隔离的方法</strong></p><ul><li>成功情况下<ul><li>能将数据从一种状态变为另一种状态，并能够持久化</li></ul></li><li>异常情况下<ul><li>能将数据恢复到正常状态</li><li>要能保证一致性，包含数据的一致性和约束的一致性</li></ul></li><li>并发情况下<ul><li>并发的操作之间不能产生相互影响</li></ul></li></ul><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="原子性-Actomicity"><a href="#原子性-Actomicity" class="headerlink" title="原子性(Actomicity)"></a>原子性(Actomicity)</h2><p>事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</p><h2 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h2><p>事务应确保数据库的状态从一个一致状态转变为另一个一致状态，一致状态的含义时数据库中数据应满足完整性约束</p><h2 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h2><p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p><h2 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h2><p>一个事务一旦提交，他对数据库的修改应该永久保存在数据库中</p><h1 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h1><h2 id="事务并发导致的异常"><a href="#事务并发导致的异常" class="headerlink" title="事务并发导致的异常"></a>事务并发导致的异常</h2><h3 id="回滚丢失-Update-Lost"><a href="#回滚丢失-Update-Lost" class="headerlink" title="回滚丢失(Update Lost)"></a>回滚丢失(Update Lost)</h3><p>第一类更新丢失，此种更新丢失时因为回滚的原因，所以也叫回滚丢失<br>|事务A|事务B|<br>|—|—|<br>|查询数据得到初始值10|查询数据得到初始值提交|<br>|更新为10+1=11|更新为10+2=12|<br>|提交|失败回滚|<br>||数据回到初始状态10，导致事务A的更新丢失了，由于回滚导致丢失，所以也叫回滚丢失|</p><h3 id="覆盖丢失-Second-Uupdate-Lost"><a href="#覆盖丢失-Second-Uupdate-Lost" class="headerlink" title="覆盖丢失(Second Uupdate Lost)"></a>覆盖丢失(Second Uupdate Lost)</h3><p>第二类更新丢失，此种更新丢失时因为更新被其他事务给覆盖了，也可以叫覆盖丢失<br>|事务A|事务B|<br>|—|—|<br>|查询数据得到初始值10|查询数据得到初始值10|<br>|更新为10+1=11|更新为10+2=12|<br>|提交|提交|<br>||最终结果变为12，由于事务B是从10开始计算，并不知道数据已经发生了变化，所以导致事务A的更新结果被覆盖了，所以也叫覆盖更新|</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>此种异常是因为一个事务读取了另一个事务修改了但是未提交的数据<br>|事务A|事务B|<br>|—|—|<br>|查询数据得到初始值10||<br>|更新为10+1=11|查询数据得到数据11|<br>||更新数据11+1=12|<br>|回滚|提交|<br>||数据最终变为12，由于读到的数据11被回滚了，结果是错误的，读取到了脏数据|</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>这种异常时一个事务对同一行数据执行了两次或更多次查询，但是却得到了不同的结果<br>| 事务A | 事务B  |<br>|—|—|<br>| 查询数据得到初始值10  | 查询数据得到初始值10  |<br>|更新为10+1=11|再次读取数据得到11|<br>||在一个事务内两次对统一数据查询，得到的结果是不同的，因此叫做不可重复读|</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读和不可重复读有点像，只是针对的不是数据的值而是数据的数量<br>|事务A|事务B|<br>|—|—|<br>|查询数据有10条||<br>|更新全部数据|插入一条数据|<br>|查询结果发现有一条没备更新，比原来多了一条||<br>|仿佛全表更新语句不正常，自己出现了幻觉，因此叫幻读||</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><strong>由低到高</strong>分成以下级别：</p><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>该隔离级别指即使一个事务的更新语句未提交，但是别的事务可以读到这个改变</p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>该隔离级别指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新，消除了脏读和回滚丢失(第一类更新丢失)，这时大多数数据库的默认隔离级别，如Oracle、SqlServer</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>该隔离级别指一个事务中进行两次或多次同样的对数据库内容的查询，得到的结果是一样的，但是不保证对数据条数的查询是一样的，指要存在读改行数据就禁止写，消除了不可重复读和覆盖丢失(第二类更新丢失)，这是MySql数据库的默认隔离级别</p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>事务执行的时候不允许别的事务并行执行，完全串行化的读，指要存在读就禁止写，但是可以同时读，消除了幻读。这是事务隔离的最高级别，虽然最安全最省心，但是效率太低，一般不会用</p><h2 id="事务隔离级别与并发异常"><a href="#事务隔离级别与并发异常" class="headerlink" title="事务隔离级别与并发异常"></a>事务隔离级别与并发异常</h2><p>各种隔离级别解决哪些并发异常<br>|隔离级别\并发异常|回滚丢失|覆盖丢失|脏读|不可重复读|幻读|<br>|—|—|—|—|—|—|<br>|读未提交|×|×|×|×|×|<br>|读已提交|√|√|×|×|×|<br>|可重复读|√|√|√|√|×|<br>|串行化|√|√|√|√|√|</p><h1 id="MySql操作"><a href="#MySql操作" class="headerlink" title="MySql操作"></a>MySql操作</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>查询当前数据库版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select version();</span><br></pre></td></tr></table></figure></li><li>查看当前会话事务隔离级别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@session.tx_isolation;</span><br></pre></td></tr></table></figure></li><li>查询全局事务隔离级别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@global.tx_isolation;</span><br></pre></td></tr></table></figure></li><li>修改隔离级别(以当前会话为例)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set @@session.tx_isolation&#x3D;&#39;会话级别&#39; </span><br><span class="line">--会话级别可选值：</span><br><span class="line">  READ-UNCOMMITTED 读未提交</span><br><span class="line">  READ-COMMITTED 读已提交</span><br><span class="line">  REPEATABLE-READ 可重复读</span><br><span class="line">  SERIALIZABLE 串行化</span><br></pre></td></tr></table></figure></li><li>开启事务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br></pre></td></tr></table></figure></li><li>提交事务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit</span><br></pre></td></tr></table></figure></li><li>回滚<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollback</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概念&quot;&gt;概念&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#定义&quot;&gt;定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#组成&quot;&gt;组成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#目的&quot;&gt;目的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="事务" scheme="http://www.dimsum.fun/categories/%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="事务" scheme="http://www.dimsum.fun/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis企业级解决方案</title>
    <link href="http://www.dimsum.fun/2020/06/02/48.Redis4_document/"/>
    <id>http://www.dimsum.fun/2020/06/02/48.Redis4_document/</id>
    <published>2020-06-02T07:48:00.000Z</published>
    <updated>2020-06-02T09:20:42.836Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#缓存预热">缓存预热</a><ul><li><a href="#现象">现象</a></li><li><a href="#问题排查">问题排查</a></li><li><a href="#解决方案">解决方案</a><ul><li><a href="#前置准备工作">前置准备工作</a></li><li><a href="#准备工作">准备工作</a></li><li><a href="#实施">实施</a></li></ul></li></ul></li><li><a href="#缓存雪崩">缓存雪崩</a><ul><li><a href="#现象-1">现象</a></li><li><a href="#问题排查-1">问题排查</a></li><li><a href="#解决方案道">解决方案（道）</a></li><li><a href="#解决方案术">解决方案（术）</a></li><li><a href="#总结">总结</a></li></ul></li><li><a href="#缓存击穿">缓存击穿</a><ul><li><a href="#现象-2">现象</a></li><li><a href="#问题排查-2">问题排查</a></li><li><a href="#问题分析">问题分析</a></li><li><a href="#解决方案术-1">解决方案（术）</a></li><li><a href="#总结-1">总结</a></li></ul></li><li><a href="#缓存穿透">缓存穿透</a><ul><li><a href="#现象-3">现象</a></li><li><a href="#问题排查-3">问题排查</a></li><li><a href="#问题分析-1">问题分析</a></li><li><a href="#解决方案术-2">解决方案（术）</a></li><li><a href="#总结-2">总结</a></li></ul></li><li><a href="#性能指标监控">性能指标监控</a><ul><li><a href="#性能指标performance">性能指标：Performance</a></li><li><a href="#内存指标memory">内存指标：Memory</a></li><li><a href="#基本活动指标basic-activity">基本活动指标：Basic activity</a></li><li><a href="#持久性指标persistence">持久性指标：Persistence</a></li><li><a href="#错误指标error">错误指标：Error</a></li></ul></li><li><a href="#监控方式">监控方式</a><ul><li><a href="#工具">工具</a></li><li><a href="#命令">命令</a></li></ul></li></ul><h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>宕机：服务器启动之后迅速宕机</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><ol><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="前置准备工作"><a href="#前置准备工作" class="headerlink" title="前置准备工作"></a>前置准备工作</h3></li><li>日常理性统计数据访问记录，统计访问频度较高的热点数据</li><li>利用LRU数据删除策略，构建数据留存队列<ol><li>例如：storm与kafka配合<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3></li></ol></li><li>将统计结果中的数据分类，根据级别，redis有限加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程<h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3></li><li>使用脚本程序固定触发数据预热过程</li><li>如果有条件，使用CDN，效果会更好</li></ol><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h2><ol><li>系统平稳运行过程中，忽然数据库连接量激增</li><li>应用服务器无法及时处理请求</li><li>大量408、500错误</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据库后再次被瞬间流量放倒<h2 id="问题排查-1"><a href="#问题排查-1" class="headerlink" title="问题排查"></a>问题排查</h2></li><li>在一个<strong>较短</strong>的时间内，缓存中<strong>较多</strong>的key<strong>集中过期</strong></li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li><li>数据库同时接收到大量的请求无法及时处理</li><li>Redis大量请求被积压，开始出现超时现象</li><li>数据库流量激增，数据库崩溃</li><li>重启后仍然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解</li><li>应用服务器无法即使得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器、Redis、数据库全部重启，效果不理想<h2 id="解决方案（道）"><a href="#解决方案（道）" class="headerlink" title="解决方案（道）"></a>解决方案（道）</h2></li><li>更多的页面静态化处理</li><li>构建多级缓存架构：nginx缓存+redis缓存+ehcache缓存</li><li>检测MySql严重耗时业务进行优化，对数据库的瓶颈排查，例如超时查询、耗时较高事务等</li><li>灾难预警机制，监控redis服务器性能指标：<ol><li>CPU占用、CPU使用率</li><li>内存容量</li><li>查询平均响应时间</li><li>线程数</li></ol></li><li>限流、降级：短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问<h2 id="解决方案（术）"><a href="#解决方案（术）" class="headerlink" title="解决方案（术）"></a>解决方案（术）</h2></li><li>LRU与LFU切换</li><li>数据有效期策略调整<ol><li>根据业务数据有效期进行分类错峰，A类90分钟、B类80分钟、C类70分钟</li><li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li></ol></li><li>超热数据使用永久key</li><li>定期维护（自动+人工）：对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li><li>加锁：慎用！！！<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>缓存雪崩就是顺接过期数据量太大，导致对数据库服务器造成压力，如果能够避免过期时间集中，可以有效解决雪崩现象的出现(40%)，配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整</li></ol><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><h2 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h2><ol><li>系统平稳运行过程中</li><li>数据库连接量瞬间激增</li><li>Redis服务器无大量key过期</li><li>Redis内存平稳，无波动</li><li>Redis服务器CPU正常</li><li>数据库崩溃<h2 id="问题排查-2"><a href="#问题排查-2" class="headerlink" title="问题排查"></a>问题排查</h2></li><li>Redis中某个key过期，该key访问量巨大</li><li>多个数据请求从服务器直接压倒Redis后，均为命中</li><li>Redis在短时间内发起了大量对数据库中同一数据的访问<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2></li><li>单个key高热数据</li><li>key过期<h2 id="解决方案（术）-1"><a href="#解决方案（术）-1" class="headerlink" title="解决方案（术）"></a>解决方案（术）</h2></li><li>预先设定：以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长。注意：购物街不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的去式</li><li>现场调整：监控访问量，对自然流量激增的数据演唱过期时间或设置未永久性key</li><li>后台刷新数据：启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li><li>二级缓存：设置不同的过期时间，保障不会被<strong>同时</strong>淘汰就行</li><li>枷锁：分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎用！！！<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2>缓存击穿就是单个高热数据过期的瞬间，数据量访问较大，未命中Redis后，发起了大量对统一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该是在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。</li></ol><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h2><ol><li>系统平稳运行过程中</li><li>应用服务器流量随时间增量较大</li><li>Redis服务器命中率随时间逐步降低</li><li>Redis内存平稳，内存无压力</li><li>Redis服务器CPU占用激增</li><li>数据库服务器压力激增</li><li>数据库崩溃</li></ol><h2 id="问题排查-3"><a href="#问题排查-3" class="headerlink" title="问题排查"></a>问题排查</h2><ol><li>Redis中大面积出现未命中</li><li>出现非正常URL访问</li></ol><h2 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h2><ol><li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li><li>Redis获得到null数据未进行持久化，直接返回</li><li>下次此类数据达到重复上述过程</li><li>出现黑客攻击服务器</li></ol><h2 id="解决方案（术）-2"><a href="#解决方案（术）-2" class="headerlink" title="解决方案（术）"></a>解决方案（术）</h2><ol><li>缓存null：对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30~60秒，最高5分钟</li><li>白名单策略<ol><li>提前预热各种分类数据id对应的bitmaps，id作为bitmap的offset，相当于设置了数据白名单，当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）</li><li>使用布隆过滤器（有关布隆过滤器的命中问题对当前状态可以忽略）</li></ol></li><li>实时监控：实时监控Redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比<ol><li>非活动时段波动：通常检测3~5倍，超过5倍纳入重点排查对象</li><li>活动时段波动：通常检测10~50倍，超过50倍纳入重点排查对象</li><li>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控</li></ol></li><li>key加密：问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验<ol><li>例如每天随机分配60个加密串，挑选2~3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</li></ol></li></ol><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>缓存击穿访问了不存在的数据，跳过了合法数据的Redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力，通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时<strong>报警</strong>，应对策略应该在临时预案方面多做文章</p><p>无论时黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除</p><h1 id="性能指标监控"><a href="#性能指标监控" class="headerlink" title="性能指标监控"></a>性能指标监控</h1><h2 id="性能指标：Performance"><a href="#性能指标：Performance" class="headerlink" title="性能指标：Performance"></a>性能指标：Performance</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>latency</td><td>Redis平均响应一个请求的时间</td></tr><tr><td>instantaneous_ops_per_sec</td><td>平均每秒处理请求总数（QPS）</td></tr><tr><td>hit rate(calculated)</td><td>缓存命中率(计算出来的)</td></tr></tbody></table><h2 id="内存指标：Memory"><a href="#内存指标：Memory" class="headerlink" title="内存指标：Memory"></a>内存指标：Memory</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>used_memory</td><td>已使用内存</td></tr><tr><td>mem_fragmentation_ratio</td><td>内存碎片率</td></tr><tr><td>evicted_key</td><td>由于最大内存限制被移除的key的数量</td></tr><tr><td>block_clients</td><td>由于BLPOP、BRPOP、BRPOPLPUSH而被阻塞的客户端</td></tr></tbody></table><h2 id="基本活动指标：Basic-activity"><a href="#基本活动指标：Basic-activity" class="headerlink" title="基本活动指标：Basic activity"></a>基本活动指标：Basic activity</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>connected_clients</td><td>客户端连接数</td></tr><tr><td>connected_slaves</td><td>slave数量</td></tr><tr><td>master_last_io_seconds_ago</td><td>最近一次主从交互之后的秒数</td></tr><tr><td>keyspace</td><td>数据库中的key值总数</td></tr></tbody></table><h2 id="持久性指标：Persistence"><a href="#持久性指标：Persistence" class="headerlink" title="持久性指标：Persistence"></a>持久性指标：Persistence</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>rdb_last_save_time</td><td>最后一次持久化保存到磁盘的时间戳</td></tr><tr><td>rdb_changes_since_last_save</td><td>自最后一次持久化以来数据库的更改数</td></tr></tbody></table><h2 id="错误指标：Error"><a href="#错误指标：Error" class="headerlink" title="错误指标：Error"></a>错误指标：Error</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>rejected_connections</td><td>由于达到maxclient限制而被拒绝的连接数</td></tr><tr><td>keyspace_misses</td><td>key值查找失败（没有命中）次数</td></tr><tr><td>master_link_down_since_seconds</td><td>主从断开的持续时间（以秒为单位）</td></tr></tbody></table><h1 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a>监控方式</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>Cloud Insight Redis</li><li>Prometheus</li><li>Redis-stat</li><li>Redis-faina</li><li>RedisLive</li><li>zabbix<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2></li><li>benchmark<ul><li><code>redis-benchmark</code>：50个连接，10000次请求对应的性能</li><li><code>redis-benchmark -c 100 -n 5000</code>：100个连接，5000次请求对应的性能</li></ul></li><li>redis-cli<ul><li>monitor</li><li>slowlog<ul><li><code>slowlog get</code>：获取慢查询日志</li><li><code>slowlog len</code>：获取慢查询日志条目数</li><li><code>slowlog reset</code>：重置慢查询日志</li><li>相关配置：<ul><li><code>slow-log-slower-than 1000</code>：设置慢查询的时间下限，单位：毫秒</li><li><code>slowlog-max-len 100</code>：设置慢查询命令对应的日志显示长度，单位：命令数</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#缓存预热&quot;&gt;缓存预热&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#现象&quot;&gt;现象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#问题排查&quot;&gt;问题排查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#解决方案&quot;&gt;解决方案&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.dimsum.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.dimsum.fun/tags/Redis/"/>
    
      <category term="NOSQL" scheme="http://www.dimsum.fun/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群</title>
    <link href="http://www.dimsum.fun/2020/06/01/47.Redis3_document/"/>
    <id>http://www.dimsum.fun/2020/06/01/47.Redis3_document/</id>
    <published>2020-06-01T07:28:00.000Z</published>
    <updated>2020-06-02T09:20:42.835Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#主从复制">主从复制</a><ul><li><a href="#简介">简介</a><ul><li><a href="#单机redis的风险与问题">单机Redis的风险与问题</a></li><li><a href="#解决方案">解决方案</a></li><li><a href="#解析">解析</a></li><li><a href="#主从复制的作用">主从复制的作用</a></li></ul></li><li><a href="#工作流程">工作流程</a><ul><li><a href="#建立连接阶段">建立连接阶段</a></li><li><a href="#连接阶段slave连master">连接阶段(slave连master)</a></li><li><a href="#授权阶段master没密码可省略">授权阶段(master没密码可省略)</a></li><li><a href="#数据同步阶段">数据同步阶段</a><ul><li><a href="#同步阶段master说明">同步阶段master说明</a></li><li><a href="#同步阶段slave说明">同步阶段slave说明</a></li></ul></li><li><a href="#命令传播阶段">命令传播阶段</a></li><li><a href="#命令传播阶段的部分复制">命令传播阶段的部分复制</a></li><li><a href="#数据同步命令传播阶段工作流程">数据同步+命令传播阶段工作流程</a></li><li><a href="#心跳机制">心跳机制</a><ul><li><a href="#master心跳任务">master心跳任务</a></li><li><a href="#slave心跳任务">slave心跳任务</a></li><li><a href="#心跳阶段注意事项">心跳阶段注意事项</a></li></ul></li></ul></li><li><a href="#主从复制的完整工作流程图">主从复制的完整工作流程图</a></li><li><a href="#常见问题">常见问题</a><ul><li><a href="#频繁的全量复制1">频繁的全量复制(1)</a></li><li><a href="#频繁的全量复制2">频繁的全量复制(2)</a></li><li><a href="#频繁的网络中断1">频繁的网络中断(1)</a></li><li><a href="#频繁的网络中断2">频繁的网络中断(2)</a></li><li><a href="#数据不一致">数据不一致</a></li></ul></li></ul></li><li><a href="#哨兵模式">哨兵模式</a><ul><li><a href="#哨兵">哨兵</a></li><li><a href="#启动哨兵">启动哨兵</a></li><li><a href="#sentinelconf">sentinel.conf</a></li><li><a href="#工作原理">工作原理</a><ul><li><a href="#监控">监控</a></li><li><a href="#通知">通知</a></li><li><a href="#故障转移">故障转移</a></li></ul></li></ul></li><li><a href="#集群">集群</a><ul><li><a href="#现状问题">现状问题</a></li><li><a href="#集群架构">集群架构</a></li><li><a href="#集群的数据存储">集群的数据存储</a></li><li><a href="#集群的内部通讯设计">集群的内部通讯设计</a></li><li><a href="#集群搭建">集群搭建</a></li><li><a href="#cluster节点操作命令">Cluster节点操作命令</a></li></ul></li></ul><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>互联网”三高”架构：高并发、高性能、高可用</p><p><em>高可用：业界可用性目标5个9，即*</em>99.999%<strong>，即全年服务器宕机时长低于315秒，</strong>约5.25分钟***</p><h3 id="单机Redis的风险与问题"><a href="#单机Redis的风险与问题" class="headerlink" title="单机Redis的风险与问题"></a>单机Redis的风险与问题</h3><ul><li>问题1：机器故障<ul><li>现象：硬盘故障、系统崩溃</li><li>本质：数据丢失，很可能对业务造成灾难性打击</li><li>结论：基本上会放弃使用Redis</li></ul></li><li>问题2：容量瓶颈<ul><li>现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存</li><li>本质：穷！硬件条件跟不上</li><li>结论：放弃使用Redis</li></ul></li><li>结论：为了避免单点Redis服务器故障，准备多台服务器，互相连通，将数据复制从多个副本保存在不同的服务器上，<strong>连接在一起</strong>，并保证数据是<strong>同步</strong>的，即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据<code>冗余备份</code></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><img src="https://i.loli.net/2020/06/01/8YE1olWtHeyvsrN.png" alt="Redis主从复制.png"></p><ul><li>提供数据方：master<ul><li>主服务器、主节点、主库</li><li>主客户端</li></ul></li><li>接受数据方：slave<ul><li>从服务器、从节点、从库</li><li>从客户端</li></ul></li><li>需要解决的问题：数据同步</li><li>核心工作：master的数据复制到slave中</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>主从复制即将master中的数据即时、有效的复制到slave中</p><p>特征：一个master可以拥有多个slave，一个slave只对应一个master</p><p>职责：</p><ul><li>master：<ul><li>写数据</li><li>执行写操作时，将出现变化的数据自动同步到slave</li><li>读数据（可忽略）</li></ul></li><li>slave<ul><li>读数据</li><li>写数据（禁止）</li></ul></li></ul><h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵与集群，实现Redis的高可用方案</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="https://i.loli.net/2020/06/01/ibGzMmkRTAdXOIx.png" alt="Redis主从复制流程.png"></p><ul><li>主从复制过程大体可以分为3个阶段<ul><li>建立连接阶段（即准备阶段）</li><li>数据同步阶段</li><li>命令传播阶段</li></ul></li></ul><h3 id="建立连接阶段"><a href="#建立连接阶段" class="headerlink" title="建立连接阶段"></a>建立连接阶段</h3><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号<br><img src="https://i.loli.net/2020/06/01/zbgBGNsdjCmt7a6.png" alt="Redis主从复制流程2.png"></p><ol><li>[slave]设置master的地址和端口，保存master信息</li><li>[slave]建立socket连接</li><li>[slave]发送ping命令(定时器任务)</li><li>[slave]身份验证</li><li>[slave]发送slave端口信息</li><li>至此主从连接成功</li><li>达到了以下状态：<ol><li>slave：保存master的地址与端口</li><li>master：保存slave的端口</li><li>总体：master与slave之间创建了连接的socket</li></ol></li></ol><h3 id="连接阶段-slave连master"><a href="#连接阶段-slave连master" class="headerlink" title="连接阶段(slave连master)"></a>连接阶段(slave连master)</h3><ul><li><p>方式一：客户端发送命令：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></li><li><p>方式二：启动服务器参数：<code>redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></li><li><p>方式三：服务器配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></li><li><p>slave系统信息</p><ul><li><code>master_link_down_since_seconds</code></li><li><code>masterhost</code></li><li><code>masterport</code></li></ul></li><li><p>master系统信息</p><ul><li><code>slave_listening_port</code>（多个）</li></ul></li></ul><h3 id="授权阶段-master没密码可省略"><a href="#授权阶段-master没密码可省略" class="headerlink" title="授权阶段(master没密码可省略)"></a>授权阶段(master没密码可省略)</h3><ul><li>master配置文件设置密码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass &lt;password&gt;</span><br></pre></td></tr></table></figure></li><li>master客户端发送命令设置密码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config get requirepass &lt;password&gt;</span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure></li><li>slave客户端发送命令设置密码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth &lt;password&gt;</span><br></pre></td></tr></table></figure></li><li>slave配置文件设置密码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></li><li>启动客户端设置密码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a &lt;password&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p><img src="https://i.loli.net/2020/06/01/U4ShNtHmXn3YZrM.png" alt="Redis主从复制数据同步阶段.png"></p><ol><li>[slave]请求同步数据</li><li>[master]创建RDB同步数据</li><li>[slave]恢复RDB同步数据</li><li>[slave]请求部分同步数据</li><li>[slave]恢复部分同步数据</li><li>至此数据同步工作完成</li><li>达到了以下状态<ol><li>slave：具有master端全部数据，包含RDB过程接受的数据</li><li>master：保存slave当前数据同步的位置</li><li>总体：master与slave之间完成了数据克隆</li></ol></li></ol><h4 id="同步阶段master说明"><a href="#同步阶段master说明" class="headerlink" title="同步阶段master说明"></a>同步阶段master说明</h4><ol><li>如果master数据量巨大，数据同步阶段应避免流量高峰期，避免造成master阻塞，影响业务正常执行</li><li>复制缓冲区大小设定不合理，会导致数据溢出，如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure></li><li>master单机内存占用主机内存的比例不应过大，建议使用50%<del>70%的内存，留下30%</del>50%的内存用于执行bgsave命令和创建复制缓冲区</li></ol><h4 id="同步阶段slave说明"><a href="#同步阶段slave说明" class="headerlink" title="同步阶段slave说明"></a>同步阶段slave说明</h4><ol><li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stable-data yes|no</span><br></pre></td></tr></table></figure></li><li>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</li><li>多个slave同时向master请求数据同步，master发送的RDB文件增多，如果master带宽不足，会对带宽造成巨大冲击，因此数据同步需要根据业务需求，适量错峰</li><li>slave过多时，建议调整拓扑结构，由一主多从从结构变成树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择</li></ol><h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><ul><li>当master数据库状态被修改时，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播</li><li>master将接收到的数据变更命令发送给slave，slave接受命令后执行命令</li></ul><h3 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h3><ul><li><p>命令传播阶段出现断网现象：</p><ul><li>网络闪断闪联  –&gt;  忽略</li><li>短时间网络中断  –&gt;  部分复制</li><li>长时间网络中断  –&gt;  全量复制</li></ul></li><li><p>部分复制的三个核心要素</p><ul><li>服务器的运行id(runid)<ul><li>概念：服务器运行Id，是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li><li>组成：运行id由40位字符组成，是一个随机的十六进制字符</li><li>作用：运行id被用于在服务器间进行传输，识别身份。如果想两次操作均同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li><li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行id发送给slave，slave保存此id，通过<code>info server</code>命令，可以查看节点的runid</li></ul></li><li>主服务器的复制积压缓冲区<ul><li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出(FIFO)的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区<ul><li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</li></ul></li><li>由来：每台服务器启动时，如果开启有AOF或被连接成位master节点，即创建复制缓冲区</li><li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set、select）</li><li>数据来源：当master接收到主客户端的指令时，除了将指令执行，还会将指令存储到缓冲区中</li><li>组成：偏移量和字节值</li><li>工作原理<ul><li>通过offset区分不同的slave当前数据传播的差异</li><li>master记录已发送的信息对应的offset</li><li>slave记录已接受的信息对应的offset</li></ul></li></ul></li><li>主从服务器的复制偏移量<ul><li>概念：一个数字，描述复制缓冲区中的指令字节位置</li><li>分类：<ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li><li>slave复制偏移量：记录slave接受master发送过来的指令字节对应的位置（一个）</li></ul></li><li>数据来源：<ul><li>master端：发送一次记录一次</li><li>slave端：接受一次记录一次</li></ul></li><li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</li></ul></li></ul></li></ul><h3 id="数据同步-命令传播阶段工作流程"><a href="#数据同步-命令传播阶段工作流程" class="headerlink" title="数据同步+命令传播阶段工作流程"></a>数据同步+命令传播阶段工作流程</h3><p><img src="https://i.loli.net/2020/06/01/aqjy9vknYB7rUxJ.png" alt="Redis数据同步完整流程.png"></p><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p>进入命令传播阶段，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</p><h4 id="master心跳任务"><a href="#master心跳任务" class="headerlink" title="master心跳任务"></a>master心跳任务</h4><ul><li>指令：<code>PING</code></li><li>周期：由<code>repl-ping-slave-period</code>决定，默认10秒</li><li>作用：判断slave是否在线</li><li>查询：<code>info replication</code> 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常<h4 id="slave心跳任务"><a href="#slave心跳任务" class="headerlink" title="slave心跳任务"></a>slave心跳任务</h4></li><li>指令：<code>REPLCONF ACK {offset}</code></li><li>周期：1秒</li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li>作用2：判断master是否在线</li></ul><h4 id="心跳阶段注意事项"><a href="#心跳阶段注意事项" class="headerlink" title="心跳阶段注意事项"></a>心跳阶段注意事项</h4><ul><li>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slave-to-write 2</span><br><span class="line">min-slave-max-lag 8</span><br></pre></td></tr></table></figure>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</li><li>slave数量由slave发送<code>REPLCONF ACK</code>命令做确认</li><li>slave延迟由slave发送<code>REPLCONF ACK</code>命令做确认</li></ul><h2 id="主从复制的完整工作流程图"><a href="#主从复制的完整工作流程图" class="headerlink" title="主从复制的完整工作流程图"></a>主从复制的完整工作流程图</h2><p><img src="https://i.loli.net/2020/06/01/u2P1MQC4YUJEk8N.png" alt="主从复制的完整工作流程.png"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="频繁的全量复制-1"><a href="#频繁的全量复制-1" class="headerlink" title="频繁的全量复制(1)"></a>频繁的全量复制(1)</h3><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作</p><ul><li>内部优化调整方案（redis自己操作的）<ul><li>master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave</li><li>在master关闭时执行命令<code>shutdown save</code>，进行RDB持久化，将runid与offset保存到RDB文件中<ul><li>repl-id repl-offset</li><li>通过redis-check-rdb命令可以查看该信息</li></ul></li><li>master重启后加载RDB文件，恢复数据，重启后RDB文件将保存的repl-id与repl-offset加载到内存中<ul><li>master_repl_id = repl  master_repl_offset = repl-offset</li><li>通过info命令可以查看该信息</li></ul></li></ul></li><li>作用：本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</li></ul><h3 id="频繁的全量复制-2"><a href="#频繁的全量复制-2" class="headerlink" title="频繁的全量复制(2)"></a>频繁的全量复制(2)</h3><ul><li>问题现象：网络环境不佳，出现网络中断，slave不提供服务</li><li>问题原因：复制缓冲区过小，断网后slave的offset越界，触发全量复制</li><li>最终结果：slave反复进行全量复制</li><li>解决方案：修复复制缓冲区大小</li><li>建议设置如下：<ul><li>测算从master到slave的重连平均时长second</li><li>获取master平均每秒产生写命令数据总量<code>write_size_per_second</code></li><li>最有复制缓冲区空间 = 2 * second * write_size_per_second</li></ul></li></ul><h3 id="频繁的网络中断-1"><a href="#频繁的网络中断-1" class="headerlink" title="频繁的网络中断(1)"></a>频繁的网络中断(1)</h3><ul><li>问题现象：master的CPU占用过高或slave频繁断开联系</li><li>问题原因：<ul><li>slave每1秒发送<code>REPLCONF ACK</code>命令到<code>master</code></li><li>当slave接到了慢查询时（<code>keys *</code>、<code>hgetall</code>等），会大量占用CPU性能</li><li>master每1秒调用复制定时函数<code>replicationCron()</code>，会对slave发现长时间没有进行响应</li></ul></li><li>最终结果：<ul><li>master各种资源（输出缓冲区、带宽、连接等）被严重占用</li></ul></li><li>解决方案：通过设置合理的超时时间，确认是否释放slave<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-timeout</span><br></pre></td></tr></table></figure>该参数定义了超时时间的阙值（默认60秒），超过该值，释放slave</li></ul><h3 id="频繁的网络中断-2"><a href="#频繁的网络中断-2" class="headerlink" title="频繁的网络中断(2)"></a>频繁的网络中断(2)</h3><ul><li>问题现象：slave与master连接断开</li><li>问题原因：<ul><li>master发送<code>ping</code>指令频度较低</li><li>master设定超时时间较短</li><li>ping指令在网络中存在丢包</li></ul></li><li>解决方案：提高<code>ping</code>指令发送的频度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-ping-slave-period</span><br></pre></td></tr></table></figure>超时时间<code>repl-time</code>的时间至少是<code>ping</code>指令频度的5到10倍，否则slave很容易判定超时</li></ul><h3 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h3><ul><li>问题现象：多个slave获取相同数据不同步</li><li>问题原因：网络信息不同步，数据发送有延迟</li><li>解决方案：<ul><li>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器要注意此现象</li><li>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stable-data yes|no</span><br></pre></td></tr></table></figure>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）</li></ul></li></ul><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>主从复制模式中，如果master宕机了，需要做以下操作：</p><ol><li>将宕机的master下线</li><li>找一个slave作为master</li><li>通知所有的slave连接新的master</li><li>启动新的master与slave</li></ol><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>哨兵是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master</p><p><img src="https://i.loli.net/2020/06/01/3MagA7w2GtNWklb.png" alt="image.png"></p><p>哨兵的作用：</p><ul><li>监控<ul><li>不断的检查master和slave是否正常运行</li><li>master存活检测、master与slave运行情况检测</li></ul></li><li>通知（提醒）：当被监控的服务器出现问题后，向其他（哨兵间、客户端）发送通知</li><li>自动故障转移：断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li></ul><p><strong>哨兵也是一台redis服务器，只是不提供数据服务，通常哨兵配置数量为单数</strong></p><h2 id="启动哨兵"><a href="#启动哨兵" class="headerlink" title="启动哨兵"></a>启动哨兵</h2><ul><li>配置一拖二的主从结构</li><li>配置三个哨兵（配置相同，端口不同）<ul><li>参看<code>sentinel.conf</code></li></ul></li><li>启动哨兵<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel-端口号.conf</span><br></pre></td></tr></table></figure></li><li>启动顺序<ol><li>启动master</li><li>启动slave</li><li>启动哨兵</li></ol></li></ul><h2 id="sentinel-conf"><a href="#sentinel-conf" class="headerlink" title="sentinel.conf"></a>sentinel.conf</h2><ul><li><p><code>port 26379</code>：哨兵对外的端口</p></li><li><p><code>dir /tmp</code>：哨兵的工作信息存储位置</p></li><li><p><code>sentinel monitor mymaster 127.0.0.1 6379 2</code></p><blockquote><p>设置哨兵监控的Master，其中mymaster是自己给master起的名字，可以自定义，后面使用的时候保持一致即可，最后面的2表示有多少个哨兵认为master挂了，就认定为挂了，一般设置(哨兵数量/2+1)</p></blockquote></li><li><p><code>sentinel down-after-milliseconds mymaster 30000</code></p><blockquote><p>master连接多长时间没响应就认为挂了</p></blockquote></li><li><p><code>sentinel parallel-syncs mymaster 1</code></p><blockquote><p>进行新的master切换的时候，一次有多少个slave来进行同步数据，这个值越小，对服务器性能压力越小，速度越慢，相反，这个值越大，对服务器性能压力就越大，与之对应的速度就越快</p></blockquote></li><li><p><code>sentinel failover-timeout mymaster 1800000</code></p><blockquote><p>在进行同步的时候，超过多长的时间算超时</p></blockquote></li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>用于同步各个节点的状态信息</p><ul><li>获取各个sentinel的状态（是否在线）</li><li>获取master的状态<ul><li>master属性<ul><li>runid</li><li>role：master</li></ul></li><li>各个slave的详细信息<ul><li>runid</li><li>role：slave</li><li>master_host、master_port</li><li>offset</li><li>…</li></ul></li></ul></li></ul><ol><li>sentinelA在启动的时候，会先连接master，建立CMD连接，获取master信息，并在master的配置里新增自己的信息</li><li>sentinelA在获取到master信息后，通过master信息得到master的slave信息，然后连接slave，获取slave信息</li><li>sentinelB启动时连接master，获取master信息，这时候发现master已经有sentinelA连接过的记录，便与sentinelA建立起一条pub/sub通道(发布订阅通道)，再连接master对应的slave</li><li>再有其他的sentinel启动连到master，一样执行的是sentinelB的步骤，就这样，每个sentinel都与其他的sentinel建立连接，形成一个小型组网</li></ol><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>多个sentinel中的其中一个向master和slave发送一条hello信息，确定是否在线，并将这个是否在线的结果发布到sentinel自己的组网里，通知其他sentinel这个结果</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><ol><li>当通知阶段中有一个sentinelA发送了hello信息给master，但是master没做反应，这时候这个sentinelA就认为这个master出现故障，便将这个master的状态标记为<code>sdown</code>(主观下线)，并将这个消息发布到sentinel的pub/sub的通道中，通知其他sentinel</li><li>其他sentinel街道sentinelA发布的消息，作为吃瓜群众赶紧也去发送hello信息给master，看看是不是真挂了。这时如果达到了<code>sentinel.conf</code>里配置的数量的sentinel认为master挂了，那所有的sentinel就都认为master是真挂了，便将这个master的状态标记为<code>odown</code>(客观下线)</li><li>出现<code>odown</code>之后，所有sentinel就开会讨论谁去做故障转移这件事，sentinel发起投票，确定谁去做故障转移</li><li>挑选出来做故障处理的sentinel要依照下面的规则挑选备选master<ol><li>在线的（排除掉下线的）</li><li>响应快的（排除掉响应慢的）</li><li>与原master沟通密切的（排除掉与原master断开时间久的）</li><li>有限原则<ol><li>优先级</li><li>offset</li><li>runid</li></ol></li></ol></li><li>挑选出备选master之后，便向新的master发送<code>slaveof no one</code>的指令，将它升级到master，然后再向其他slave发送<code>slaveof 新masterIP 端口</code>，让其他slave全部指向新master</li></ol><p><strong>原master重新上线之后，会变成slave去连接现在的master</strong></p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="现状问题"><a href="#现状问题" class="headerlink" title="现状问题"></a>现状问题</h2><ul><li>redis提供的服务OPS可以达到10w/秒，当前业务OPS已经达到20w/秒</li><li>内存单机容量达到256G，当前业务需求内存容量1T</li></ul><p><strong>这时候就需要集群来解决上面的问题了</strong></p><h2 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h2><p>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</p><p>集群作用：</p><ul><li>分散单台服务器的访问压力，实现负载均衡</li><li>分散单台服务器的存储压力，实现可扩展性</li><li>降低单台服务器宕机带来的业务灾难</li></ul><h2 id="集群的数据存储"><a href="#集群的数据存储" class="headerlink" title="集群的数据存储"></a>集群的数据存储</h2><ul><li>通过算法设计，计算出key应该保存的位置<ul><li>通过<code>CRC16(key)</code>得到一个数值，然后与<code>16384</code>取模，得到这个key最终应该保存的位置</li></ul></li><li>也就是说将所有的存储空间计划切割成16384份，每台主机保存一部分<ul><li>每份代表的是一个存储空间，不是存储一个key的保存空间</li></ul></li><li>将key按照计算出的结果放到对应的存储空间</li><li>增强可扩展性</li></ul><h2 id="集群的内部通讯设计"><a href="#集群的内部通讯设计" class="headerlink" title="集群的内部通讯设计"></a>集群的内部通讯设计</h2><ul><li>各个数据库相互通信，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体位置</li></ul><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><ul><li>搭建一个三主三从的集群</li></ul><p>cluster配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line">cluster-node-timeout 100000</span><br></pre></td></tr></table></figure><p>大概的redis.conf配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize yes</span><br><span class="line">dir &#x2F;redis-all-in&#x2F;data</span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">save 10 2</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync always</span><br><span class="line">appendfilename appendonly-6379.aof</span><br><span class="line">databases 16</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line">cluster-node-timeout 10000</span><br></pre></td></tr></table></figure><p>启动命令（redis 5.0以后的启动方式）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p>输入上面命令之后redis会自动分配槽位置与主从节点，确定没问题之后输入<code>yes</code>即可自动创建cluster集群</p><p><code>--cluster-replicas</code>表示1个master连1个slave</p><h2 id="Cluster节点操作命令"><a href="#Cluster节点操作命令" class="headerlink" title="Cluster节点操作命令"></a>Cluster节点操作命令</h2><ul><li>查看集群节点信息：<code>cluster nodes</code></li><li>进入一个从节点，切换其主节点：<code>cluster replicate &lt;master-id&gt;</code></li><li>发现一个新节点，新增主节点：<code>cluster meet ip:port</code></li><li>忽略一个没有slot的节点：<code>cluster forget &lt;id&gt;</code></li><li>手动故障转移：<code>cluster failover</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#主从复制&quot;&gt;主从复制&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#简介&quot;&gt;简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#单机redis的风险与问题&quot;&gt;单机Redis的风险与问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#解决方案&quot;&gt;解
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.dimsum.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.dimsum.fun/tags/Redis/"/>
    
      <category term="NOSQL" scheme="http://www.dimsum.fun/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis进阶</title>
    <link href="http://www.dimsum.fun/2020/05/30/46.Redis2_document/"/>
    <id>http://www.dimsum.fun/2020/05/30/46.Redis2_document/</id>
    <published>2020-05-30T04:08:00.000Z</published>
    <updated>2020-06-01T10:59:44.327Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#net-core操作redis">.NET Core操作Redis</a></li><li><a href="#持久化">持久化</a><ul><li><a href="#持久化过程保存什么">持久化过程保存什么</a></li><li><a href="#rdb">RDB</a><ul><li><a href="#rdb持久化的配置">RDB持久化的配置</a></li><li><a href="#注意">注意</a></li><li><a href="#bgsave">bgsave</a></li><li><a href="#自动执行rdb">自动执行RDB</a></li><li><a href="#自动执行rdb注意">自动执行RDB注意</a></li><li><a href="#三种方案对比">三种方案对比</a></li><li><a href="#rdb特殊启动形式">RDB特殊启动形式</a></li><li><a href="#rdb优点">RDB优点</a></li><li><a href="#rdb缺点">RDB缺点</a></li></ul></li><li><a href="#aof">AOF</a><ul><li><a href="#rdb存储的弊端">RDB存储的弊端</a></li><li><a href="#解决思路">解决思路</a></li><li><a href="#概念">概念</a></li><li><a href="#aof写数据三种策略appendfsync">AOF写数据三种策略(appendfsync)</a></li><li><a href="#aof配置">AOF配置</a></li><li><a href="#aof重写">AOF重写</a><ul><li><a href="#aof重写作用">AOF重写作用</a></li><li><a href="#aof重写规则">AOF重写规则</a></li><li><a href="#aof重写方式">AOF重写方式</a></li><li><a href="#aof自动重写方式">AOF自动重写方式</a></li><li><a href="#aof非重写流程">AOF非重写流程</a></li><li><a href="#aof重写流程">AOF重写流程</a></li></ul></li></ul></li><li><a href="#rdb与aof区别">RDB与AOF区别</a></li><li><a href="#rdb与aof怎么选">RDB与AOF怎么选</a></li></ul></li><li><a href="#事务">事务</a><ul><li><a href="#简介">简介</a></li><li><a href="#基本操作">基本操作</a></li><li><a href="#事务的工作流程">事务的工作流程</a></li><li><a href="#事务的注意事项">事务的注意事项</a></li><li><a href="#锁----基于特定条件的事务执行">锁 – 基于特定条件的事务执行</a><ul><li><a href="#乐观锁">乐观锁</a><ul><li><a href="#业务分析">业务分析</a></li><li><a href="#解决方案">解决方案</a></li></ul></li><li><a href="#分布式锁">分布式锁</a><ul><li><a href="#业务分析-1">业务分析</a></li><li><a href="#解决方案-1">解决方案</a></li></ul></li><li><a href="#死锁">死锁</a><ul><li><a href="#业务分析-2">业务分析</a></li><li><a href="#解决方案-2">解决方案</a></li></ul></li></ul></li></ul></li><li><a href="#删除策略">删除策略</a><ul><li><a href="#redis中的数据特征">Redis中的数据特征</a></li><li><a href="#定时删除">定时删除</a></li><li><a href="#惰性删除">惰性删除</a></li><li><a href="#定期删除">定期删除</a></li><li><a href="#删除策略比对">删除策略比对</a></li><li><a href="#逐出算法">逐出算法</a><ul><li><a href="#新数据进入检测">新数据进入检测</a></li><li><a href="#影响数据逐出的相关设置">影响数据逐出的相关设置</a></li><li><a href="#数据逐出策略配置依据">数据逐出策略配置依据</a></li></ul></li></ul></li><li><a href="#redisconf">Redis.Conf</a><ul><li><a href="#服务器基础配置">服务器基础配置</a></li><li><a href="#日志配置">日志配置</a></li><li><a href="#客户端配置">客户端配置</a></li><li><a href="#多服务器快捷配置">多服务器快捷配置</a></li></ul></li><li><a href="#高级数据类型">高级数据类型</a><ul><li><a href="#bitmaps">Bitmaps</a></li><li><a href="#hyperloglog">HyperLogLog</a><ul><li><a href="#说明">说明</a></li></ul></li><li><a href="#geo">GEO</a><ul><li><a href="#基本操作-1">基本操作</a></li></ul></li></ul></li></ul><h1 id="NET-Core操作Redis"><a href="#NET-Core操作Redis" class="headerlink" title=".NET Core操作Redis"></a>.NET Core操作Redis</h1><p>创建控制台应用<code>RedisSample01</code>，通过<code>nuget</code>引入<code>CSRedisCore</code></p><p>具体示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">using CSRedis;</span><br><span class="line"></span><br><span class="line">namespace RedisSample01</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static async Task Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            var redis &#x3D; new CSRedisClient(&quot;127.0.0.1:6379,defaultDatabase&#x3D;0,prefix&#x3D;ds_&quot;);</span><br><span class="line">            RedisHelper.Initialization(redis);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;↓↓↓↓↓ String Sample ↓↓↓↓↓&quot;);</span><br><span class="line">            await RedisHelper.SetAsync(&quot;name&quot;, &quot;dimsum&quot;);</span><br><span class="line">            var name &#x3D; await RedisHelper.GetAsync&lt;string&gt;(&quot;name&quot;);</span><br><span class="line">            Console.WriteLine($&quot;name &#x3D; &#123;name&#125;&quot;);</span><br><span class="line">            Console.WriteLine(&quot;↑↑↑↑↑ Sample End ↑↑↑↑↑↑&quot;);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;↓↓↓↓↓ List Sample ↓↓↓↓↓&quot;);</span><br><span class="line">            await RedisHelper.DelAsync(&quot;list1&quot;);</span><br><span class="line">            await RedisHelper.LPushAsync(&quot;list1&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">            await RedisHelper.RPushAsync(&quot;list1&quot;, &quot;x&quot;);</span><br><span class="line"></span><br><span class="line">            var list1 &#x3D;await RedisHelper.LRangeAsync(&quot;list1&quot;, 0, -1);</span><br><span class="line">            Console.WriteLine($&quot;list1 &#x3D; &#123;String.Join(&#39;,&#39;,list1)&#125;&quot;);</span><br><span class="line">            var list1Length &#x3D; await redis.LLenAsync(&quot;list1&quot;);</span><br><span class="line">            Console.WriteLine($&quot;list1.length &#x3D; &#123;list1Length&#125;&quot;);</span><br><span class="line">            Console.WriteLine(&quot;↑↑↑↑↑ Sample End ↑↑↑↑↑↑&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;↓↓↓↓↓ Hash Sample ↓↓↓↓↓&quot;);</span><br><span class="line"></span><br><span class="line">            await RedisHelper.HSetAsync(&quot;hash1&quot;, &quot;name&quot;, &quot;张三&quot;);</span><br><span class="line">            await RedisHelper.HSetAsync(&quot;hash1&quot;, &quot;age&quot;, 19);</span><br><span class="line">            await RedisHelper.HSetAsync(&quot;hash1&quot;, &quot;job&quot;, &quot;C#&quot;);</span><br><span class="line"></span><br><span class="line">            var hash1 &#x3D; await RedisHelper.HGetAllAsync(&quot;hash1&quot;);</span><br><span class="line">            Console.WriteLine($&quot;hash1 &#x3D; &#123;string.Join(&#39;,&#39;, hash1.Select(x &#x3D;&gt; $&quot;&#123;x.Key&#125;:&#123;x.Value&#125;&quot;).ToArray())&#125;&quot;);</span><br><span class="line">            Console.WriteLine(&quot;↑↑↑↑↑ Sample End ↑↑↑↑↑↑&quot;);</span><br><span class="line">            </span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">            Console.WriteLine(&quot;Sample done&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><ul><li>持久化：利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制</li><li>为什么要持久化？防止数据的意外丢失，确保数据安全</li></ul><h2 id="持久化过程保存什么"><a href="#持久化过程保存什么" class="headerlink" title="持久化过程保存什么"></a>持久化过程保存什么</h2><ul><li>RDB：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据</li><li>AOF：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ul><li>操作命令：<code>save</code></li><li>作用：手动执行一次保存操作</li></ul><h3 id="RDB持久化的配置"><a href="#RDB持久化的配置" class="headerlink" title="RDB持久化的配置"></a>RDB持久化的配置</h3><p><strong>在配置文件中修改</strong></p><ul><li>dbfilename dump.rdb<ul><li>说明：设置本地数据库文件名，默认为<code>dump.rdb</code></li><li>经验：通常设置为<code>dump-端口号.rdb</code></li></ul></li><li>dir<ul><li>说明：设置存储<code>.rdb</code>文件的路径</li><li>经验：通常设置成存储空间较大的目录中，目录名称<code>data</code></li></ul></li><li>rdbcompression yes<ul><li>说明：设置存储至本地数据库时是否压缩数据，默认为<code>yes</code>，采用<code>LZF</code>压缩</li><li>经验：通常默认为开启状态，如果设置为<code>no</code>，可以节省CPU运行时间，但会使存储的文件变大(巨大)</li></ul></li><li>rdbchecksum yes<ul><li>说明：设置是否进行<code>RDB</code>文件格式校验，该校验过程在写文件和读文件过程均进行</li><li>经验：通常默认为开启状态，如果设置为no，可以节约读写行过程约10%时间消耗，但是存储一定的数据损坏风险</li></ul></li><li>stop-writes-on-bgsave-error yes<ul><li>说明：后台存储过程中如果出现错误现象，是否停止保存操作(这个配置项针对bgsave操作)</li><li>经验：通常默认为开启状态<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3></li></ul></li><li><em>save指令的执行会阻塞当前Redis服务器，知道当前RDB过程完成位置，有可能会造成长时间阻塞，线上环境不建议使用*</em><h3 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h3></li><li>操作命令：<code>bgsave</code></li><li>作用：手动启动后台保存操作，但不是立即执行</li></ul><p><strong>注意：bgsave命令是针对save阻塞问题做的优化，redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用</strong><br><img src="https://i.loli.net/2020/05/30/GMkazeWvx2iwmYp.png" alt="bgsave.png"></p><h3 id="自动执行RDB"><a href="#自动执行RDB" class="headerlink" title="自动执行RDB"></a>自动执行RDB</h3><ul><li>配置：<code>save second changes</code></li><li>作用：满足限定时间范围内key的变化数量达到指定数量，即进行持久化</li><li>参数：<ul><li>second：监控时间范围</li><li>changes：监控<code>key</code>的变化量</li></ul></li><li>位置：在conf文件中进行配置</li><li>示例：<ul><li><code>save 900 1</code> -&gt; 900秒内变化1个即触发RDB</li><li><code>save 300 10</code> -&gt; 300秒内变化10个即触发RDB</li><li><code>save 60 10000</code> -&gt; 60秒内变化10000个即触发RDB</li></ul></li><li>经验：一般监控时间大，变化时间小</li></ul><h3 id="自动执行RDB注意"><a href="#自动执行RDB注意" class="headerlink" title="自动执行RDB注意"></a>自动执行RDB注意</h3><ul><li><code>save</code>配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</li><li><code>save</code>配置中对于<code>second</code>与<code>changes</code>设置通常具有互补对应关系，尽量不要设置成包含行关系</li><li><code>save</code>配置启动后执行的是<code>bgsave</code>操作</li></ul><h3 id="三种方案对比"><a href="#三种方案对比" class="headerlink" title="三种方案对比"></a>三种方案对比</h3><table><thead><tr><th>方式</th><th>save指令</th><th>bgsave指令</th><th>save配置</th></tr></thead><tbody><tr><td>读写</td><td>同步</td><td>异步</td><td></td></tr><tr><td>阻塞客户端指令</td><td>是</td><td>否</td><td></td></tr><tr><td>额外内存消耗</td><td>否</td><td>是</td><td></td></tr><tr><td>启动新进程</td><td>否</td><td>是</td><td></td></tr></tbody></table><h3 id="RDB特殊启动形式"><a href="#RDB特殊启动形式" class="headerlink" title="RDB特殊启动形式"></a>RDB特殊启动形式</h3><ul><li>全量复制：（主从复制再说）</li><li>服务器运行过程中重启：<code>debug reload</code></li><li>关闭服务器时指定保存数据：<code>shutdown save</code></li></ul><h3 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a>RDB优点</h3><ul><li><code>RDB</code>是一个紧凑压缩的二进制文件，存储效率较高</li><li><code>RDB</code>内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li><li><code>RDB</code>恢复数据的速度要比<code>AOF</code>快很多</li><li>应用：服务器中每N小时执行<code>bgsave</code>备份，并将<code>RDB</code>文件拷贝到远程服务器中，用于灾难恢复</li></ul><h3 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a>RDB缺点</h3><ul><li><code>RDB</code>方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li><li><code>bgsave</code>指令每次运行要执行<code>fork</code>操作创建子进程，要牺牲掉一些性能</li><li><code>Redis</code>的众多版本中未进行<code>RDB</code>文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h3 id="RDB存储的弊端"><a href="#RDB存储的弊端" class="headerlink" title="RDB存储的弊端"></a>RDB存储的弊端</h3><ul><li>存储数据量较大，效率较低。基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</li><li>大数据量下的IO性能较低</li><li>基于<code>fork</code>创建子进程，内存产生额外消耗</li><li>宕机带来的数据丢失风险<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3></li><li>不写全数据，仅记录部分数据</li><li>改记录数据为记录操作过程</li><li>对所有数据操作均进行记录，排除丢失数据的风险</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>AOP(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行<code>AOF</code>文件中命令，以达到恢复数据的目的，与<code>RDB</code>相比可以简单描述为<strong>改记录数据为记录数据产生的过程</strong></li><li><code>AOF</code>的主要作用是解决了数据持久化的实时性，目前已经是<code>Redis</code>持久化的主流方式</li></ul><p><img src="https://i.loli.net/2020/05/30/795MA1npkrj46qC.png" alt="image.png"></p><h3 id="AOF写数据三种策略-appendfsync"><a href="#AOF写数据三种策略-appendfsync" class="headerlink" title="AOF写数据三种策略(appendfsync)"></a>AOF写数据三种策略(appendfsync)</h3><ul><li>always(每次)：每次写入操作均同步到<code>AOF</code>文件中，数据零误差，性能较差</li><li>everysec(每秒)：每秒将缓冲区的指令同步到<code>AOF</code>文件中，数据准确性较高，性能较高，在系统突然宕机的情况下丢失1秒内的数据。<strong>建议使用，也是默认配置项</strong></li><li>no(系统控制)：由操作系统控制每次同步到<code>AOF</code>文件的周期，整体过程不可控</li></ul><h3 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h3><ul><li>配置：<code>appendonly yes|no</code><ul><li>作用：是否开启<code>AOF</code>持久化功能，默认为不开启状态</li><li>经验：开启</li></ul></li><li>配置：<code>appendfsync always|everysec|no</code><ul><li>作用：<code>AOF</code>写数据策略</li><li>经验：<code>everysec</code></li></ul></li><li>配置：<code>appendfilename filename</code><ul><li>作用：<code>AOF</code>持久化文件名，默认文件名为<code>appendonly.aof</code></li><li>经验：建议配置为<code>appendonly-端口号.aof</code></li></ul></li><li>配置：<code>dir</code><ul><li>作用：<code>AOF</code>持久化文件保存路径</li><li>经验：与<code>RDB</code>持久化文件保持一致即可</li></ul></li></ul><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>随着命令不断写入<code>AOF</code>，文件会越来越大，为了解决这个问题，Redis引入了<code>AOF</code>重写机制压缩文件体积。<code>AOF</code>文件重写是将Redis进程内的数据转化为些命令同步到新<code>AOF</code>文件的过程。简单说就是将对同一个数据的若干条命令执行结果转化成最终结果数据对应的指令进行记录。</p><h4 id="AOF重写作用"><a href="#AOF重写作用" class="headerlink" title="AOF重写作用"></a>AOF重写作用</h4><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提升IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h4 id="AOF重写规则"><a href="#AOF重写规则" class="headerlink" title="AOF重写规则"></a>AOF重写规则</h4><ul><li>进程内已超时的数据不再写入文件</li><li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<ul><li>如：<code>del key1、hdel key2、srem key3、set key4 111、set key4 222</code></li></ul></li><li>对同一数据的多条写命令合并为同一条命令<ul><li>如：<code>push list1 a、lpush list1 b、lpush list1 c</code>可以转为：<code>lpush list1 a b c</code></li><li>为了防止数据量过大造成客户端缓冲区溢出，对<code>list</code>、<code>set</code>、<code>hash</code>、<code>zset</code>等类型，每条指令最多写入64个元素</li></ul></li></ul><h4 id="AOF重写方式"><a href="#AOF重写方式" class="headerlink" title="AOF重写方式"></a>AOF重写方式</h4><ul><li>手动重写：<code>bgrewriteaof</code></li><li>自动重写  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size</span><br><span class="line">auto-aof-rewrite-percentage percentage</span><br></pre></td></tr></table></figure></li></ul><h4 id="AOF自动重写方式"><a href="#AOF自动重写方式" class="headerlink" title="AOF自动重写方式"></a>AOF自动重写方式</h4><ul><li>自动重写触发条件设置  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size --自动AOF的重写尺寸(默认值比较大)</span><br><span class="line">auto-aof-rewrite-percentage percent  --自动重写的百分比</span><br></pre></td></tr></table></figure></li><li>自动重写触发对比参数（运行指令info persistence获取具体信息）  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size</span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure></li><li>自动重写触发条件  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size &gt; auto_aof_rewrite_min_size</span><br><span class="line">aof_current_size - aof_base_size &#x2F; aof_base_size &gt;&#x3D; auto-aof-rewrite-percentage</span><br></pre></td></tr></table></figure><h4 id="AOF非重写流程"><a href="#AOF非重写流程" class="headerlink" title="AOF非重写流程"></a>AOF非重写流程</h4><img src="https://i.loli.net/2020/05/31/Eb6D8x2mK5toUBn.png" alt="image.png"></li></ul><h4 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h4><p><img src="https://i.loli.net/2020/05/31/TCr4WfDitezAhSo.png" alt="image.png"></p><h2 id="RDB与AOF区别"><a href="#RDB与AOF区别" class="headerlink" title="RDB与AOF区别"></a>RDB与AOF区别</h2><table><thead><tr><th>持久方式</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>占用存储空间</td><td>小（数据级：压缩）</td><td>大（指令集：重写）</td></tr><tr><td>存储速度</td><td>慢</td><td>快</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>会丢失数据</td><td>依据策略决定</td></tr><tr><td>消耗资源</td><td>高/重量级</td><td>低/轻量级</td></tr><tr><td>启动优先级</td><td>低</td><td>高</td></tr></tbody></table><h2 id="RDB与AOF怎么选"><a href="#RDB与AOF怎么选" class="headerlink" title="RDB与AOF怎么选"></a>RDB与AOF怎么选</h2><ul><li>对数据非常敏感，建议使用默认的<code>AOF</code>持久化方案<ul><li><code>AOF</code>持久化策略使用<code>everysecond</code>，每秒钟<code>fsync</code>一次。该策略redis仍然可以保持很好的性能，当出现问题时，最多丢失0-1秒钟的数据</li><li>注意：<code>AOF</code>文件存储体积较大，且恢复速度较慢</li></ul></li><li>数据呈现具有有效性，建议使用<code>RDB</code>持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度快，阶段点数据恢复通常采用<code>RDB</code>方案</li><li>注意：利用<code>RDB</code>实现紧凑的数据持久化会使Redis性能降得很低</li></ul></li><li>综合比对<ul><li><code>RDB</code>与<code>AOF</code>的选择实际上是在做一种权衡，每种都有利弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用<code>AOF</code></li><li>如能承受数分钟以内的数据丢失，且追求大数据的恢复速度，选用<code>RDB</code></li><li>灾难恢复选用<code>AOF</code></li><li>双保险策略，同时开启<code>RDB</code>和<code>AOF</code>，重启后，Redis优先使用<code>AOF</code>来恢复数据，降低丢失数据的量</li></ul></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为什么要有事务：Redis执行指令过程中，多条连续执行的指令被干扰、打断、插队</p><p>Redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或干扰。</p><p>一个队伍中，一次性、顺序性、排他性的执行一系列命令</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>开启事务：<code>multi</code><ul><li>作用：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li></ul></li><li>执行事务：<code>exec</code><ul><li>作用：设定事务的结束位置，同时执行事务。与<code>multi</code>成对出现，成对使用</li></ul></li><li>取消事务：<code>discard</code><ul><li>作用：终止当前事务的定义，发生在<code>multi</code>之后，<code>exex</code>之前</li></ul></li></ul><p><strong>注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行<code>exec</code>命令才开始执行</strong></p><h2 id="事务的工作流程"><a href="#事务的工作流程" class="headerlink" title="事务的工作流程"></a>事务的工作流程</h2><p><img src="https://i.loli.net/2020/05/31/TkjoWPLJsxivF3h.png" alt="image.png"></p><h2 id="事务的注意事项"><a href="#事务的注意事项" class="headerlink" title="事务的注意事项"></a>事务的注意事项</h2><ul><li>定义事务的过程中，命令格式输入错误怎么办？<ul><li>语法错误：指命令书写格式有误</li><li>处理结果：如果定义的事务中所包含存在语法错误，整体事务中所有命令均不会执行，包括那些语法正确的命令</li></ul></li><li>定义事务的过程中，命令执行出现错误怎么办？<ul><li>运行错误：指命令格式正确，但是无法正确的执行，例如对<code>list</code>进行<code>incr</code>操作</li><li>处理结果：能够正确运行的命令会执行，运行错误的命令不会执行</li></ul></li></ul><p><strong>注意：已经执行的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚</strong></p><ul><li>手动进行事务回滚（无奈之举才用）<ul><li>记录操作过程中被影响的数据之前的状态<ul><li>单数据：<code>string</code></li><li>多数据：<code>hash</code>、<code>list</code>、<code>set</code>、<code>zset</code></li></ul></li><li>设置指令恢复所有的被修改的项<ul><li>单数据：直接<code>set</code>（注意周边属性，例如时效）</li><li>多数据：修改对应值或整体克隆复制</li></ul></li></ul></li></ul><h2 id="锁-–-基于特定条件的事务执行"><a href="#锁-–-基于特定条件的事务执行" class="headerlink" title="锁 – 基于特定条件的事务执行"></a>锁 – 基于特定条件的事务执行</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析</h4><ul><li>多个客户端都有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作</li><li>在操作之前锁定要操作的数据，一旦发生变化，终止当前操作<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4></li><li>对<code>key</code>添加监视锁，在执行<code>exec</code>前如果<code>key</code>发生了变化，终止事务执行：<code>watch key1 [key2...]</code></li><li>取消对所有<code>key</code>的监视：<code>unwatch</code></li><li><code>watch</code>命令在事务开启之前，然后在执行事务的<code>exec</code>的时候，会判断<code>watch</code>的值是否已经发生变化，如果没有则正常事务执行，如果发生了变化，则操作<code>watch</code>的命令失败</li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="业务分析-1"><a href="#业务分析-1" class="headerlink" title="业务分析"></a>业务分析</h4><ul><li>使用<code>watch</code>监控一个<code>key</code>有没有改变已经不能解决问题，此处要监控的是具体数据</li><li>虽然Redis是单线程，但是多个客户对同一个数据同时进行操作时，如何避免不被同时修改<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4></li><li>设置<code>setnx</code>设置一个公共锁：<code>setnx lock-key value</code><ul><li>利用<code>setnx</code>命令的返回值特征，有值则返回设置失败，无值则返回设置成功</li><li>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</li><li>对于返回设置失败的，不具有控制权，排队或等待</li><li>操作完毕通过<code>del</code>操作释放锁</li></ul></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="业务分析-2"><a href="#业务分析-2" class="headerlink" title="业务分析"></a>业务分析</h4><ul><li>由于锁操作由用户控制加锁解锁，必定会存在加所有未解锁的风险</li><li>需要解锁操作不能仅依赖用户控制，系统级别要能给出对应的保底处理方案<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4></li><li>使用<code>expire</code>为锁<code>key</code>添加时间限定，到时不释放锁，放弃锁  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire lock-key second</span><br><span class="line">pexpire lock-key milliseconds</span><br></pre></td></tr></table></figure></li><li>由于操作通常都是微妙或毫秒级，因此该锁定时间不宜设置过长，具体时间需要业务测试后确定<ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms</li><li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li><li>锁时间设定推荐：<code>最大耗时*120% + 平均网络延迟*100%</code></li><li>如果业务最大耗时&lt;&lt;网络平均耗时，通常为2个数量级，取其中单个耗时较长即可</li></ul></li></ul><h1 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h1><h2 id="Redis中的数据特征"><a href="#Redis中的数据特征" class="headerlink" title="Redis中的数据特征"></a>Redis中的数据特征</h2><ul><li>Redis是一种内存及数据库，所有数据均存放在内存中，内存中的数据可以通过<code>TTL</code>指令获取其状态<ul><li>XX：具有时效性的数据</li><li>-1：永久有效的数据</li><li>-2：已经过期的数据 或 被删除的数据 或 未定义的数据</li></ul></li></ul><p>数据删除策略的目的：在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体Redis性能的下降，甚至引发服务器宕机或内存泄露</p><h2 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h2><p>创建一个定时器，当<code>key</code>设置由过期时间，且过期时间到达时，由定时器立即执行对键的删除操作</p><ul><li>优点：解决内存，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响Redis服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换存储空间（拿时间换空间）</li></ul><h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><p>数据到达过期时间，不做处理，等下次访问该数据时再进行删除，并返回不存在</p><ul><li>优点：节约CPU性能，发现必须删除的时候才删除</li><li>缺点：内存压力很大，出现长期占用内存的数据</li><li>总结：用存储空间换取处理器性能（拿空间换时间）</li></ul><h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><ul><li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p></li><li><p>每秒执行server.hz次<code>serverCron()-&gt;databaseCron()-&gt;activeExpireCycle()</code></p></li><li><p><code>activeExpireCycle()</code>对每个<code>expires[*]</code>逐一进行检测，每次执行250ms/server.hz</p></li><li><p>对某个<code>expires[*]</code>检测时，随机挑选W个key检测</p><ul><li>如果key超时，删除key</li><li>如果一轮中删除的key的数量 &gt; W*25%，则循环该过程</li><li>如果一轮中删除的key的数量 &lt;= W<em>25%，检查下一个`expires[</em>]`，db0-db15循环</li><li>W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</li></ul></li><li><p>参数<code>current_db</code>用来记录<code>activeExpireCycle()</code>进入那个<code>expires[*]</code>执行</p></li><li><p>周期性轮询Redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p></li><li><p>特点1：CPU性能占用设置由峰值，检测频度可自定义设置</p></li><li><p>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</p></li><li><p>总结：周期性抽查检查空间（随机抽查，重点抽查）</p></li></ul><h2 id="删除策略比对"><a href="#删除策略比对" class="headerlink" title="删除策略比对"></a>删除策略比对</h2><table><thead><tr><th>删除策略</th><th>特点1</th><th>特点2</th><th>总结</th></tr></thead><tbody><tr><td>定期删除</td><td>节约内存，无占用</td><td>部分时段占用CPU资源，频度高</td><td>拿时间换空间</td></tr><tr><td>惰性删除</td><td>内存占用严重</td><td>延时执行，CPU利用率高</td><td>拿空间换时间</td></tr><tr><td>定期删除</td><td>内存定期随机清理</td><td>每秒花费固定的CPU资源维护内存</td><td>随机抽查，重点抽查</td></tr></tbody></table><h2 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h2><h3 id="新数据进入检测"><a href="#新数据进入检测" class="headerlink" title="新数据进入检测"></a>新数据进入检测</h3><ul><li>当新数据进入Redis时，如果内存不足怎么办？<ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用<code>freeMemoryIfNeeded()</code>检测内存是否充足，如果内存不满足新加入数据的最低存储要求，Redis要临时删除一些数据为当前指令清除存储空间。清理数据的策略称为<strong>逐出算法</strong></li><li>注意：逐出算法的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息<h3 id="影响数据逐出的相关设置"><a href="#影响数据逐出的相关设置" class="headerlink" title="影响数据逐出的相关设置"></a>影响数据逐出的相关设置</h3></li></ul></li><li>最大可使用内存  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory</span><br></pre></td></tr></table></figure>  占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</li><li>每次选取待删除数据的个数  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples</span><br></pre></td></tr></table></figure>  选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</li><li>删除策略  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy</span><br></pre></td></tr></table></figure>  达到最大内存后的，对被挑选出来的数据进行删除的策略</li><li>检测易失数据（可能会过期的数据集<code>server.db[i].expires</code>）<ol><li><code>volatile-lru</code>：挑选最近最少使用的数据淘汰（推荐）</li><li><code>volatile-lfu</code>：挑选最近使用次数最少的数据淘汰</li><li><code>volatile-ttl</code>：挑选将要过期的数据淘汰</li><li><code>volatile-random</code>：任意选择数据淘汰</li></ol></li><li>检测全库数据（所有数据集<code>server.db[i].dict</code>)<ol><li><code>allkeys-lru</code>：挑选最近最少使用的数据淘汰</li><li><code>allkeys-lfu</code>：挑选最近使用次数最少的数据淘汰</li><li><code>allkeys-random</code>：任意选择数据淘汰</li></ol></li><li>不使用数据驱逐<ul><li><code>no-enviction</code>(不驱逐)：禁止驱逐数据(redis4.0中默认策略)，会引发错误OOM(Out Of Memory)</li></ul></li><li>配置方式  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><h3 id="数据逐出策略配置依据"><a href="#数据逐出策略配置依据" class="headerlink" title="数据逐出策略配置依据"></a>数据逐出策略配置依据</h3></li><li>使用<code>INFO</code>命令输出监控信息，查询缓存<code>hit</code>和<code>miss</code>的次数，根据业务需求调优Redis配置</li></ul><h1 id="Redis-Conf"><a href="#Redis-Conf" class="headerlink" title="Redis.Conf"></a>Redis.Conf</h1><h2 id="服务器基础配置"><a href="#服务器基础配置" class="headerlink" title="服务器基础配置"></a>服务器基础配置</h2><ul><li>设置服务器以守护进程的方式运行：<code>daemonize yes|no</code></li><li>绑定主机地址：<code>bind 127.0.0.1</code></li><li>设置服务器端口号：<code>port 6379</code></li><li>设置数据库数量：<code>databases 16</code></li></ul><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><ul><li>设置服务器以指定日志记录级别：<code>loglevel debug|verbose|notice|warning</code></li><li>日志记录文件名：<code>logfile 端口号.log</code></li></ul><p><strong>注意：日志级别开发期设置为<code>verbose</code>，生产环境中配置为<code>notice</code>，简化日志输出量，降低写日志IO的频度</strong></p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><ul><li>设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclient 0</span><br></pre></td></tr></table></figure></li><li>客户端限制等待最长时长，达到最大值后关闭连接，如需要关闭该功能，设置为0  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure><h2 id="多服务器快捷配置"><a href="#多服务器快捷配置" class="headerlink" title="多服务器快捷配置"></a>多服务器快捷配置</h2></li><li>导入并加载指定配置文件信息，用于快速创建Redis公共配置较多的Redis实例配置文件，便于维护  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &#x2F;path&#x2F;server-端口号.conf</span><br></pre></td></tr></table></figure></li></ul><h1 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><ul><li>获取指定key对应偏移量上的bit值  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure></li><li>设置指定key对应偏移量上的bit值，value只能时1或0  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure></li><li>对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bitop op destKey key1 [key2...]</span><br><span class="line">&#x2F;&#x2F; and：交</span><br><span class="line">&#x2F;&#x2F; or：并</span><br><span class="line">&#x2F;&#x2F; not：非</span><br><span class="line">&#x2F;&#x2F; xor：异或</span><br></pre></td></tr></table></figure></li><li>统计指定key中1的数量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure></li></ul><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><ul><li><p>基数：数据集去重后元素个数</p></li><li><p>HyperLogLog是用来做基数统计的，运用了LogLog的算法</p></li><li><p>添加数据：<code>pfadd key element [element...]</code></p></li><li><p>统计数据：<code>pfcount key [key...]</code></p></li><li><p>合并数据：<code>pfmerge destKey sourceKey [sourceKey...]</code></p></li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>只用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数量</li><li>核心是基数估计算法，最终数值存在一定误差</li><li>误差范围：基数估计的结果是一个带有0.81%标准错误的近似值</li><li>耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数</li><li><code>pfadd</code>命令不是一次性分配12K内存使用，会随着基数的增加内存主键增大</li><li><code>pfmerge</code>命令合并后占用的存储空间为12K，无论合并之前数据量多大</li></ul><h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><ul><li>存放地理位置的数据类型<h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3></li><li>添加坐标点：<code>geoadd key longitude latitude member [longitude latitude member...]</code></li><li>获取坐标点：<code>geopos key member [member...]</code></li><li>计算坐标点距离：<code>getdist key member1 member2 [unit]</code>(unit是单位，<code>m=米 km=千米</code>)</li><li>根据坐标求范围内的数据  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadius key longitude latitude redius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li><li>根据点求范围内的数据  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li><li>获取指定点对应的坐标hash值  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key member [member...]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#net-core操作redis&quot;&gt;.NET Core操作Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#持久化&quot;&gt;持久化&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#持久化过程保存什么&quot;&gt;持久化过程保存什么&lt;/a&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.dimsum.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.dimsum.fun/tags/Redis/"/>
    
      <category term="NOSQL" scheme="http://www.dimsum.fun/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="http://www.dimsum.fun/2020/05/29/45.Redis1_document/"/>
    <id>http://www.dimsum.fun/2020/05/29/45.Redis1_document/</id>
    <published>2020-05-29T02:19:00.000Z</published>
    <updated>2020-05-31T15:58:31.056Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#概念">概念</a><ul><li><a href="#简介">简介</a></li><li><a href="#特征">特征</a></li><li><a href="#应用">应用</a></li></ul></li><li><a href="#数据类型">数据类型</a><ul><li><a href="#string">string</a><ul><li><a href="#基本操作">基本操作</a></li><li><a href="#set与mset"><code>set</code>与<code>mset</code></a></li><li><a href="#扩展操作">扩展操作</a><ul><li><a href="#业务场景a">业务场景A</a></li><li><a href="#业务场景b">业务场景B</a></li><li><a href="#业务场景c">业务场景C</a></li></ul></li><li><a href="#key的设置约定">key的设置约定</a></li><li><a href="#注意事项">注意事项</a></li></ul></li><li><a href="#hash">hash</a><ul><li><a href="#基本操作-1">基本操作</a></li><li><a href="#扩展操作-1">扩展操作</a></li><li><a href="#注意事项-1">注意事项</a></li><li><a href="#应用场景">应用场景</a><ul><li><a href="#业务场景a-1">业务场景A</a></li><li><a href="#业务场景b-1">业务场景B</a></li></ul></li><li><a href="#string存对象json和hash寸对象">string存对象(json)和hash寸对象</a></li></ul></li><li><a href="#list">list</a><ul><li><a href="#基础操作">基础操作</a></li><li><a href="#扩展操作-2">扩展操作</a></li><li><a href="#应用场景-1">应用场景</a><ul><li><a href="#业务场景a-2">业务场景A</a></li></ul></li><li><a href="#注意事项-2">注意事项</a></li><li><a href="#比较典型的业务场景">比较典型的业务场景</a></li></ul></li><li><a href="#set">set</a><ul><li><a href="#基本操作-2">基本操作</a></li><li><a href="#扩展操作-3">扩展操作</a></li><li><a href="#应用场景-2">应用场景</a><ul><li><a href="#业务场景a-3">业务场景A</a></li><li><a href="#业务场景b-2">业务场景B</a></li><li><a href="#业务场景c-1">业务场景C</a></li><li><a href="#业务场景d">业务场景D</a></li><li><a href="#业务场景e">业务场景E</a></li></ul></li><li><a href="#注意事项-3">注意事项</a></li></ul></li><li><a href="#sorted_set">sorted_set</a><ul><li><a href="#基础操作-1">基础操作</a></li><li><a href="#应用场景-3">应用场景</a><ul><li><a href="#业务场景a-4">业务场景A</a></li><li><a href="#业务场景b-3">业务场景B</a></li><li><a href="#业务场景c-2">业务场景C</a></li></ul></li><li><a href="#注意事项-4">注意事项</a></li></ul></li></ul></li><li><a href="#实践案例">实践案例</a><ul><li><a href="#业务场景a-5">业务场景A</a></li><li><a href="#业务场景b-4">业务场景B</a></li></ul></li><li><a href="#key通用操作">key通用操作</a><ul><li><a href="#key基本操作">key基本操作</a></li><li><a href="#key的时效性控制">key的时效性控制</a></li><li><a href="#key的查询模式">key的查询模式</a></li><li><a href="#key的其他操作">key的其他操作</a></li></ul></li><li><a href="#数据库通用操作">数据库通用操作</a><ul><li><a href="#key的重复问题">key的重复问题</a></li><li><a href="#基本操作-3">基本操作</a></li><li><a href="#其他操作">其他操作</a></li></ul></li></ul><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis：Remote Dictionary Server，使用C语言开发的一个开源的高性能键值对(key-value)数据库</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ol><li>数据间没有必然的关联关系</li><li>内部采用单线程机制进行工作</li><li>高性能。官方提供测试数据，50个并发执行100000个请求，读的速度是110000次/秒，写的速度是81000次/秒</li><li>多数据类型支持<ol><li>字符串类型  <code>string</code></li><li>列表类型 <code>list</code></li><li>散列类型 <code>hash</code></li><li>集合类型 <code>set</code></li><li>有序集合类型 <code>sorted_set</code></li></ol></li><li>持久化支持，可以进行数据灾难恢复</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>为热点数据加速查询(主要场景)，如热点商品、热点新闻、热点资讯、推广类高访问量信息等</li><li>任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询，如排行榜、各类网站访问统计、公交到站信息、在线人数信息、设备信号等</li><li>分布式数据共享，如分布式集群架构中的session分离</li><li>消息队列</li><li>分布式锁</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul><li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li><li>存储数据的格式：一个存储空间保存一个数据</li><li>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3></li><li>添加/修改数据：<code>set key value</code></li><li>获取数据：<code>get key</code></li><li>删除数据：<code>del key</code></li><li>添加/修改多个数据：<code>mset key1 value1 key2 value2 ...</code></li><li>获取多个数据：<code>mge key1 key2 ...</code></li><li>获取数据字符串个数(字符串长度)：<code>strlen key</code></li><li>追加信息到原始信息候补(如果原始信息存在就追加，否则新建)：<code>append key value</code></li></ul><h3 id="set与mset"><a href="#set与mset" class="headerlink" title="set与mset"></a><code>set</code>与<code>mset</code></h3><p>需要考虑以下几个点：</p><ul><li><code>set</code>是一条指令条操作一条数据，<code>mset</code>是一条指令操作多条记录。<strong>指令的传输和响应都需要耗时</strong></li><li>redis是单线程执行指令，在执行指令的时候需要耗时，如果<code>mset</code>包含的数据太多，<strong>会阻塞redis</strong></li><li>所以：一般少量数据两者影响不大，大量数据分割成合适的大小，再多次使用<code>mset</code>，这样能减少指令传输耗时和减少redis阻塞时间</li></ul><h3 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h3><h4 id="业务场景A"><a href="#业务场景A" class="headerlink" title="业务场景A"></a>业务场景A</h4><p>大型企业级应用中，分表操作时基本操作，使用多张表存储同类型数据，但是对应的主键id必须保证统一性，不能重复。Oracle数据库具有sequence设定，可以解决该问题，但是MySql数据库并不具有类似的机制，怎么解决？</p><p><strong>解决方案</strong></p><ul><li>设置数值数据增加指定范围的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br><span class="line">incrby key increment</span><br><span class="line">incrbyfloat ket increment</span><br></pre></td></tr></table></figure></li><li>设置数值数据减少指定范围的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decr key</span><br><span class="line">decr key increment</span><br></pre></td></tr></table></figure>string作为数值操作</li><li>string在redis内部存储默认就是一个字符串，当遇到增减类操作incr、decr时会转成数值型进行计算</li><li>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响</li><li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis数值上线范围，将报错</li></ul><hr><h4 id="业务场景B"><a href="#业务场景B" class="headerlink" title="业务场景B"></a>业务场景B</h4><p>活动海选投票，只能通过微信投票，每个微信号每4小时只能投1票。</p><p>电商商家开启热门商品推荐，热门商品不能一直处于热门期，每个商品热门期持续3天，3天后自动取消热门</p><p>新闻网站会出现热点新闻，热点新闻最大的特征就是时效性，如何自动控制热点新闻的时效性</p><p><strong>解决方案</strong></p><ul><li>设置数据具有指定的生命周期<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br><span class="line">psetex key milliseconds value</span><br></pre></td></tr></table></figure><strong>redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</strong></li></ul><hr><h4 id="业务场景C"><a href="#业务场景C" class="headerlink" title="业务场景C"></a>业务场景C</h4><p>主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数和微博数量</p><p><strong>解决方案</strong></p><ul><li>在redis中为大V用户设定用户信息，以用户主键和属性值为key，后台设定定时刷新策略即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg -&gt;  user:id:544935942:fans  -&gt; 120658</span><br><span class="line">eg -&gt;  user:id:544935942:blogs -&gt; 6164</span><br><span class="line">eg -&gt;  user:id:544935942:focuss -&gt; 100</span><br></pre></td></tr></table></figure></li><li>在redis中以json格式存储大V用户信息，定时刷新(也可以使用hash类型)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg -&gt; user:id:544935942 -&gt; &#123;id:544935942,name:张三,fans:120658,blogs:6164,focuss:100&#125;</span><br></pre></td></tr></table></figure></li><li><em>redis应用于各种结构性和非结构性高热度数据访问加速*</em></li></ul><h3 id="key的设置约定"><a href="#key的设置约定" class="headerlink" title="key的设置约定"></a>key的设置约定</h3><p>数据库中的热点数据key命名惯例，以<code>:</code>拼接</p><table><thead><tr><th></th><th>表名</th><th>主键名</th><th>主键值</th><th>字段名</th></tr></thead><tbody><tr><td>eg1：</td><td>order</td><td>id</td><td>20200415</td><td>name</td></tr><tr><td>eg2：</td><td>equip</td><td>id</td><td>82295157</td><td>type</td></tr><tr><td>eg3：</td><td>news</td><td>id</td><td>544935942</td><td>title</td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>数据操作不成功的反馈与数据正常操作之间的差异<ul><li>表示运行结果是否成功<ul><li>(integer)0 -&gt; false -&gt; 失败</li><li>(integer)1 -&gt; true  -&gt; 成功</li></ul></li><li>表示运行结果值<ul><li>(integer)3 -&gt; 表示3个</li><li>(integer)1 -&gt; 表示1个</li></ul></li></ul></li><li>数据未获取到<ul><li>(nill) -&gt; null</li></ul></li><li>数据最大存储量<ul><li>512MB</li></ul></li><li>数值计算有最大范围</li></ul><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><ul><li>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li><li>需要的存储结构：一个存储空间保存多个键值对数据</li><li>hash存储结构优化<ul><li>如果field数量较少，存储结构优化为类数组结构</li><li>如果field数量较多，存储结构使用HashMap结构</li></ul></li></ul><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>添加/修改单条数据：<code>hset key field value</code></li><li>获取指定field数据：<code>hget key field</code></li><li>获取全部field数据：<code>hgetall key</code></li><li>删除数据：<code>hdel key field1 field2 ...</code></li><li>添加/修改多条数据：<code>hmset key field1 value1 field2 value2 ...</code></li><li>获取多条数据：<code>hmget key field1 field2 ...</code></li><li>获取hash表中字段的数量：<code>hlen key</code></li><li>获取hash表中是否存在指定的字段：<code>hexists key field</code></li></ul><h3 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a>扩展操作</h3><ul><li>获取hash表中所有的字段或字段值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br><span class="line">hvals key</span><br></pre></td></tr></table></figure></li><li>设置指定字段的数值数据增加指定范围的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field increment</span><br><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3></li><li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象，如果数据未获取到，对应值为nil</li><li>每个hash可以存储2的32次方-1个键值对</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性，但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="业务场景A-1"><a href="#业务场景A-1" class="headerlink" title="业务场景A"></a>业务场景A</h4><p>电商网站购物车设计与实现</p><p>解决方案：</p><ul><li>仅分析购物车的redis存储模型：添加、浏览、更改数量、删除、清空<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用户Id -&gt; Key</span><br><span class="line">购物车商品Id&#x2F;SkuId -&gt; field</span><br><span class="line">购物车商品数量 -&gt; value</span><br><span class="line"></span><br><span class="line">添加商品 -&gt; hset</span><br><span class="line">修改数量 -&gt; hset&#x2F;hincrby</span><br><span class="line">删除商品 -&gt; hdel</span><br><span class="line">商品条目数 -&gt; hlen</span><br><span class="line">商品总数 -&gt; sum(hvals)</span><br><span class="line">浏览商品 -&gt; hgetall</span><br></pre></td></tr></table></figure><ul><li>按照上述的操作方式，可以发现redis中只存储了购物车的商品id和商品数量，并未存储商品信息，这样在查询整个购物车的时候，还需要二次查询商品信息，所以还需要做改进，可以将商品提取到单独一个hash中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; shoppingcart:product.info</span><br><span class="line">field -&gt; 商品Id:info</span><br><span class="line">value -&gt; 商品信息</span><br><span class="line"></span><br><span class="line">当用户添加商品到购物车的时候，通过 hsetnx key field value将商品存入shoppingcart:product.info，这样做可以避免重复添加商品到hash中</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="业务场景B-1"><a href="#业务场景B-1" class="headerlink" title="业务场景B"></a>业务场景B</h4><p>销售手机充值卡的商家对移动、联通、电信的30元、50元、100元的商品退出抢购活动，每种商品抢购上线1000长</p><p>解决方案：</p><ul><li>以商家id作为key</li><li>将参与抢购的商品id作为field</li><li>将参与抢购的商品数量作为对应的value</li><li>抢购时使用降值得方式控制产品数量</li></ul><h3 id="string存对象-json-和hash寸对象"><a href="#string存对象-json-和hash寸对象" class="headerlink" title="string存对象(json)和hash寸对象"></a>string存对象(json)和hash寸对象</h3><ul><li><code>string</code>存对象讲究整体性，一次性存一次性取，讲究读为主</li><li><code>hash</code>存对象，用<code>field</code>把属性隔离开，主要讲究得是更新操作比较有灵活性，讲究写为主</li><li>说通俗一点，当一个对象不需要频繁修改，只是存储之后查出来展示，那么用<code>string</code>来存是可以的，如果一个对象经常需要对各个属性进行修改，那么就使用<code>hash</code>，<code>hash</code>可以修改指定<code>field</code>的值</li></ul><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul><li>数据存储需求：存储多个数据，并对数据进行存储空间的顺粗进行区分</li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li><li>list类型：保存多个数据，底层使用双向链表存储结构实现</li></ul><p>顺序表（查询快，增删慢），链表（查询慢，增删快），双向链表<br><img src="https://i.loli.net/2020/05/29/Lz5AkwTo4bZPqOK.png" alt="顺序表-链表-双向链表.png"></p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>添加/修改数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpush key value1 value2 ...</span><br><span class="line">rpush key value1 value2 ...</span><br></pre></td></tr></table></figure></li><li>获取数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrange key start stop  (lrange key 0 -1 表示查询整个列表)</span><br><span class="line">lindex key index</span><br><span class="line">llen key</span><br></pre></td></tr></table></figure></li><li>获取并移除数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure></li></ul><h3 id="扩展操作-2"><a href="#扩展操作-2" class="headerlink" title="扩展操作"></a>扩展操作</h3><ul><li>规定时间内获取并移除数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop key1 key2 ... timeout</span><br><span class="line">brpop key1 key2 ... timeout</span><br></pre></td></tr></table></figure>就是当list没数据的时候，执行上面的命令会阻塞，等有其他客户端往上面监听的list添加数据，随后被取出，timeout为超时时间，单位为秒</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="业务场景A-2"><a href="#业务场景A-2" class="headerlink" title="业务场景A"></a>业务场景A</h4><p>微信朋友圈点赞，要求按点赞顺序显示点赞好友信息，如果取消点赞，则移除对应好友信息</p><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">朋友圈Id -&gt; key -&gt; 举例 -&gt; a01</span><br><span class="line">用户点赞 -&gt; rpush -&gt; 举例 -&gt; rpush a01 zhangsan lisi wangwu</span><br><span class="line">展示 -&gt; lrange key start stop -&gt; 举例 -&gt; lrang a01 0 -1</span><br><span class="line">取消点赞 -&gt; lrem key count value -&gt; 举例 -&gt; lrem a01 1 lisi</span><br></pre></td></tr></table></figure><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>list</code>中保存的数据都是string类型，数据总容量也是有限的，最多2的32次方-1个元素</li><li><code>list</code>具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</li><li>获取全部数据操作结束索引设置为-1</li><li>list可以对数据进行分页操作，通常第一页的信息来自list，第2页及更多的信息通过数据库的形式加载</li></ul><h3 id="比较典型的业务场景"><a href="#比较典型的业务场景" class="headerlink" title="比较典型的业务场景"></a>比较典型的业务场景</h3><ul><li>twitter、微博中个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面</li><li>新闻、资讯类网站将最新的新闻或咨询按照发生的时间顺序展示</li><li>企业运营过程中，系统将产出大量的运营数据，保障堕胎服务器操作日志的统一顺序输出</li></ul><p>上面的解决方案</p><ul><li>依赖list的数据具有顺序的特征对信息进行管理</li><li>使用栈模型解决最新消息的问题</li><li>使用队列模式解决多路信息汇总合并的问题</li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul><li>存储需求：存储大量的数据，在查询方便提供更高的效率</li><li>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</li><li>set类型：与hash存储结构完全相同，仅存储键，不存储值(nil)，并且值时不允许重复的</li></ul><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>添加数据：<code>sadd key member1 member2 ...</code></li><li>获取全部数据：<code>smembers key</code></li><li>删除数据：<code>srem key member1 member2 ...</code></li><li>获取集合数据总量：<code>scard key</code></li><li>判断集合中是否包含指定数据：<code>sismember key member</code></li><li>随机获取集合中指定数量的数据：<code>srandmember key [count]</code></li><li>随机获取集合中某个数据并将该数据移出集合：<code>spop key ...</code></li></ul><h3 id="扩展操作-3"><a href="#扩展操作-3" class="headerlink" title="扩展操作"></a>扩展操作</h3><ul><li>求两个集合的交、并、差集<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinter key1 key2</span><br><span class="line">sunion key1 key2</span><br><span class="line">sdiff key1 key2</span><br></pre></td></tr></table></figure></li><li>求两个集合的交、并、差集并存储到指定集合中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key1 key2</span><br><span class="line">sunionstore destination key1 key2</span><br><span class="line">sdiffstore destination key1 key2</span><br></pre></td></tr></table></figure></li><li>将指定数据从原始集合中移动到目标集合中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove source destination member</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2020/05/29/eD9fQSGItFLwso6.png" alt="交并差.png"></li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="业务场景A-3"><a href="#业务场景A-3" class="headerlink" title="业务场景A"></a>业务场景A</h4><p>每位用户首次使用今日头条会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户对其他信息类别主键产生兴趣，增加客户留存都，该如何实现？</p><p>业务分析</p><ul><li>系统分析出各个分类的最新或最热点信息条目并组织成set集合</li><li>随机挑选其中部分信息</li><li>配合用户关注信息分类中的热点信息组成展示的全信息集合</li></ul><p><strong>redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热点旅游线路，应用APP推荐，大V推荐等</strong></p><h4 id="业务场景B-2"><a href="#业务场景B-2" class="headerlink" title="业务场景B"></a>业务场景B</h4><p>脉脉之类的APP中共同好友的功能，这里通过两个set进行交并差集的运算可以满足需求</p><ul><li>redis应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</li><li>显示共同关注（交集）（一度）</li><li>显示共同好友（交集）（一度）</li><li>由用户A出发，获取到好友用户B的好友信息列表（一度）</li><li>由用户A出发，获取到好友用户B的购物清单列表（二度）</li><li>由用户A出发，获取到好友用户B的游戏充值列表（二度）</li></ul><h4 id="业务场景C-1"><a href="#业务场景C-1" class="headerlink" title="业务场景C"></a>业务场景C</h4><p>集团公司共具有12000名员工，内部OA系统中具有700多个角色，3000多个业务操作，23000多中数据，每个员工具有一个或多个角色，如何快速进行业务操作的权限校验？</p><p>解决思路：</p><ul><li>依赖<code>set</code>集合数据不重复的特征，依赖<code>set</code>集合<code>hash</code>存储结构特征完成数据过滤与快速查询</li><li>根据用户id获取用户所有角色</li><li>根据用户所有角色获取用户所有操作权限放入set集合</li><li>根据用户所有角色获取用户所有数据权限放入set集合</li></ul><h4 id="业务场景D"><a href="#业务场景D" class="headerlink" title="业务场景D"></a>业务场景D</h4><p>统计网站的PV、UV、IP</p><p>解决思路：</p><ul><li>利用<code>set</code>集合的数据去重特转增，记录各种访问数据</li><li>建立<code>string</code>类型数据，利用<code>incr</code>统计日访问量</li><li>建立<code>set</code>模型，记录不同cookie数量(UV)</li><li>建立<code>set</code>模型，记录不同IP数量(IP)</li></ul><h4 id="业务场景E"><a href="#业务场景E" class="headerlink" title="业务场景E"></a>业务场景E</h4><p>黑白名单</p><p>解决思路：</p><ul><li>基于经营战略设定问题用户发现、鉴别规则</li><li>周期性更新满足规则的用户黑名单，加入<code>set</code>集合</li><li>用户行为信息达到后于黑名单进行比对，确认行为去向</li><li>黑名单过滤IP地址：应用于开放游客访问权限的信息源</li><li>黑名单过滤设备信息：应用于限定访问设备的信息源</li><li>黑名单过滤用户：应用于基于访问权限的信息源</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>set</code>类型不允许数据重复，如果添加的数据在<code>set</code>中已经存在，将只保留一份</li><li><code>set</code>虽然于<code>hash</code>的存储结构相同，但是无法启用<code>hash</code>中存储值的空间</li></ul><h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted_set"></a>sorted_set</h2><ul><li>存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</li><li>需要的存储结构：新的存储模型，可以保存可排序的数据</li><li>sorted_set类型：在set的存储结构上添加可排序字段</li></ul><h3 id="基础操作-1"><a href="#基础操作-1" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>添加数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score1 member [score2 member] ...</span><br></pre></td></tr></table></figure></li><li>获取全部数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrang key start stop [WITHSCORES]</span><br><span class="line">zrevrange key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure></li><li>删除数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure></li><li>按条件获取数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT]</span><br><span class="line">zrevrangebyscore key max min [WITHSCORES]</span><br></pre></td></tr></table></figure></li><li>按条件删除数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start stop</span><br><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure></li><li>获取集合数据总量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br><span class="line">zcard key min max</span><br></pre></td></tr></table></figure></li><li>集合交、并操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...]</span><br><span class="line">zunionstore destination numkeys key [key ...]</span><br></pre></td></tr></table></figure></li><li>获取数据对应的索引(排名)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrank key memeber</span><br><span class="line">zrevrank key member</span><br></pre></td></tr></table></figure></li><li>score值获取与修改<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong></p><ul><li>min与max用于限定搜索查询的条件</li><li>start与stop用于限定查询访问，作用于索引，表示开始和结束索引</li><li>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li></ul><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="业务场景A-4"><a href="#业务场景A-4" class="headerlink" title="业务场景A"></a>业务场景A</h4><p>海选投票、各种TopN排行榜、聊天室活跃度统计、游戏好友亲密度</p><p>解决方案：通过获取索引</p><h4 id="业务场景B-3"><a href="#业务场景B-3" class="headerlink" title="业务场景B"></a>业务场景B</h4><p>体验VIP功能，当体验VIP到期后，如何有效管理此类信息，即便对于正式VIP用户也应该存在对应的管理方式。网站定期开启投票、讨论、限期进行，逾期作废，如何有效管理此类过期信息</p><p>解决方案：</p><ul><li>对基于时间线限定的任务处理，将处理时间记录为<code>score</code>值，利用顺序功能分区处理的先后顺序</li><li>记录下一个要处理的时间，当到期后处理对应任务，移除redis中的记录，并记录下一个要处理的时间</li><li>当新任务加入时，判断并更新当前下一个要处理的任务时间</li><li>为提升<code>sorted_set</code>的性能，通常将任务根据特征存储成若干个<code>sorted_set</code>，例如1小时内、1天内、周内、月内、季内、年内等，操作时逐级提升，将即将操作的若干任务纳入到1小时内处理的队伍中</li></ul><h4 id="业务场景C-2"><a href="#业务场景C-2" class="headerlink" title="业务场景C"></a>业务场景C</h4><p>任务/消息权重设定应用：当任务或消息待处理，形成了任务队列或消息队列时，对于高优先级的任务要保障对其优先处理</p><p>解决方案：</p><ul><li>对于带权重的任务，优先处理权重高的任务，采用score记录权重即可</li></ul><h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>score</code>保存的数据存储空间是64位</li><li><code>score</code>保存的数据也可以是个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时要慎重</li><li><code>sorted_set</code>底层存储还是基于<code>set</code>结构的，因此数据不能重复，如果重复添加相同的数据，<code>score</code>值将被反复覆盖，保留最后一次修改的结果</li></ul><h1 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h1><h2 id="业务场景A-5"><a href="#业务场景A-5" class="headerlink" title="业务场景A"></a>业务场景A</h2><p>人工智能领域的语义识别与自动对话将是未来服务业机器人应答呼叫体系中的重要技术，百度自研用户评价语义识别服务，免费开放给企业试用，同时训练百度自己的模型。现对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用</p><p>解决方案：</p><ul><li>设计计数器，记录调用次数，用于控制业务执行次数，以用户id作为key，使用次数为value</li><li>在调用前获取次数，判断是否超过限定次数<ul><li>不超过次数的情况下，每次调用技术+1</li><li>超过次数则业务调用失败，计数-1</li></ul></li><li>为计时器设置生命周期为指定周期，例如1秒/分钟，自动清空周期内使用次数</li></ul><p><img src="https://i.loli.net/2020/05/30/zdv5hkYgHXVOqjQ.png" alt="业务场景A.png"></p><p>解决方案改良：</p><ul><li>取消最大值的判断，利用incr操作超过最大值抛出异常的形式替代每次判断是否大于最大值</li><li>判断值是否为nil<ul><li>如果是，设置为数值的Max-次数</li><li>如果不是，计数+1</li><li>业务调用失败，计数-1</li></ul></li><li>遇到异常即+操作超过上限，视为使用达到上限</li></ul><p><img src="https://i.loli.net/2020/05/30/pfZFm7Vdt2iIroN.png" alt="业务场景A改良.png"></p><h2 id="业务场景B-4"><a href="#业务场景B-4" class="headerlink" title="业务场景B"></a>业务场景B</h2><p>使用微信的过程中，当微信接收消息后，会默认将最近接受的消息置顶，当多个好友及关注的订阅号同时发送消息时，该顺序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户里离线后，再次打开微信时，消息该按照什么样的顺序显示？</p><p>解决方案：</p><ul><li>依赖<code>list</code>的数据具有顺序的特征对消息进行管理，将<code>list</code>结构作为栈使用</li><li>对指定与普通会话分别创建独立的<code>list</code>分别管理</li><li>当某个<code>list</code>中接收到用户消息后，将消息发送方的<code>id</code>从<code>list</code>的一侧加入<code>list</code>(此处设定左侧)</li><li>多个<code>消息id</code>发出的消息反复入栈会出现问题，在入栈前无论是否具有当前<code>id</code>对应的消息，先删除对应<code>id</code></li><li>推送消息时先推送置顶会话<code>list</code>，再推送普通会话<code>list</code>，推送完成的<code>list</code>清除所有数据</li><li>消息的数量，也就是微信用户对话数量采用计数器的思路另行记录，伴随<code>list</code>操作同步更新</li></ul><h1 id="key通用操作"><a href="#key通用操作" class="headerlink" title="key通用操作"></a>key通用操作</h1><h2 id="key基本操作"><a href="#key基本操作" class="headerlink" title="key基本操作"></a>key基本操作</h2><ul><li>删除指定key：<code>del key</code></li><li>获取key是否存在：<code>exists key</code></li><li>获取key的类型：<code>type key</code></li></ul><h2 id="key的时效性控制"><a href="#key的时效性控制" class="headerlink" title="key的时效性控制"></a>key的时效性控制</h2><ul><li><p>为指定key设置有效期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line">expireat key timestamp</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br></pre></td></tr></table></figure></li><li><p>获取key的有效实践</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure></li><li><p>切换key从时效性转换为永久性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></table></figure><h2 id="key的查询模式"><a href="#key的查询模式" class="headerlink" title="key的查询模式"></a>key的查询模式</h2></li><li><p>查询key：<code>keys parttern</code>，查询模式规则：</p><ul><li><code>*</code>：匹配任意数量的任意符号</li><li><code>?</code>：匹配一个任意字符</li><li><code>[]</code>：匹配一个指定符号</li></ul><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keys * -&gt; 查询所有</span><br><span class="line">keys it* -&gt; 查询所有以it开头</span><br><span class="line">keys *save -&gt; 查询所有以save结尾</span><br><span class="line">keys ??user -&gt; 查询所有前面两个任意字符，后面以user结尾</span><br><span class="line">keys user:&quot; -&gt; 查询所有以user:开头，后面一个任意字符</span><br><span class="line">keys u[st]er:1 -&gt;查询所有以u开头，以er:1结尾，中间包含字符s或t</span><br></pre></td></tr></table></figure></li></ul><h2 id="key的其他操作"><a href="#key的其他操作" class="headerlink" title="key的其他操作"></a>key的其他操作</h2><ul><li>为key改名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br><span class="line">renamenx key newkey</span><br></pre></td></tr></table></figure></li><li>对所有key排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort</span><br></pre></td></tr></table></figure></li><li>其他key通用操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help @generic</span><br></pre></td></tr></table></figure></li></ul><h1 id="数据库通用操作"><a href="#数据库通用操作" class="headerlink" title="数据库通用操作"></a>数据库通用操作</h1><h2 id="key的重复问题"><a href="#key的重复问题" class="headerlink" title="key的重复问题"></a>key的重复问题</h2><ul><li>key是由程序员定义的</li><li>redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key</li><li>数据不区分种类、类别混在在一起，极易出现重复或冲突</li></ul><p>解决方案：</p><ul><li>redis为每个服务提供有16个数据库，编号从0到15</li><li>每个数据库之间的数据相互独立</li></ul><h2 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>切换数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select index</span><br></pre></td></tr></table></figure></li><li>其他操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">ping</span><br><span class="line">echo message</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><ul><li>数据移动<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure></li><li>数据清除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbsize --库里有多少个key</span><br><span class="line">flushdb  --清空当前数据库</span><br><span class="line">flushall --清空有数据库</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概念&quot;&gt;概念&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#简介&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#特征&quot;&gt;特征&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#应用&quot;&gt;应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.dimsum.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.dimsum.fun/tags/Redis/"/>
    
      <category term="NOSQL" scheme="http://www.dimsum.fun/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ进阶</title>
    <link href="http://www.dimsum.fun/2020/05/29/44.RabbitMq2_document/"/>
    <id>http://www.dimsum.fun/2020/05/29/44.RabbitMq2_document/</id>
    <published>2020-05-29T01:32:00.000Z</published>
    <updated>2020-05-31T15:58:31.056Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#消息是如何保障100的投递成功">消息是如何保障100%的投递成功</a><ul><li><a href="#生产端的可靠性投递">生产端的可靠性投递</a></li><li><a href="#具体解决方案">具体解决方案</a></li></ul></li><li><a href="#幂等性怎么避免重复消费">幂等性/怎么避免重复消费</a><ul><li><a href="#消费端-幂等性保障">消费端-幂等性保障</a></li><li><a href="#具体解决方案-1">具体解决方案</a></li></ul></li><li><a href="#confirm确认消息">Confirm确认消息</a><ul><li><a href="#代码示例">代码示例</a><ul><li><a href="#创建项目">创建项目</a></li><li><a href="#具体代码">具体代码</a></li></ul></li></ul></li><li><a href="#return返回消息">Return返回消息</a><ul><li><a href="#代码示例-1">代码示例</a><ul><li><a href="#创建项目-1">创建项目</a></li><li><a href="#具体代码-1">具体代码</a></li></ul></li></ul></li><li><a href="#自定义消费者">自定义消费者</a><ul><li><a href="#代码示例-2">代码示例</a><ul><li><a href="#创建项目-2">创建项目</a></li><li><a href="#具体代码-2">具体代码</a></li></ul></li></ul></li><li><a href="#消息的ack与重回队列">消息的ACK与重回队列</a><ul><li><a href="#消费端的手工ack和nack">消费端的手工ACK和NACK</a></li><li><a href="#消费端的重回队列">消费端的重回队列</a></li><li><a href="#代码示例-3">代码示例</a><ul><li><a href="#创建项目-3">创建项目</a></li><li><a href="#具体代码-3">具体代码</a></li></ul></li></ul></li></ul><blockquote><p>源码：<a href="https://github.com/xiejiamiao/AllSamples" target="_blank" rel="noopener">https://github.com/xiejiamiao/AllSamples</a></p></blockquote><h1 id="消息是如何保障100-的投递成功"><a href="#消息是如何保障100-的投递成功" class="headerlink" title="消息是如何保障100%的投递成功"></a>消息是如何保障100%的投递成功</h1><h2 id="生产端的可靠性投递"><a href="#生产端的可靠性投递" class="headerlink" title="生产端的可靠性投递"></a>生产端的可靠性投递</h2><ul><li><p>保障消息的成功发出</p></li><li><p>保障MQ节点的成功接受</p></li><li><p>发送端收到MQ节点(Broker)确认应答</p></li><li><p>完善的消息进行补偿机制</p><h2 id="具体解决方案"><a href="#具体解决方案" class="headerlink" title="具体解决方案"></a>具体解决方案</h2></li><li><p>消息落库，对消息状态进行达标。即在发送消息的时候将消息持久化到数据库中，然后进行状态维护</p><p><img src="https://i.loli.net/2020/05/27/JhjECxulDILTWQp.png" alt="消息落库.png"></p><p>缺陷：需要对消息做持久化，这样在遇到高并发的场景，数据库压力大</p></li><li><p>消息的延迟投递，做二次确认，回调检查</p><p><img src="https://i.loli.net/2020/05/27/go7lXc49nNjUPHi.png" alt="消息延迟投递.png"></p></li></ul><h1 id="幂等性-怎么避免重复消费"><a href="#幂等性-怎么避免重复消费" class="headerlink" title="幂等性/怎么避免重复消费"></a>幂等性/怎么避免重复消费</h1><p>幂等性：通俗的讲就是一个操作不管做多少次，结果永远都一样</p><h2 id="消费端-幂等性保障"><a href="#消费端-幂等性保障" class="headerlink" title="消费端-幂等性保障"></a>消费端-幂等性保障</h2><p>消费端实现幂等性，就意味着消费端永远不会消费多次，即使消费端收到多条一样的消息</p><h2 id="具体解决方案-1"><a href="#具体解决方案-1" class="headerlink" title="具体解决方案"></a>具体解决方案</h2><ul><li><p><code>唯一ID+指纹码</code>机制</p><ul><li>唯一ID+指纹码 机制，利用数据库主键去重</li><li>SELECT COUNT(1) FROM T_ORDER WHERE ID=(唯一ID+指纹码)</li><li>好处：实现简单</li><li>坏处：高并发下有数据库写入的性能瓶颈</li><li>解决方案：跟进ID进行分库分表进行算法路由</li></ul></li><li><p>利用Redis的原子性去实现</p><ul><li>数据是否需要进行数据落库，如果落库的话，关键解决的问题是数据库和缓存如何做到原子性</li><li>如果数据不落库，那么都存在缓存中，如何设置定时同步的策略</li></ul></li></ul><h1 id="Confirm确认消息"><a href="#Confirm确认消息" class="headerlink" title="Confirm确认消息"></a>Confirm确认消息</h1><ul><li>消息的确定，是指生产者投递消息后，如果Broker收到消息，则会给生产者一个应答</li><li>生产者进行接受应答，用来确定这条消息是否正常的发送给Broker，这种方法也是消息的可靠性投递的核心保障</li></ul><p><img src="https://i.loli.net/2020/05/27/y92nhMRg1b7sTJ6.png" alt="Confirm机制流程图.png"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>创建两个控制台应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ComfirmSample.Consumer</span><br><span class="line">ComfirmSample.Producer</span><br></pre></td></tr></table></figure><p>再分别通过nuget引入<code>RabbitMQ.Client</code></p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><p>ComfirmSample.Producer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace ComfirmSample.Producer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;****** Confirm Sample Producer ******&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 指定消息投递模式&#x3D;Confirm</span><br><span class="line">            channel.ConfirmSelect();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;test_confirm_exchange&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;confirm.save&quot;;</span><br><span class="line"></span><br><span class="line">            var message &#x3D; &quot;Hello RabbitMQ For Confirm Message&quot;;</span><br><span class="line">            var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">            channel.BasicPublish(exchangeName, routingKey, null, body);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 添加确认监听</span><br><span class="line">            channel.BasicAcks +&#x3D; (sender, ea) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine($&quot;消息确认被MQ收到  DeliveryTag&#x3D;&#123;ea.DeliveryTag&#125;&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">            &#x2F;&#x2F; no ack-ed</span><br><span class="line">            channel.BasicNacks +&#x3D; (sender, ea) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine($&quot;消息发送失败  DeliveryTag&#x3D;&#123;ea.DeliveryTag&#125;&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;消息发送完成&quot;);</span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComfirmSample.Consumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line"></span><br><span class="line">namespace ComfirmSample.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;****** Confirm Sample Consumer ******&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;test_confirm_exchange&quot;;</span><br><span class="line">            var queueName &#x3D; &quot;test_confirm_queue&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;confirm.save&quot;;</span><br><span class="line"></span><br><span class="line">            channel.ExchangeDeclare(exchangeName,ExchangeType.Direct,true,false,null);</span><br><span class="line">            channel.QueueDeclare(queueName, true, false, false, null);</span><br><span class="line">            channel.QueueBind(queueName, exchangeName, routingKey, null);</span><br><span class="line"></span><br><span class="line">            var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">            channel.BasicConsume(queueName, true, consumer);</span><br><span class="line">            consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                var body &#x3D; ea.Body;</span><br><span class="line">                var message &#x3D; Encoding.UTF8.GetString(body.ToArray());</span><br><span class="line">                Console.WriteLine($&quot;接收到消息：&#123;message&#125;&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Return返回消息"><a href="#Return返回消息" class="headerlink" title="Return返回消息"></a>Return返回消息</h1><ul><li>Return Listener用于处理一些不可路由的消息</li><li>消息生产者通过指定一个<code>Exchange</code>和<code>RoutingKey</code>，把消息送达到某一个队列中去，然后消息监听者监听队列，进行消费处理操作</li><li>但是在某些情况下，如果我们在发送消息的时候，当前的<code>Exchange</code>不存在或者指定的路由key路由不到，这个时候如果我们需要监听这种不可达的消息，就要使用Return Listener</li><li><strong>Mandatory</strong>：如果为true，则监听器会接受到路由不可达的消息，然后进行后续处理，如果为false，那么broker端会自动删除该消息</li></ul><p><img src="https://i.loli.net/2020/05/27/wZe1qY3NxDL2QjS.png" alt="image.png"></p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a>创建项目</h3><p>创建两个控制台应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReturnListenerSample.Consumer</span><br><span class="line">ReturnListenerSample.Producer</span><br></pre></td></tr></table></figure><p>再分别通过nuget引入<code>RabbitMQ.Client</code></p><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><p>ReturnListenerSample.Producer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace ReturnListenerSample.Producer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;****** Return Listener Producer ******&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;return_listener_exchange&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;order.save&quot;;</span><br><span class="line">            var routingKeyError &#x3D; &quot;abc.save&quot;;</span><br><span class="line"></span><br><span class="line">            var message &#x3D; &quot;Hello RabbitMQ For ReturnListener&quot;;</span><br><span class="line">            var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">            channel.BasicPublish(exchangeName,routingKey,mandatory:true,null,body);</span><br><span class="line">            channel.BasicPublish(exchangeName, routingKeyError, mandatory: true, null, body);</span><br><span class="line"></span><br><span class="line">            channel.BasicReturn +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;---------- 消息发送失败 ----------&quot;);</span><br><span class="line">                Console.WriteLine($&quot;ReplyCode &#x3D; &#123;ea.ReplyCode&#125;&quot;);</span><br><span class="line">                Console.WriteLine($&quot;ReplyText &#x3D;&#123;ea.ReplyText&#125;&quot;);</span><br><span class="line">                Console.WriteLine($&quot;Exchange &#x3D; &#123;ea.Exchange&#125;&quot;);</span><br><span class="line">                Console.WriteLine($&quot;RoutingKey &#x3D; &#123;ea.RoutingKey&#125;&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;消息发送完成&quot;);</span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReturnListenerSample.Consumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line"></span><br><span class="line">namespace ReturnListenerSample.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;****** Return Listener Consumer ******&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;return_listener_exchange&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;order.#&quot;;</span><br><span class="line">            var queueName &#x3D; &quot;return_listener_queue&quot;;</span><br><span class="line"></span><br><span class="line">            channel.ExchangeDeclare(exchangeName,ExchangeType.Topic,true,false,null);</span><br><span class="line">            channel.QueueDeclare(queueName, true, false, false, null);</span><br><span class="line">            channel.QueueBind(queueName,exchangeName,routingKey,null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">            channel.BasicConsume(queueName, true, consumer);</span><br><span class="line">            consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                var body &#x3D; ea.Body;</span><br><span class="line">                var message &#x3D; Encoding.UTF8.GetString(body.ToArray());</span><br><span class="line">                Console.WriteLine($&quot;接收到消息  &#123;message&#125;&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义消费者"><a href="#自定义消费者" class="headerlink" title="自定义消费者"></a>自定义消费者</h1><p>自定义Consumer在日常工作中更常用，主要就是继承<code>DefaultBasicConsumer</code>这个类，然后<code>override HandleBasicDeliver()</code>这个方法即可</p><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="创建项目-2"><a href="#创建项目-2" class="headerlink" title="创建项目"></a>创建项目</h3><p>创建两个控制台应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CustomerConsumer.Consumer</span><br><span class="line">CustomerConsumer.Producer</span><br></pre></td></tr></table></figure><p>再分别通过nuget引入<code>RabbitMQ.Client</code></p><p>在<code>CustomerConsumer.Consumer</code>中创建类<code>MyConsumer.cs</code></p><h3 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h3><p>CustomerConsumer.Producer.Program.cs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace CustomerConsumer.Producer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;****** Customer Consumer Producer ******&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;customer_consumer_exchange&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;customer.save&quot;;</span><br><span class="line"></span><br><span class="line">            var message &#x3D; &quot;Hello RabbitMQ For Customer_Consumer&quot;;</span><br><span class="line">            var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                channel.BasicPublish(exchangeName, routingKey, true, null, body);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;消息发送完成&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CustomerConsumer.Consumer.MyConsumer.cs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace CustomerConsumer.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    public class MyConsumer : DefaultBasicConsumer</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IModel _model;</span><br><span class="line"></span><br><span class="line">        public MyConsumer(IModel model):base(model)</span><br><span class="line">        &#123;</span><br><span class="line">            _model &#x3D; model;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey,</span><br><span class="line">            IBasicProperties properties, ReadOnlyMemory&lt;byte&gt; body)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;consumerTag &#x3D; &#123;consumerTag&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;deliveryTag &#x3D; &#123;deliveryTag&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;redelivered &#x3D; &#123;redelivered&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;exchange &#x3D; &#123;exchange&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;routingKey &#x3D; &#123;routingKey&#125;&quot;);</span><br><span class="line">            var message &#x3D; Encoding.UTF8.GetString(body.ToArray());</span><br><span class="line">            Console.WriteLine($&quot;Message &#x3D; &#123;message&#125;&quot;);</span><br><span class="line">            Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CustomerConsumer.Consumer.Program.cs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace CustomerConsumer.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;****** Customer Consumer Producer ******&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;customer_consumer_exchange&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;customer.#&quot;;</span><br><span class="line">            var queueName &#x3D; &quot;customer_consumer_queue&quot;;</span><br><span class="line"></span><br><span class="line">            channel.ExchangeDeclare(exchangeName,ExchangeType.Topic,true,false,null);</span><br><span class="line">            channel.QueueDeclare(queueName, true, false, false, null);</span><br><span class="line">            channel.QueueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">            channel.BasicConsume(queueName, true, new MyConsumer(channel));</span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息的限流"><a href="#消息的限流" class="headerlink" title="消息的限流"></a>消息的限流</h1><p>为什么需要消费端限流：当消费端处理能力达不到生产端的生产速度，或当Broker中囤积了巨量消息，当消费端启动之后，巨量消息同一时间全部推送到消费端，会直接导致消费端崩溃，</p><p> RabbitMQ提供了一种Qos(服务质量保证)功能，即在非自动确认消息的前提下，如果一定数目的消息(通过基于consumer或者channel设置Qos的值)未被确认之前，不进行消费新的消息</p><p> 主要操作方式就是调用<code>channel</code>上的<code>BasicQos</code>方法设置，其中参数意思如下：</p><ul><li><p>prefetchSize：表示单挑消息的最大限制，一般设置为0表示对单挑消息的体积大小不做限制</p></li><li><p>prefetchCount：表示Broker最多同时给一个消费者推送多少条消息，一旦有这么多条消息没有ack，则该consumer将block掉，知道有消息ack，Broker才会继续推消息</p></li><li><p>global：true/false，是否将上面的设置应用于channel，简单点说就是上面限制是channel级别还是consumer级别</p></li><li><p><em>注意：这里的设置一定是在调用channel.BasicConsume()的时候设置consumer的autoAck=false才有效，并且一般开发中都是将autoAck设置为false，然后在业务逻辑处理完之后再手动ack*</em></p></li></ul><h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="创建项目-3"><a href="#创建项目-3" class="headerlink" title="创建项目"></a>创建项目</h3><p> 创建两个控制台应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConsumerLimit.Consumer</span><br><span class="line">ConsumerLimit.Producer</span><br></pre></td></tr></table></figure><p>再分别通过nuget引入<code>RabbitMQ.Client</code></p><p>在<code>ConsumerLimit.Consumer</code>中创建类<code>MyConsumer.cs</code></p><h4 id="具体代码-3"><a href="#具体代码-3" class="headerlink" title="具体代码"></a>具体代码</h4><p>ConsumerLimit.Producer.Program</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace ConsumerLimit.Producer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;********** Consumer Limit Producer **********&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;consumer_limit_exchange&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;order.saved&quot;;</span><br><span class="line"></span><br><span class="line">            var random &#x3D; new Random();</span><br><span class="line">            for (var i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                var message &#x3D; $&quot;Hello RabbitMQ For Consumer Limit &#123;random.Next(1,100)&#125;&quot;;</span><br><span class="line">                var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">                channel.BasicPublish(exchangeName, routingKey, null, body);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;消息发送完成&quot;);</span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerLimit.Consumer.MyConsumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace ConsumerLimit.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    public class MyConsumer:DefaultBasicConsumer</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IModel _channel;</span><br><span class="line"></span><br><span class="line">        public MyConsumer(IModel channel):base(channel)</span><br><span class="line">        &#123;</span><br><span class="line">            _channel &#x3D; channel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey,</span><br><span class="line">            IBasicProperties properties, ReadOnlyMemory&lt;byte&gt; body)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;接收到消息：&#123;Encoding.UTF8.GetString(body.ToArray())&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;consumerTag &#x3D; &#123;consumerTag&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;deliveryTag &#x3D; &#123;deliveryTag&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;redelivered &#x3D; &#123;redelivered&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;exchange &#x3D; &#123;exchange&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;routingKey &#x3D; &#123;routingKey&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;正在模拟业务操作...&quot;);</span><br><span class="line">            Thread.Sleep(2000);</span><br><span class="line">            Console.WriteLine(&quot;业务处理完毕&quot;);</span><br><span class="line">            _channel.BasicAck(deliveryTag,false);</span><br><span class="line">            Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerLimit.Consumer.Program</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line"></span><br><span class="line">namespace ConsumerLimit.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;********** Consumer Limit Consumer **********&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;consumer_limit_exchange&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;order.#&quot;;</span><br><span class="line">            var queueName &#x3D; &quot;consumer_limit_queue&quot;;</span><br><span class="line"></span><br><span class="line">            channel.ExchangeDeclare(exchangeName, ExchangeType.Topic, true, false, null);</span><br><span class="line">            channel.QueueDeclare(queueName, true, false, false, null);</span><br><span class="line">            channel.QueueBind(queueName, exchangeName, routingKey, null);</span><br><span class="line"></span><br><span class="line">            channel.BasicConsume(queueName, false, new MyConsumer(channel));</span><br><span class="line">            channel.BasicQos(prefetchSize:0,prefetchCount:1,global:false);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息的ACK与重回队列"><a href="#消息的ACK与重回队列" class="headerlink" title="消息的ACK与重回队列"></a>消息的ACK与重回队列</h1><h2 id="消费端的手工ACK和NACK"><a href="#消费端的手工ACK和NACK" class="headerlink" title="消费端的手工ACK和NACK"></a>消费端的手工ACK和NACK</h2><ul><li>ACK=消息已经成功处理了</li><li>NACK=消息我处理失败了(Broker会进行重新投递)</li></ul><p>使用场景：</p><ul><li>消费端进行消费的时候，如果由于业务异常可以进行NACK，当尝试到足够的次数都一直处理失败，则返回记录日志后续做补偿，然后返回ACK</li><li>由于服务器宕机等严重问题，Broker即没收到ACK也没有收到NACK，那么Broker也会进行重新推送消息，这时如果处理完消息，返回ACK可以保障Broker知道消费端已经成功消费</li></ul><h2 id="消费端的重回队列"><a href="#消费端的重回队列" class="headerlink" title="消费端的重回队列"></a>消费端的重回队列</h2><ul><li>消费端重回队列是为了对没有处理成功的消息，把消息重新会递给Broker</li><li>一般在实际应用中，都会关闭重回队列，也就是设置为False</li></ul><h2 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="创建项目-4"><a href="#创建项目-4" class="headerlink" title="创建项目"></a>创建项目</h3><p> 创建两个控制台应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AckSample.Consumer</span><br><span class="line">AckSample.Producer</span><br></pre></td></tr></table></figure><p>再分别通过nuget引入<code>RabbitMQ.Client</code></p><p>在<code>AckSample.Consumer</code>中创建类<code>MyConsumer.cs</code></p><h3 id="具体代码-4"><a href="#具体代码-4" class="headerlink" title="具体代码"></a>具体代码</h3><p>AckSample.Producer.Program</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace AckSample.Producer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;********** ACK Sample Producer **********&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;ack_sample_exchange&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;order.saved&quot;;</span><br><span class="line"></span><br><span class="line">            var random &#x3D;new Random();</span><br><span class="line"></span><br><span class="line">            for (var i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                var properties &#x3D; channel.CreateBasicProperties();</span><br><span class="line">                properties.DeliveryMode &#x3D; 2;</span><br><span class="line">                properties.ContentEncoding &#x3D; &quot;UTF-8&quot;;</span><br><span class="line">                properties.Headers &#x3D; new Dictionary&lt;string, object&gt;() &#123;&#123;&quot;num&quot;, random.Next(0, 10).ToString()&#125;&#125;;</span><br><span class="line"></span><br><span class="line">                var message &#x3D; $&quot;Hello RabbitMQ For ACK  -&gt;  &#123;i&#125;&quot;;</span><br><span class="line">                var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">                channel.BasicPublish(exchangeName, routingKey, properties, body);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AckSample.Consumer.MyConsumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line">using Console &#x3D; System.Console;</span><br><span class="line"></span><br><span class="line">namespace AckSample.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    public class MyConsumer:DefaultBasicConsumer</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IModel _channel;</span><br><span class="line"></span><br><span class="line">        public MyConsumer(IModel channel):base(channel)</span><br><span class="line">        &#123;</span><br><span class="line">            _channel &#x3D; channel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey,</span><br><span class="line">            IBasicProperties properties, ReadOnlyMemory&lt;byte&gt; body)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">            var stringNum &#x3D; properties.Headers[&quot;num&quot;];</span><br><span class="line">            var byteNum &#x3D; stringNum as byte[];</span><br><span class="line">            Console.WriteLine($&quot;接收到消息  num&#x3D;&#123;Encoding.UTF8.GetString(byteNum)&#125;  &#123;Encoding.UTF8.GetString(body.ToArray())&#125;&quot;);</span><br><span class="line">            Console.WriteLine(&quot;......模拟业务操作......&quot;);</span><br><span class="line">            var num &#x3D; int.Parse(Encoding.UTF8.GetString(byteNum));</span><br><span class="line">            if (num % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;......业务处理失败......&quot;);</span><br><span class="line">                _channel.BasicNack(deliveryTag, false, true);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;......业务处理成功......&quot;);</span><br><span class="line">                _channel.BasicAck(deliveryTag,false);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Thread.Sleep(2000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AckSample.Consumer.Program</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace AckSample.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;********** ACK Sample Consumer **********&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;ack_sample_exchange&quot;;</span><br><span class="line">            var queueName &#x3D; &quot;ack_sample_queue&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;order.saved&quot;;</span><br><span class="line"></span><br><span class="line">            channel.ExchangeDeclare(exchangeName, ExchangeType.Topic, true, false, null);</span><br><span class="line">            channel.QueueDeclare(queueName, true, false, false, null);</span><br><span class="line">            channel.QueueBind(queueName,exchangeName,routingKey);</span><br><span class="line"></span><br><span class="line">            channel.BasicConsume(queueName, false, new MyConsumer(channel));</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TTL消息"><a href="#TTL消息" class="headerlink" title="TTL消息"></a>TTL消息</h1><p>主要就是两点，TTL可以针对消息本身也可以针对消息队列</p><p>消息本身通过消息的<code>Properties</code>中设置<code>Expiration</code>属性来设置过期时间</p><p>Queue通过声明的时候在<code>arguments</code>字典参数里添加<code>x-message-ttl</code>这个键值对来设置进入该消息队列的消息有效期</p><h1 id="DLX–死信队列-Dead-Letter-Exchange"><a href="#DLX–死信队列-Dead-Letter-Exchange" class="headerlink" title="DLX–死信队列(Dead-Letter-Exchange)"></a>DLX–死信队列(Dead-Letter-Exchange)</h1><p>利用DLX，当消息在一个队列变成死信(dead message)之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX</p><p>消息编程死信的情况：</p><ul><li>消息被拒绝(basic.reject/basic.nack)，并且requeue=false(不再重回队列)</li><li>消息TTL过期</li><li>队列达到最大长度</li></ul><p>死信队列</p><ul><li>DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在仍和的队列上被指定，实际上就是设置某个队列的属性</li><li>当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列</li><li>可以监听这个队列中消息做相应的处理，这个特性可以弥补RabbitMQ以前支持的immediate参数的功能</li></ul><p>死信队列设置：</p><ul><li>首先需要设置死信队列的exchange和queue，然后进行绑定<ul><li>Exchange：dlx.exchange</li><li>Queue：dlx.queue</li><li>RoutingKey：#</li></ul></li><li>然后进行正常声明交换机、队列、绑定，只不过需要在队列上的arguments字典上加一个键值对：<code>x-dead-letter-exchange:dlx.exchange</code></li></ul><h1 id="ASP-NET-Core做消费者"><a href="#ASP-NET-Core做消费者" class="headerlink" title="ASP.NET Core做消费者"></a>ASP.NET Core做消费者</h1><p>主要思路：创建一个<code>HostedService</code>服务类，继承<code>BackgroundService</code>，<code>override ExecuteAsync</code>方法，然后在里面做消息监听，最后在<code>Startup.ConfigureServices</code>中注册这个<code>HostedService</code></p><h2 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">using Microsoft.Extensions.Hosting;</span><br><span class="line">using Microsoft.Extensions.Logging;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line">using WebSiteConsumerSample.Consumers;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ReSharper disable UnusedMember.Global</span><br><span class="line">&#x2F;&#x2F; ReSharper disable InconsistentNaming</span><br><span class="line"></span><br><span class="line">namespace WebSiteConsumerSample.BackgroundServices</span><br><span class="line">&#123;</span><br><span class="line">    public class ConsumeRabbitMQHostedService : BackgroundService</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly ILogger&lt;ConsumeRabbitMQHostedService&gt; _logger;</span><br><span class="line">        private readonly ILogger&lt;SolutionMessageConsumer&gt; _consumerLogger;</span><br><span class="line">        private IConnection _connection;</span><br><span class="line">        private IModel _channel;</span><br><span class="line"></span><br><span class="line">        private string _exchangeName;</span><br><span class="line">        private string _queueName;</span><br><span class="line">        private string _routingKey;</span><br><span class="line"></span><br><span class="line">        public ConsumeRabbitMQHostedService(ILogger&lt;ConsumeRabbitMQHostedService&gt; logger,ILogger&lt;SolutionMessageConsumer&gt; consumerLogger)</span><br><span class="line">        &#123;</span><br><span class="line">            _logger &#x3D; logger;</span><br><span class="line">            _consumerLogger &#x3D; consumerLogger;</span><br><span class="line">            InitRabbitMq();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void InitRabbitMq()</span><br><span class="line">        &#123;</span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            _connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            _channel &#x3D; _connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;dimsum_solution_exchange&quot;;</span><br><span class="line">            var queueName &#x3D; &quot;dimsum_solution_queue&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;solution.#&quot;;</span><br><span class="line"></span><br><span class="line">            _exchangeName &#x3D; exchangeName;</span><br><span class="line">            _queueName &#x3D; queueName;</span><br><span class="line">            _routingKey &#x3D; routingKey;</span><br><span class="line"></span><br><span class="line">            _channel.ExchangeDeclare(exchangeName, ExchangeType.Topic, true, false, null);</span><br><span class="line">            _channel.QueueDeclare(queueName, true, false, false, null);</span><br><span class="line">            _channel.QueueBind(queueName, exchangeName, routingKey, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override async Task ExecuteAsync(CancellationToken stoppingToken)</span><br><span class="line">        &#123;</span><br><span class="line">            await Task.CompletedTask;</span><br><span class="line">            stoppingToken.ThrowIfCancellationRequested();</span><br><span class="line">            _channel.BasicConsume(_queueName, false, new SolutionMessageConsumer(_channel, _consumerLogger));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Dispose()</span><br><span class="line">        &#123;</span><br><span class="line">            _channel.Dispose();</span><br><span class="line">            _connection.Dispose();</span><br><span class="line">            base.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Startup.ConfigureServices</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddHostedService&lt;ConsumeRabbitMQHostedService&gt;();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#消息是如何保障100的投递成功&quot;&gt;消息是如何保障100%的投递成功&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#生产端的可靠性投递&quot;&gt;生产端的可靠性投递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#具体解决方案&quot;&gt;具体解决方案&lt;/a&gt;&lt;/l
      
    
    </summary>
    
    
      <category term="消息队列" scheme="http://www.dimsum.fun/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.dimsum.fun/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://www.dimsum.fun/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ基础</title>
    <link href="http://www.dimsum.fun/2020/05/26/43.RabbitMq1_document/"/>
    <id>http://www.dimsum.fun/2020/05/26/43.RabbitMq1_document/</id>
    <published>2020-05-26T14:36:00.000Z</published>
    <updated>2020-05-31T15:58:31.055Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#主流消息中间件">主流消息中间件</a><ul><li><a href="#activemq">ActiveMQ</a></li><li><a href="#kafka">Kafka</a></li><li><a href="#rocketmq">RocketMQ</a></li><li><a href="#rabbitmq">RabbitMQ</a></li></ul></li><li><a href="#rabbitmq核心概念及amqp协议">RabbitMQ核心概念及AMQP协议</a><ul><li><a href="#为什么用rabbitmq">为什么用RabbitMQ</a></li><li><a href="#rabbitmq高性能的原因">RabbitMQ高性能的原因</a></li><li><a href="#什么是amqp">什么是AMQP</a></li><li><a href="#amqp核心概念">AMQP核心概念</a></li><li><a href="#rabbitmq整体架构">RabbitMQ整体架构</a></li><li><a href="#rabbitmq消息流转">RabbitMQ消息流转</a></li></ul></li><li><a href="#rabbitmq常用命令">RabbitMQ常用命令</a><ul><li><a href="#rabbitmq-server">rabbitmq-server</a></li><li><a href="#rabbitmqctl">rabbitmqctl</a><ul><li><a href="#用户相关">用户相关</a></li><li><a href="#virtual-host相关">virtual host相关</a></li><li><a href="#queue相关">queue相关</a></li><li><a href="#高级操作">高级操作</a></li></ul></li><li><a href="#rabbitmq-plugins">rabbitmq-plugins</a></li></ul></li><li><a href="#消息生产与消费">消息生产与消费</a><ul><li><a href="#重要概念">重要概念</a></li><li><a href="#创建项目">创建项目</a></li><li><a href="#具体代码">具体代码</a></li><li><a href="#运行测试">运行测试</a></li></ul></li><li><a href="#exchange--交换机">Exchange–交换机</a><ul><li><a href="#exchange属性交换机属性">Exchange属性(交换机属性)</a></li><li><a href="#direct-exchange">Direct Exchange</a><ul><li><a href="#代码示例">代码示例</a><ul><li><a href="#创建项目-1">创建项目</a></li><li><a href="#具体代码-1">具体代码</a></li></ul></li></ul></li><li><a href="#topic-exchange">Topic Exchange</a><ul><li><a href="#代码示例-1">代码示例</a><ul><li><a href="#创建项目-2">创建项目</a></li><li><a href="#具体代码-2">具体代码</a></li></ul></li></ul></li><li><a href="#fanout-exchange">Fanout Exchange</a><ul><li><a href="#代码示例-2">代码示例</a><ul><li><a href="#创建项目-3">创建项目</a></li><li><a href="#具体代码-3">具体代码</a></li></ul></li></ul></li></ul></li><li><a href="#binding--绑定">Binding–绑定</a></li><li><a href="#queue--消息队列">Queue–消息队列</a></li><li><a href="#message--消息">Message–消息</a></li><li><a href="#virtual-hots--虚拟主机">Virtual Hots–虚拟主机</a></li></ul><blockquote><p>源码：<a href="https://github.com/xiejiamiao/AllSamples" target="_blank" rel="noopener">https://github.com/xiejiamiao/AllSamples</a></p></blockquote><h1 id="主流消息中间件"><a href="#主流消息中间件" class="headerlink" title="主流消息中间件"></a>主流消息中间件</h1><p><strong>衡量MQ指标：服务性能、数据存储、集群架构</strong></p><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><ul><li>ActiveMQ是Apache出品，最流行的、能力最强劲的开源消息总线，并且它是一个完全支持JMS规范的消息中间件</li><li>其丰富的API、多种集群构建模式使得它称为业界老牌消息中间件，在中小型企业中应用广泛</li><li>性能比较一般，面对大数量高并发的情况容易出现堵塞、消息堆积过多导致延迟</li><li>适合并发量不高的场景</li></ul><p>ActiveMQ的集群模式：<br><img src="https://i.loli.net/2020/05/27/UmneOgI2GSRY7Kp.png" alt="ActiveMQ集群模式.png"></p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量(配置不高的单机服务器也能支撑每秒100K的吞吐数据量)，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务</p><p>Kafka集群模式：<br><img src="https://i.loli.net/2020/05/27/K7ZvEM3S16XLDUr.png" alt="Kafka集群模式.png"></p><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>RocketMQ是阿里开源的消息中间件，目前也已经孵化为Apache顶级项目，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，它对消息的可靠传输和事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分布等场景</p><p>RocketMQ集群模式：<br><img src="https://i.loli.net/2020/05/27/SDQGuKW8sAz93RX.png" alt="RocketMQ集群模式.png"></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p><p>RabbitMQ高可用负载均衡集群模式：<br><img src="https://i.loli.net/2020/05/27/fGiY93JrbTU1xI7.png" alt="RbbitMQ高可用负载均衡集群.png"></p><h1 id="RabbitMQ核心概念及AMQP协议"><a href="#RabbitMQ核心概念及AMQP协议" class="headerlink" title="RabbitMQ核心概念及AMQP协议"></a>RabbitMQ核心概念及AMQP协议</h1><p><strong>RabbitMQ</strong>是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基于AMQP协议的。</p><h2 id="为什么用RabbitMQ"><a href="#为什么用RabbitMQ" class="headerlink" title="为什么用RabbitMQ"></a>为什么用RabbitMQ</h2><ul><li>与<code>SpringAMQP</code>完美的整合、API丰富</li><li>集群模式丰富，表达式配置，HA模式，镜像队列模型</li><li>保证数据不丢失的前提下做到高可靠性、可用性</li></ul><h2 id="RabbitMQ高性能的原因"><a href="#RabbitMQ高性能的原因" class="headerlink" title="RabbitMQ高性能的原因"></a>RabbitMQ高性能的原因</h2><p><strong>Erlang语言</strong>最初在于交换机领域的架构模式，这使得RabbitMQ在Broker之间进行数据交互的性能是非常优秀的</p><p><strong>Erlang</strong>的优点：有着与原生Socket一样的延迟</p><h2 id="什么是AMQP"><a href="#什么是AMQP" class="headerlink" title="什么是AMQP"></a>什么是AMQP</h2><ul><li>AMQP全称：Advance Message Queuing Protocol（高级消息队列协议）</li><li>AMQP定义：具有现代特征的二进制协议。是一个提供统一消息的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</li><li>AMQP协议模型：<br><img src="https://i.loli.net/2020/05/27/KPqzXyw2lYTxs3Q.png" alt="AMQP协议模型.png"></li></ul><h2 id="AMQP核心概念"><a href="#AMQP核心概念" class="headerlink" title="AMQP核心概念"></a>AMQP核心概念</h2><ul><li><strong>Server</strong>：又称Broker，接受客户端的连接，实现AMQP实体服务</li><li><strong>Connection</strong>：连接，应用程序域Broker的网络连接</li><li><strong>Channel</strong>：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个会话任务</li><li><strong>Message</strong>：消息，服务器和应用程序之间传送的数据，有<code>Properties</code>和<code>Body</code>组成，Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body则是消息体内容</li><li><strong>Virtual host</strong>：虚拟主机，用于进行逻辑隔离，最上层的消息路由。一个Virtual host里面可以有若干个Exchange和Queue，同一个Virtual host里面不能有相同名称的Exchange和Queue</li><li><strong>Exchange</strong>：交换机，接受消息，根据路由键转发消息到绑定的队列</li><li><strong>Binding</strong>：Exchange和Queue之间的虚拟连接，bingding中可以包含routing key</li><li><strong>Routing key</strong>：一个路由规则，虚拟机可用它来确定如何路由一个特定消息</li><li><strong>Queue</strong>：也成为Message Queue，消息队列，保存消息并将它们转发给消费者</li></ul><h2 id="RabbitMQ整体架构"><a href="#RabbitMQ整体架构" class="headerlink" title="RabbitMQ整体架构"></a>RabbitMQ整体架构</h2><p><img src="https://i.loli.net/2020/05/27/9o4DdunCB53hPyR.png" alt="RabbitMQ整体架构.png"></p><h2 id="RabbitMQ消息流转"><a href="#RabbitMQ消息流转" class="headerlink" title="RabbitMQ消息流转"></a>RabbitMQ消息流转</h2><p><img src="https://i.loli.net/2020/05/27/6DIpaO721zVJFQn.png" alt="RabbitMQ消息流转.png"></p><h1 id="RabbitMQ常用命令"><a href="#RabbitMQ常用命令" class="headerlink" title="RabbitMQ常用命令"></a>RabbitMQ常用命令</h1><h2 id="rabbitmq-server"><a href="#rabbitmq-server" class="headerlink" title="rabbitmq-server"></a>rabbitmq-server</h2><ul><li>启动并后台运行：<code>rabbitmq-server start &amp;</code></li><li>停止服务：<code>rabbitmq-server stop</code><h2 id="rabbitmqctl"><a href="#rabbitmqctl" class="headerlink" title="rabbitmqctl"></a>rabbitmqctl</h2></li><li>启动应用：<code>rabbitmqctl start_app</code></li><li>停止应用：<code>rabbitmqctl stop_app</code></li><li>节点状态：<code>rabbitmqctl status</code><h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3></li><li>添加用户：<code>rabbitmqctl add_user username password</code></li><li>列出所有用户：<code>rabbitmqctl list_users</code></li><li>删除用户：<code>rabbitmqctl delete_user username</code></li><li>清除用户权限：<code>rabbitmqctl clear_permissions -p vhostpath username</code></li><li>列出用户权限：<code>rabbitmqctl list_user_permissions username</code></li><li>修改密码：<code>rabbitmqctl change_password username newpassword</code></li><li>设置用户权限：<code>rabbitmqctl set_permissions -p vhostpath username &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code><h3 id="virtual-host相关"><a href="#virtual-host相关" class="headerlink" title="virtual host相关"></a>virtual host相关</h3></li><li>创建虚拟主机：<code>rabbitmqctl add_vhost vhostpath</code></li><li>列出所有虚拟主机：<code>rabbitmqctl list_vhosts</code></li><li>列出虚拟主机上所有权限：<code>rabbitmqctl list_permissions -p vhostpath</code></li><li>删除虚拟主机：<code>rabbitmqctl delete_vhost vhostpath</code><h3 id="queue相关"><a href="#queue相关" class="headerlink" title="queue相关"></a>queue相关</h3></li><li>查看所有队列信息：<code>rabbitmqctl list_queues</code></li><li>清楚队列里的消息：<code>rabbitmqctl -p vhostpath purge_queue blue</code><h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3></li><li>移除所有数据：<code>rabbitmqctl reset</code>(要在<code>rabbitmqctl stop_app</code>之后使用)</li><li>组成集群命令：<code>rabbitmqctl join_cluster &lt;clusternode&gt; [--ram]</code></li><li>查看集群状态：<code>rabbitmqctl cluster_status</code></li><li>修改集群节点的存储形式：<code>rabbitmqctl change_cluster_node_type disc | ram</code></li><li>忘记节点(摘除节点)：<code>rabbitmqctl forget_cluster_node [--offline]</code></li><li>修改节点名称：<code>rabbitmqctl rename_cluster_node oldnode1 newnode1 [oldnode2] [newnode2...]</code></li></ul><h2 id="rabbitmq-plugins"><a href="#rabbitmq-plugins" class="headerlink" title="rabbitmq-plugins"></a>rabbitmq-plugins</h2><ul><li>列出当前所有插件：<code>rabbitmq-plugins list</code></li><li>启动控制台：<code>rabbitmq-plugins enable rabbitmq_management</code></li></ul><h1 id="消息生产与消费"><a href="#消息生产与消费" class="headerlink" title="消息生产与消费"></a>消息生产与消费</h1><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><ul><li><code>ConnectionFactory</code>：获取连接工厂</li><li><code>Connection</code>：一个连接</li><li><code>Channel</code>：数据通信信道，可发送和接收消息</li><li><code>Queue</code>：具体的消息存储队列</li><li><code>Producer</code>：消息生产者</li><li><code>Consumer</code>：消息消费者</li></ul><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>创建两个控制台应用程序，名字分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BasicConsumer</span><br><span class="line">BasicProducer</span><br></pre></td></tr></table></figure><p>在两个项目分别通过nuget引入<code>RabbitMQ.Client</code></p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><p>BasicProducer.Program代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace BasicProducer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 1.创建一个ConnectionFactory</span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            &#x2F;&#x2F; 2.通过连接工厂创建连接</span><br><span class="line">            using (var connection &#x3D; connectionFactory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 3.通过connection创建Channel</span><br><span class="line">                var channel &#x3D; connection.CreateModel();</span><br><span class="line">                &#x2F;&#x2F; 4.通过channel发送数据</span><br><span class="line">                var message &#x3D; &quot;Hello RabbitMQ&quot;;</span><br><span class="line">                var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;test001&quot;, basicProperties: null, body: body);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;发送完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BasicConsumer.Program代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line"></span><br><span class="line">namespace BasicConsumer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 1.创建一个ConnectionFactory</span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;, </span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;, </span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            &#x2F;&#x2F; 2.通过连接工厂创建连接</span><br><span class="line">            using (var connection &#x3D; connectionFactory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 3.通过connection创建Channel</span><br><span class="line">                var channel &#x3D; connection.CreateModel();</span><br><span class="line">                &#x2F;&#x2F; 4.声明一个队列</span><br><span class="line">                var queue &#x3D; channel.QueueDeclare(queue: &quot;test001&quot;, durable: true, exclusive: false, autoDelete: true, arguments: null);</span><br><span class="line">                &#x2F;&#x2F; 5.创建消费者</span><br><span class="line">                var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">                &#x2F;&#x2F; 6.设置Channel</span><br><span class="line">                channel.BasicConsume(queue: &quot;test001&quot;, autoAck: true, consumer: consumer);</span><br><span class="line">                &#x2F;&#x2F; 7.获取消息</span><br><span class="line">                consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    var body &#x3D; ea.Body;</span><br><span class="line">                    var message &#x3D; Encoding.UTF8.GetString(body.ToArray());</span><br><span class="line">                    Console.WriteLine($&quot;接收到消息:&#123;message&#125;&quot;);</span><br><span class="line">                &#125;;</span><br><span class="line">                Console.WriteLine(&quot;输入回车键键退出&quot;);</span><br><span class="line">                Console.ReadLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p><strong>注意：先运行Consumer，再运行Producer</strong>，可以看到Consumer端接收到了Producer端发出的5条消息</p><h1 id="Exchange–交换机"><a href="#Exchange–交换机" class="headerlink" title="Exchange–交换机"></a>Exchange–交换机</h1><p>Exchange：接受消息，并根据路由键转发消息所绑定的队列<br><img src="https://i.loli.net/2020/05/27/fXumPnWEpoLehdy.png" alt="Exchange.png"></p><h2 id="Exchange属性-交换机属性"><a href="#Exchange属性-交换机属性" class="headerlink" title="Exchange属性(交换机属性)"></a>Exchange属性(交换机属性)</h2><ul><li>Name：交换机名字</li><li>Type：交换机类型 <code>direct</code>、<code>topic</code>、<code>fanout</code>、<code>headers</code></li><li>Durability：是否需要持久化，true为持久化</li><li>Auto Delete：当最后一个绑定到Exchange上的队列删除后，自动删除该Exchange</li><li>Internal：当前Exchange是否用于RabbitMQ内部使用，默认为false</li><li>Arguments：扩展参数，用于扩展AMQP协议自制定化使用</li></ul><h2 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h2><p>所有发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue</p><p><strong>注意：Direct模式可以使用RabbitMQ自带的Exchange:default Exchange，所以不需要将Exchange进行任何绑定(bingding)操作，消息传递时，RouteKey必须完全匹配才会被队列接受，否则该消息会被抛弃</strong></p><p><img src="https://i.loli.net/2020/05/27/bYIA27sadEDihwx.png" alt="Direct Exchange.png"></p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a>创建项目</h4><p>创建两个控制台应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DirectExchange.Consumer</span><br><span class="line">DirectExchange.Producer</span><br></pre></td></tr></table></figure><p>再分别通过nuget引入<code>RabbitMQ.Client</code></p><h4 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h4><p>DirectExchange.Producer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace DirectExchange.Producer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;**** Direct Exchange Producer Sample ****&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;,</span><br><span class="line">                AutomaticRecoveryEnabled &#x3D; true,</span><br><span class="line">                NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3)</span><br><span class="line">            &#125;;</span><br><span class="line">            using (var connection &#x3D; connectionFactory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (var channel &#x3D; connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    var exchangeName &#x3D; &quot;test_direct_exchange&quot;;</span><br><span class="line">                    var routingKey &#x3D; &quot;test.direct&quot;;</span><br><span class="line"></span><br><span class="line">                    var message &#x3D; &quot;Hello World RabbitMQ For Direct Exchange&quot;;</span><br><span class="line">                    var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">                    channel.BasicPublish(exchangeName, routingKey, null, body);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;消息发送完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DirectExchange.Consumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line"></span><br><span class="line">namespace DirectExchange.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;**** Direct Exchange Consumer Sample ****&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;,</span><br><span class="line">                AutomaticRecoveryEnabled &#x3D; true,</span><br><span class="line">                NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;test_direct_exchange&quot;;</span><br><span class="line">            var queueName &#x3D; &quot;test_direct_queue&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;test.direct&quot;;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 声明一个交换机</span><br><span class="line">            channel.ExchangeDeclare(exchange: exchangeName, type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);</span><br><span class="line">            &#x2F;&#x2F; 声明一个队列</span><br><span class="line">            channel.QueueDeclare(queue: queueName, durable: true, exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">            &#x2F;&#x2F; 建立一个绑定关系</span><br><span class="line">            channel.QueueBind(queue:queueName,exchange:exchangeName,routingKey:routingKey);</span><br><span class="line"></span><br><span class="line">            var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">            channel.BasicConsume(queue: queueName, autoAck: true, consumer);</span><br><span class="line">            consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                var body &#x3D; ea.Body;</span><br><span class="line">                var message &#x3D; Encoding.UTF8.GetString(body.ToArray());</span><br><span class="line">                Console.WriteLine($&quot;接收到消息：&#123;message&#125;&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;输入回车键退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h2><p>所有发送到Topic Exchange的消息都会被转发到所有关系RouteKey中指定Topic的Queue上</p><p>Exchange将RouteKey和某个Topic进行模糊匹配，此时队列需要绑定一个Topic</p><p><em>注意：可以使用通配符进行模糊匹配</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">符号&quot;#&quot;匹配一个或多个词</span><br><span class="line">符号&quot;*&quot;匹配不多不少一个词</span><br><span class="line">例如：&quot;log.#&quot; 能够匹配到 &quot;log.info.oa&quot;</span><br><span class="line">      &quot;log.*&quot; 只能够匹配到 &quot;log.error&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/27/J95AiKbfn4UutRa.png" alt="Topic Exchange.png"></p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="创建项目-2"><a href="#创建项目-2" class="headerlink" title="创建项目"></a>创建项目</h4><p>创建两个控制台应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TopicExchange.Consumer</span><br><span class="line">TopicExchange.Producer</span><br></pre></td></tr></table></figure><p>再分别通过nuget引入<code>RabbitMQ.Client</code></p><h4 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h4><p>TopicExchange.Producer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace TopicExchange.Producer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;**** Topic Exchange Producer Sample ****&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;,</span><br><span class="line">                AutomaticRecoveryEnabled &#x3D; true,</span><br><span class="line">                NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3)</span><br><span class="line">            &#125;;</span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;test_topic_exchange&quot;;</span><br><span class="line">            var routingKey1 &#x3D; &quot;user.save&quot;;</span><br><span class="line">            var routingKey2 &#x3D; &quot;user.update&quot;;</span><br><span class="line">            var routingKey3 &#x3D; &quot;user.delete.abc&quot;;</span><br><span class="line"></span><br><span class="line">            var message &#x3D; &quot;Hello World RabbitMQ For Topic Exchange Message&quot;;</span><br><span class="line">            var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">            channel.BasicPublish(exchange: exchangeName, routingKey: routingKey1, basicProperties: null, body);</span><br><span class="line">            channel.BasicPublish(exchange: exchangeName, routingKey: routingKey2, basicProperties: null, body);</span><br><span class="line">            channel.BasicPublish(exchange: exchangeName, routingKey: routingKey3, basicProperties: null, body);</span><br><span class="line">            </span><br><span class="line">            Console.WriteLine(&quot;消息发送完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TopicExchange.Consumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line"></span><br><span class="line">namespace TopicExchange.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;**** Topic Exchange Consumer Sample ****&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;,</span><br><span class="line">                AutomaticRecoveryEnabled &#x3D; true,</span><br><span class="line">                NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3)</span><br><span class="line">            &#125;;</span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;test_topic_exchange&quot;;</span><br><span class="line">            var queueName &#x3D; &quot;test_topic_queue&quot;;</span><br><span class="line">            var routingKey &#x3D; &quot;user.*&quot;;</span><br><span class="line">            &#x2F;&#x2F; 声明交换机</span><br><span class="line">            channel.ExchangeDeclare(exchange: exchangeName, type: ExchangeType.Topic, durable: true, autoDelete: false, arguments: null);</span><br><span class="line">            &#x2F;&#x2F; 声明队列</span><br><span class="line">            channel.QueueDeclare(queue: queueName, durable: false, exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">            &#x2F;&#x2F; 建立绑定关系</span><br><span class="line">            channel.QueueBind(queue: queueName, exchange: exchangeName, routingKey: routingKey);</span><br><span class="line"></span><br><span class="line">            var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">            channel.BasicConsume(queue: queueName, autoAck: true, consumer: consumer);</span><br><span class="line">            consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                var body &#x3D; ea.Body;</span><br><span class="line">                var message &#x3D; Encoding.UTF8.GetString(body.ToArray());</span><br><span class="line">                </span><br><span class="line">                Console.WriteLine($&quot;接收到消息：&#123;message&#125;   RoutingKey&#x3D;&#123;ea.RoutingKey&#125;&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h2><p>不处理路由键，只需要简单的队列绑定到交换机上，发送到交换机上的消息都会被转发到与该交换机绑定的所有队列上，<strong>Fanout交换机转发消息是最快的</strong></p><p><img src="https://i.loli.net/2020/05/27/VaGHXMh6YsboDJp.png" alt="Fanout Exchange.png"></p><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="创建项目-3"><a href="#创建项目-3" class="headerlink" title="创建项目"></a>创建项目</h4><p>创建两个控制台应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FanoutExchange.Consumer</span><br><span class="line">FanoutExchange.Producer</span><br></pre></td></tr></table></figure><p>再分别通过nuget引入<code>RabbitMQ.Client</code></p><h4 id="具体代码-3"><a href="#具体代码-3" class="headerlink" title="具体代码"></a>具体代码</h4><p>FanoutExchange.Producer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace FanoutExchange.Producer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;**** Fanout Exchange Producer Sample ****&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;,</span><br><span class="line">                AutomaticRecoveryEnabled &#x3D; true,</span><br><span class="line">                NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;test_fanout_exchange&quot;;</span><br><span class="line">            var message &#x3D; &quot;Hello World RabbitMQ For Fanout Exchange&quot;;</span><br><span class="line">            var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">            channel.BasicPublish(exchange: exchangeName, routingKey: &quot;&quot;, basicProperties: null, body: body);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;消息发送完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FanoutExchange.Consumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line"></span><br><span class="line">namespace FanoutExchange.Consumer</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;**** Fanout Exchange Consumer Sample ****&quot;);</span><br><span class="line"></span><br><span class="line">            var connectionFactory &#x3D; new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName &#x3D; &quot;127.0.0.1&quot;,</span><br><span class="line">                Port &#x3D; 5672,</span><br><span class="line">                UserName &#x3D; &quot;admin&quot;,</span><br><span class="line">                Password &#x3D; &quot;admin&quot;,</span><br><span class="line">                VirtualHost &#x3D; &quot;&#x2F;&quot;,</span><br><span class="line">                AutomaticRecoveryEnabled &#x3D; true,</span><br><span class="line">                NetworkRecoveryInterval &#x3D; TimeSpan.FromSeconds(3)</span><br><span class="line">            &#125;;</span><br><span class="line">            using var connection &#x3D; connectionFactory.CreateConnection();</span><br><span class="line">            using var channel &#x3D; connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            var exchangeName &#x3D; &quot;test_fanout_exchange&quot;;</span><br><span class="line">            var queueName &#x3D; &quot;test_fanout_queue&quot;;</span><br><span class="line">            &#x2F;&#x2F; 声明</span><br><span class="line">            channel.ExchangeDeclare(exchange: exchangeName, type: ExchangeType.Fanout, durable: true, autoDelete: false, arguments: null);</span><br><span class="line">            channel.QueueDeclare(queue: queueName, durable: true, exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">            channel.QueueBind(queue:queueName,exchange:exchangeName,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">            channel.BasicConsume(queue: queueName, autoAck: true, consumer);</span><br><span class="line">            consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                var body &#x3D; ea.Body;</span><br><span class="line">                var message &#x3D; Encoding.UTF8.GetString(body.ToArray());</span><br><span class="line">                Console.WriteLine($&quot;接收到消息：&#123;message&#125;&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">            Console.WriteLine(&quot;输入回车退出...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Binding–绑定"><a href="#Binding–绑定" class="headerlink" title="Binding–绑定"></a>Binding–绑定</h1><ul><li>Exchange和Exchange、Queue之间的连接关系</li><li>Binding中可以包含RoutingKey或参数</li></ul><h1 id="Queue–消息队列"><a href="#Queue–消息队列" class="headerlink" title="Queue–消息队列"></a>Queue–消息队列</h1><ul><li>消息队列，实际存储消息数据</li><li>Durability：是否持久化，Durable：是，Transient：否</li><li>Auto Delete：如果是yes，则代表当最后一个监听被移除之后，该queue会被自动删除</li></ul><h1 id="Message–消息"><a href="#Message–消息" class="headerlink" title="Message–消息"></a>Message–消息</h1><ul><li>服务器和应用程序之间传送的数据</li><li>本质上就是一段数据，由Properties和Payload(Body)组成</li><li>常用属性：delivery mode、headers（自定义属性）</li><li>content_type、content_encoding、priority(优先级)</li><li>correlation_id（消息唯一ID）、reply_to（消息处理失败了返回哪个队列）、expiration（消息过期时间，多久时间没被消费就过期）、message_id</li><li>timestamp、type、user_id、app_id、cluster_id</li></ul><h1 id="Virtual-Hots–虚拟主机"><a href="#Virtual-Hots–虚拟主机" class="headerlink" title="Virtual Hots–虚拟主机"></a>Virtual Hots–虚拟主机</h1><ul><li>虚拟地址，用于进行逻辑隔离，最上层的消息路由</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#主流消息中间件&quot;&gt;主流消息中间件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#activemq&quot;&gt;ActiveMQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#kafka&quot;&gt;Kafka&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#rock
      
    
    </summary>
    
    
      <category term="消息队列" scheme="http://www.dimsum.fun/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.dimsum.fun/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://www.dimsum.fun/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://www.dimsum.fun/2020/05/25/42.MultiThreading/"/>
    <id>http://www.dimsum.fun/2020/05/25/42.MultiThreading/</id>
    <published>2020-05-25T02:11:00.000Z</published>
    <updated>2020-05-27T16:57:02.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机概念"><a href="#计算机概念" class="headerlink" title="计算机概念"></a>计算机概念</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>程序在服务器运行时，占据的计算资源合计，称之为进程。进程之间不会相互干扰，但是进程间的通信比较困难（分布式）。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>程序执行的最小单位，相应操作的最小执行流，线程也包含自己的计算资源。线程是属于进程的，一个进程可以有多个线程。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一个进程里面，有多个线程并发执行</p><h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><h2 id="多线程Thread"><a href="#多线程Thread" class="headerlink" title="多线程Thread"></a>多线程Thread</h2><p><code>Thread</code>是一个类，就是一个封装，是.NET对线程对象的抽象封装，通过<code>Thread</code>去完成的操作，最终是通过像操作系统请求得到的执行流</p><ul><li><code>CurrentThread</code>：当前线程–任何操作执行都是线程完成的，即获得运行当前这句话的线程</li><li><code>ManagerThreadId</code>：是.NET平台给Thread起的名字，就是一个<code>int</code>值，尽量不重复</li></ul><hr><ul><li>同步单线程方法：按顺序执行，每次调用完成后才能进下一行，是同一个线程运行的</li><li>异步多线程方法：发起调用，不等待结果就直接进入下一行(主线程)，动作会由一个新线程来执行(子线程)</li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="界面卡顿"><a href="#界面卡顿" class="headerlink" title="界面卡顿"></a>界面卡顿</h2><ul><li>同步单线程方法卡界面 —- 主(UI)线程线程忙于计算，所以不能相应</li><li>异步多线程不卡界面 —- 计算任务交给子线程，主(UI)线程已经闲置，可以相应别的操作</li><li>多线程对于C/S：点击按钮后能不卡死，例如：上传文件界面不卡死</li><li>多线程对于B/S：例如：用户注册时同时发邮件/发短信/写日志<h2 id="执行速度"><a href="#执行速度" class="headerlink" title="执行速度"></a>执行速度</h2></li><li>同步单线程方法慢 —- 因为只有一个线程在计算</li><li>异步多线程方法快 —- 因为多个线程并发计算</li><li>多线程就是用资源换性能</li><li>但是两者的速度差不是线性增长，例如1个线程耗时1000毫秒，5个线程不代表能做到耗时200毫秒。说明多线程的协调管理由额外的成本，同时资源也是由上限的</li><li>所以：线程并不是越多越好<h2 id="无序性"><a href="#无序性" class="headerlink" title="无序性"></a>无序性</h2></li><li>启动无序：几乎同一时间向操作系统请求线程，因为线程时操作系统资源，CLR只能去申请，具体时什么顺序启动这个无法掌握</li><li>执行时间不确定：同个线程同个任务耗时都不一样，更何况多个任务多个线程。这跟操作系统的资源调度策略有关</li><li>结束无序：上面的都无序，结束时间怎么可能有序</li></ul><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>使用多线程时，千万不要通过延时等方式去掌控顺序</p><h1 id="多线程控制顺序"><a href="#多线程控制顺序" class="headerlink" title="多线程控制顺序"></a>多线程控制顺序</h1><h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><h2 id="死循环IsCompleted等待"><a href="#死循环IsCompleted等待" class="headerlink" title="死循环IsCompleted等待"></a>死循环IsCompleted等待</h2><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h2 id="EndInvoke获得返回值"><a href="#EndInvoke获得返回值" class="headerlink" title="EndInvoke获得返回值"></a>EndInvoke获得返回值</h2><h1 id="使用各个版本的多线程处理方式"><a href="#使用各个版本的多线程处理方式" class="headerlink" title="使用各个版本的多线程处理方式"></a>使用各个版本的多线程处理方式</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread的API特别丰富，可以玩的很花哨，但是其实大部分人都玩不好，因为线程资源是操作系统管理的，相应并部灵敏，所以没那么好控制</span></span><br><span class="line"><span class="comment">// Thread启动线程是没限制的，一个for循环启动几百万个线程，分分钟搞死服务器</span></span><br><span class="line">ThreadStart threadHandler = () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$"Thread Start。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>); </span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$"Thread End。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(threadHandler);</span><br><span class="line">thread.Start();</span><br></pre></td></tr></table></figure><h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPool：池化资源管理设计思想，线程是一种资源，以前要用到线程就去申请一个，使用完释放掉。</span></span><br><span class="line"><span class="comment">// 这样是一种浪费，池化就是一个容器，容器提前申请一批线程，程序需要使用线程，直接找容器获取，用完再放回容器(通过控制资源的状态)，避免频繁的申请和销毁，容器自己还会根据限制的数量去申请和释放</span></span><br><span class="line"><span class="comment">// 好处：1.线程服用，2.可以限制最大线程数量</span></span><br><span class="line"><span class="comment">// 缺点：ThreadPool的API太少了，线程等待顺序控制比较弱，影响了实战</span></span><br><span class="line">WaitCallback callback = o =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$"ThreadPool Start。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$"ThreadPool End。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">ThreadPool.QueueUserWorkItem(callback);</span><br></pre></td></tr></table></figure><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task:多线程最佳实践</span></span><br><span class="line"><span class="comment">// 优点：1.Task的线程券是线程池的线程  2.提供了丰富的API，非常适合开发实践</span></span><br><span class="line">Action action = () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$"Task Start。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$"Task End。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Task task = <span class="keyword">new</span> Task(action);</span><br><span class="line">task.Start();</span><br></pre></td></tr></table></figure><h2 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h2><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parallel：并行编程</span></span><br><span class="line"><span class="comment">// 可以同时执行多个操作，同时主线程也会参与计算，不会闲置。可以节约一个线程</span></span><br><span class="line"><span class="comment">// 可以通过ParallelOptions的MaxDegreeOfParallelism控制最大并发数量</span></span><br><span class="line">Parallel.Invoke(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Parallel 1 Start。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$"Parallel 1 End。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Parallel 2 Start。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$"Parallel 2 End。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Parallel 3 Start。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$"Parallel 3 End。。。<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="Task比较全面示例"><a href="#Task比较全面示例" class="headerlink" title="Task比较全面示例"></a>Task比较全面示例</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Coding</span>(<span class="params"><span class="keyword">string</span> dev, <span class="keyword">string</span> module</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">var</span> stopWatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">    stopWatch.Start();</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;dev&#125;</span>开发<span class="subst">&#123;module&#125;</span>模块 开始.......... ManagedThreadId=<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">    Thread.Sleep(random.Next(<span class="number">1000</span>, <span class="number">5000</span>));</span><br><span class="line">    stopWatch.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;dev&#125;</span>开发<span class="subst">&#123;module&#125;</span>模块 完成.......... ManagedThreadId=<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>   共耗时<span class="subst">&#123;stopWatch.ElapsedMilliseconds&#125;</span>毫秒"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AllJob</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"谈需求..."</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"选成员..."</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"分配模块..."</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Task&gt; tasks = <span class="keyword">new</span> List&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">    tasks.Add(Task.Run(() =&gt; Coding(<span class="string">"张小三"</span>, <span class="string">"用户管理"</span>)));</span><br><span class="line">    tasks.Add(Task.Run(() =&gt; Coding(<span class="string">"李筱思"</span>, <span class="string">"商品管理"</span>)));</span><br><span class="line">    tasks.Add(Task.Run(() =&gt; Coding(<span class="string">"王小五"</span>, <span class="string">"订单管理"</span>)));</span><br><span class="line">    tasks.Add(Task.Run(() =&gt; Coding(<span class="string">"赵小六"</span>, <span class="string">"售后管理"</span>)));</span><br><span class="line"></span><br><span class="line">    TaskFactory taskFactory = <span class="keyword">new</span> TaskFactory();</span><br><span class="line">    taskFactory.ContinueWhenAny(tasks.ToArray(), t =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"达到里程碑...  ManagerThreadId=<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 等待全部任务完成后，启动一个新的task来完成后续动作</span></span><br><span class="line">    taskFactory.ContinueWhenAll(tasks.ToArray(), tArray =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"项目上线...  ManagerThreadId=<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$"项目验收...  ManagerThreadId=<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$"支付费用...  ManagerThreadId=<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 会阻塞当前线程，直到任一任务结束</span></span><br><span class="line"><span class="comment">    Task.WaitAny(tasks.ToArray());</span></span><br><span class="line"><span class="comment">    Console.WriteLine("达到里程碑...");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 等待上面所有的多线程都计算完毕</span></span><br><span class="line"><span class="comment">    // 会阻塞当前线程，直到全部任务结束</span></span><br><span class="line"><span class="comment">    Task.WaitAll(tasks.ToArray());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Console.WriteLine("项目上线...");</span></span><br><span class="line"><span class="comment">    Console.WriteLine("项目验收...");</span></span><br><span class="line"><span class="comment">    Console.WriteLine("支付费用...");</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h1><p>如果一段代码，单线程执行和多线程执行结果不一致，就表明由线程安全问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机概念&quot;&gt;&lt;a href=&quot;#计算机概念&quot; class=&quot;headerlink&quot; title=&quot;计算机概念&quot;&gt;&lt;/a&gt;计算机概念&lt;/h1&gt;&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进
      
    
    </summary>
    
    
      <category term="C#" scheme="http://www.dimsum.fun/categories/C/"/>
    
    
      <category term="C#" scheme="http://www.dimsum.fun/tags/C/"/>
    
      <category term="多线程" scheme="http://www.dimsum.fun/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习17--触发器</title>
    <link href="http://www.dimsum.fun/2020/05/24/41.TSqlReview17/"/>
    <id>http://www.dimsum.fun/2020/05/24/41.TSqlReview17/</id>
    <published>2020-05-24T05:24:00.000Z</published>
    <updated>2020-05-24T06:11:11.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>触发器是数据库服务器中发生事件时自动执行的特种存储过程</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><ul><li>DML触发器：当发生数据操作语言，如<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>时，执行的触发器</li><li>DDL触发器：当发生数据定义语言，如<code>CREATE</code>、<code>ALTER</code>或<code>DROP</code>时，执行的触发器</li><li>登陆触发器：与SQL Server示例建立用户会话时执行的触发器</li></ul><h1 id="DML触发器"><a href="#DML触发器" class="headerlink" title="DML触发器"></a>DML触发器</h1><p>DML触发器有点：DML触发器类似于约束，可以强制实体完整性或域完整性；当约束支持的功能无法满足应用程序的功能要求时，DML触发器非常有用</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'TR_INSERT'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> TR_INSERT</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> TR_INSERT</span><br><span class="line"><span class="keyword">ON</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">PRINT <span class="string">'插入学生表成功'</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--测试触发INSERT触发器</span></span><br><span class="line"><span class="keyword">INSERT</span> dbo.STUDENT(<span class="keyword">NAME</span>,SEX,Age) <span class="keyword">VALUES</span>(<span class="string">'Alice'</span>,<span class="string">'女'</span>,<span class="number">24</span>)</span><br></pre></td></tr></table></figure><h1 id="触发器工作原理"><a href="#触发器工作原理" class="headerlink" title="触发器工作原理"></a>触发器工作原理</h1><p>SQL Server创建了两个专用表：<code>inserted</code>和<code>deleted</code>表，这是两个逻辑表，由系统维护，不允许用户直接对两个表进行修改。他们存放在内存中，不存放在数据库中。这两个表的结构总是与被触发器作用的表的结构相同</p><ul><li><p>inserted表：存放由于<code>INSERT</code>或<code>UPDATE</code>语句的执行而要加到该触发表中去的所有新行。即用于插入或更新表的新行值，在插入或更新表的同时，也将其副本存储<code>inserted</code>表中。因为在<code>inserted</code>表中的行总是与触发表中的新行相同</p></li><li><p>deleted表：存放由于<code>DELETE</code>或<code>UPDATE</code>语句的执行而要从该触发表中删除的所有行。也就是说，把触发表中要删除或要更新的旧行移到<code>deleted</code>表中。因此<code>deleted</code>表和触发表的行不相同</p></li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当向成绩表插入学生多个课程的成绩时，学生的总分发生相应变化</span></span><br><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'TR_SCORE'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> TR_SCORE</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> TR_SCORE</span><br><span class="line"><span class="keyword">ON</span> dbo.SCORE</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> @SCORE <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">SELECT</span> @SCORE=SCORE <span class="keyword">FROM</span> inserted</span><br><span class="line"><span class="keyword">UPDATE</span> dbo.TOTALSCORE <span class="keyword">SET</span> TOTALSCORE=TOTALSCORE+@SCORE</span><br><span class="line">PRINT <span class="string">'学生总成绩修改成功'</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h1 id="禁用触发器"><a href="#禁用触发器" class="headerlink" title="禁用触发器"></a>禁用触发器</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">DISABLE</span> <span class="keyword">TRIGGER</span> TR_INSERT</span><br></pre></td></tr></table></figure><h1 id="启用触发器"><a href="#启用触发器" class="headerlink" title="启用触发器"></a>启用触发器</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbo.SCORE</span><br><span class="line"><span class="keyword">ENABLE</span> <span class="keyword">TRIGGER</span> TR_SCORE</span><br></pre></td></tr></table></figure><h1 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> dbo.TR_SCORE</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;触发器是数据库服务器中发生事件时自动执行的特种存储过程&lt;/p&gt;
&lt;h1 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习16--函数</title>
    <link href="http://www.dimsum.fun/2020/05/24/40.TSqlReview16/"/>
    <id>http://www.dimsum.fun/2020/05/24/40.TSqlReview16/</id>
    <published>2020-05-24T03:42:00.000Z</published>
    <updated>2020-05-24T06:11:11.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><ul><li>内置函数：SQL Server自带</li><li>用户自定义函数：用户自己创建的函数</li></ul><h1 id="常用的内置函数"><a href="#常用的内置函数" class="headerlink" title="常用的内置函数"></a>常用的内置函数</h1><h2 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h2><ul><li>GETDATE() –返回当前日期时间</li><li>CURRENT_TIMESTAMP –返回当前日期时间</li><li>YEAR()  –返回日期中的年</li><li>MONTH()  –返回日期中的月</li><li>DAY()  –返回日期中的日</li><li>SELECT DATEPART()  –返回日期中指定部分的日期，如SELECT DATEPART(QUARTER,GETDATE())</li><li>DATEADD  –返回给日期添加指定部分的数量后的日期，如SELECT DATEADD(YEAR,2,GETDATE())</li><li>DATEDIFF  –返回指定两个日期指定部分的差，如SELECT DATEDIFF(YEAR,GETDATE(),’1991-08-22 00:00:00’)</li></ul><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul><li>LEFT()  –从字符串左边开始返回指定个数的字符串，如:SELECT LEFT(‘张三’,1)</li><li>RIGHT()  –从字符串右边开始返回指定个数的字符串，如:SELECT RIGHT(‘李四’,1)</li><li>LEN()  –返回字符串的个数，如:SELECT LEN(‘王五’)</li><li>DATALENGTH()  –返回字符串的字节数，如:SELECT DATALENGTH(‘赵六’)</li><li>LTRIM()  –返回删除左边的空格的字符串，如:SELECT LTRIM(‘ 深田咏美’)</li><li>RTRIM()  –返回删除右边的空格的字符串，如:SELECT RTRIM(‘波多野结衣  ‘)</li><li>LOWER()  –将大写字符转成小写字符</li><li>UPPER()  –将小写字符转为大写字符</li><li>SUBSTRING()  –返回字符串中的一部分字符，如:SELECT SUBSTRING(‘张三李四王五赵六’,2,2)</li></ul><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><ul><li>CAST()  –将一种数据类型转换为另一种数据类型，如:SELECT CAST(‘2016-12-1’ AS datetime2)</li><li>CONVERT()  –将一种数据类型转换为另一种数据类型，如:SELECT CONVERT(datetime2,’2020-05-06’)<br>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="keyword">CAST</span>(AGE <span class="keyword">AS</span> <span class="built_in">BIGINT</span>)) <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure></li><li>ISNULL  –使用指定的替换值替换NULL<br>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ISNULL</span>(ADDRESS,<span class="string">'中国'</span>) <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure></li><li>NEWID()  –创建uniqueidentifier类型的唯一值，如：SELECT NEWID()</li><li>ROUND()  –返回一个数值，舍入到指定的长度，如:SELECT ROUND(123.1243,2),ROUND(123.566,0,1),ROUND(123.456,-2,1)</li></ul><h1 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h1><p>SQL Server用户定义函数时接受参数、执行操作(例如复杂计算)并将操作解雇以值得形式返回得例程。返回值可以是单个标量值或结果集。用户定义函数不能用于执行修改数据库状态操作</p><p>使用用户定义函数的优点：</p><ul><li>可重复使用</li><li>执行速度更快</li><li>减少网络流量</li></ul><p>函数类型：<br>标量函数：返回单个值<br>表值函数：用户定义表值函数返回<code>TABLE</code>数据类型</p><h2 id="标量函数"><a href="#标量函数" class="headerlink" title="标量函数"></a>标量函数</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'FN_AGE'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> FN_AGE</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> FN_AGE</span><br><span class="line">(@<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>))  <span class="comment">--定义输入参数及数据类型</span></span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INT</span>  <span class="comment">--定义返回值数据类型</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> @AGE <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">SELECT</span> @AGE=Age <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=@<span class="keyword">NAME</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span> @AGE <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">SET</span> @AGE=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURN</span> @AGE <span class="comment">--指定返回值变量</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dbo.FN_AGE(<span class="string">'JAME'</span>) <span class="comment">--必须加上所属架构dbo，否则会提示：不是可以识别的函数名称</span></span><br></pre></td></tr></table></figure><h2 id="表值函数"><a href="#表值函数" class="headerlink" title="表值函数"></a>表值函数</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'FN_TABLE'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> FN_TABLE</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> FN_TABLE</span><br><span class="line">(@<span class="keyword">ID</span> <span class="built_in">INT</span>)  <span class="comment">--定义输入参数及数据类型</span></span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">TABLE</span> <span class="comment">--返回类型为TABLE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">RETURN</span>  <span class="comment">--直接用RETURN，不能使用BEGIN...END块</span></span><br><span class="line">(  <span class="comment">--必须使用括号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NAME</span>,Age <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">ID</span>=@<span class="keyword">ID</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h3 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.FN_TABLE(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;内置函数：SQL Server自带&lt;/li&gt;
&lt;li&gt;用户自定义函数：用户自己创建的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习15--事务</title>
    <link href="http://www.dimsum.fun/2020/05/24/39.TSqlReview15/"/>
    <id>http://www.dimsum.fun/2020/05/24/39.TSqlReview15/</id>
    <published>2020-05-24T02:19:00.000Z</published>
    <updated>2020-05-24T06:11:11.138Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e6%a6%82%e5%bf%b5">概念</a></li><li><a href="#sql-server%e4%ba%8b%e5%8a%a1">SQL Server事务</a></li><li><a href="#%e5%88%9b%e5%bb%ba%e6%8f%90%e4%ba%a4%e4%ba%8b%e5%8a%a1">创建提交事务</a></li><li><a href="#%e6%a0%87%e8%ae%b0%e4%b8%80%e4%b8%aa%e4%ba%8b%e5%8a%a1">标记一个事务</a></li><li><a href="#%e5%9b%9e%e6%bb%9a%e4%ba%8b%e5%8a%a1">回滚事务</a></li><li><a href="#%e5%9c%a8%e4%ba%8b%e5%8a%a1%e5%86%85%e8%ae%be%e7%bd%ae%e4%bf%9d%e5%ad%98%e7%82%b9">在事务内设置保存点</a></li><li><a href="#%e5%9c%a8%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e4%b8%ad%e4%bd%bf%e7%94%a8%e4%ba%8b%e5%8a%a1">在存储过程中使用事务</a></li></ul><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>事务是单个工作单元，如果某一事务成功，则在该事务中进行的所有数据修改均会提交，成为数据库中的永久组成部分，如果该事务遇到错误且必须取消或回滚，则所有数据修改均被清楚</p><h1 id="SQL-Server事务"><a href="#SQL-Server事务" class="headerlink" title="SQL Server事务"></a>SQL Server事务</h1><ul><li>自动提交事务：每条单独的语句都是一个事务</li><li>显式事务：每个事务均已<code>BEGIN TRANSACTION</code>语句显示开始，已<code>COMMIT</code>或<code>ROLLBACK</code>语句显式结束</li><li>隐式事务：在前一个事务完成时新事务隐式启动，但每个事务仍已<code>COMMIT</code>或<code>ROLLBACK</code>语句显式结束</li></ul><h1 id="创建提交事务"><a href="#创建提交事务" class="headerlink" title="创建提交事务"></a>创建提交事务</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span> UP_STU <span class="comment">--表示开始一个事务，BEGIN TRANSACTION使@@TRANCOUNT值按1递增</span></span><br><span class="line"><span class="comment">--SELECT @@TRANCOUNT  --查询@@TRANCOUNT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span> Age=<span class="number">10</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">TRANSACTION</span> UP_STU  <span class="comment">--表示提交一个事务，仅当对数据库的操作全部正确时，才可以提交事务。COMMIT TRANSACTION时@@TRANCOUNT值按1递减</span></span><br><span class="line"><span class="comment">--SELECT @@TRANCOUNT</span></span><br></pre></td></tr></table></figure><h1 id="标记一个事务"><a href="#标记一个事务" class="headerlink" title="标记一个事务"></a>标记一个事务</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span> UP_STU</span><br><span class="line"><span class="keyword">WITH</span> MARK <span class="string">'修改学生年龄'</span> <span class="comment">--使用WITH MARK来标记事务</span></span><br><span class="line"><span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span> Age=<span class="number">10</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Hello'</span></span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">TRANSACTION</span> UP_STU</span><br></pre></td></tr></table></figure><p><em>注：标记事务时事务名于事务日志中，在还原数据库时可将数据库还原到标记的事务</em></p><h1 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span> UP_STU</span><br><span class="line"><span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span> Age=<span class="number">10</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Hello'</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TRANSACTION</span> UP_STU <span class="comment">--回滚事务到事务的起点，清除自事务起点所作的所有数据的修改，ROLLBACK TRANSACTION使@@TRANCOUNT值递减到0</span></span><br></pre></td></tr></table></figure><h1 id="在事务内设置保存点"><a href="#在事务内设置保存点" class="headerlink" title="在事务内设置保存点"></a>在事务内设置保存点</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span> UP_STU</span><br><span class="line"><span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span> Age=<span class="number">10</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Hello'</span></span><br><span class="line"><span class="keyword">SAVE</span> <span class="keyword">TRANSACTION</span> TRAN_SAVE</span><br><span class="line"><span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span> Age=<span class="number">12</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'World'</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TRANSACTION</span> TRAN_SAVE <span class="comment">--回滚到事务的保存点位置，ROLLBACK TRANSACTION savePointName 不影响@@TRANCOUNT</span></span><br><span class="line"><span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span> Age=<span class="number">13</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'World'</span></span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">TRANSACTION</span> UP_STU</span><br></pre></td></tr></table></figure><h1 id="在存储过程中使用事务"><a href="#在存储过程中使用事务" class="headerlink" title="在存储过程中使用事务"></a>在存储过程中使用事务</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_STUDENT'</span>,<span class="string">'P'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">BEGIN</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span> TRAN1 <span class="comment">--外层事务</span></span><br><span class="line"><span class="keyword">UPDATE</span> STUDENT <span class="keyword">SET</span> Age=<span class="number">10</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Hello'</span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span> SUBTRAN1  <span class="comment">--嵌套事务</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT(<span class="keyword">NAME</span>,Age,SEX) <span class="keyword">VALUES</span>(<span class="string">'JAME'</span>,<span class="number">12</span>,<span class="string">'男'</span>)</span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">TRANSACTION</span> SUBTRAN1</span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">TRANSACTION</span> TRAN1</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line"><span class="keyword">IF</span> @@TRANCOUNT &gt; <span class="number">0</span> <span class="comment">--@@TRANCOUNT&gt;0表示在TRY块中的事务没有成功提交，那么就回滚整个外层事务</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">PRINT @@TRANCOUNT</span><br><span class="line"><span class="keyword">SELECT</span> ERROR_LINE(),ERROR_MESSAGE(),ERROR_PROCEDURE()</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TRANSACTION</span> TRAN1</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span>  <span class="comment">--ELSE就是@@TRANCOUNT的值为0，说明事务都已经全部提交了</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">END</span> CATCH</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%a6%82%e5%bf%b5&quot;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sql-server%e4%ba%8b%e5%8a%a1&quot;&gt;SQL Server事务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e5%88%9b
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习14--游标</title>
    <link href="http://www.dimsum.fun/2020/05/23/38.TSqlReview14/"/>
    <id>http://www.dimsum.fun/2020/05/23/38.TSqlReview14/</id>
    <published>2020-05-23T08:54:00.000Z</published>
    <updated>2020-05-23T10:12:55.673Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e6%a6%82%e5%bf%b5">概念</a><ul><li><a href="#%e6%b8%b8%e6%a0%87%e7%b1%bb%e5%9e%8b">游标类型：</a><ul><li><a href="#%e5%8f%aa%e8%bf%9b">只进</a></li><li><a href="#%e9%9d%99%e6%80%81%e4%b8%8d%e6%95%8f%e6%84%9f">静态/不敏感</a></li><li><a href="#%e5%8a%a8%e6%80%81">动态</a></li><li><a href="#%e9%94%ae%e9%9b%86">键集</a></li></ul></li></ul></li><li><a href="#%e4%bd%bf%e7%94%a8%e7%ae%80%e5%8d%95%e7%9a%84%e6%b8%b8%e6%a0%87">使用简单的游标</a></li><li><a href="#%e4%bd%bf%e7%94%a8while%e5%be%aa%e7%8e%af%e6%a3%80%e7%b4%a2%e6%b8%b8%e6%a0%87%e4%b8%ad%e7%9a%84%e7%bb%93%e6%9e%9c%e9%9b%86">使用WHILE循环检索游标中的结果集</a></li><li><a href="#%e5%9c%a8%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e4%b8%ad%e4%bd%bf%e7%94%a8%e6%b8%b8%e6%a0%87">在存储过程中使用游标</a></li></ul><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>SQL Server语句产生完整的结果集，但有时候最好对结果进行逐行处理，打开结果集中的游标，即可对结果集进行逐行处理。<strong>游标主要用于存储过程、触发器、批处理中*</strong></p><p>游标通过以下方式来拓展结果处理：</p><ul><li>允许定位在结果集中的特定行</li><li>从结果集的当前位置检索一行或一部分行</li><li>支持对结果集中当前位置的行进行数据修改</li><li>为由其他用户对显示在结果集中的数据库数据所作的更改提供不同级别的可见性支持</li><li>提供脚本、存储过程和触发器中用于访问结果集中的数据的TSQL语句</li></ul><h2 id="游标类型："><a href="#游标类型：" class="headerlink" title="游标类型："></a>游标类型：</h2><h3 id="只进"><a href="#只进" class="headerlink" title="只进"></a>只进</h3><p>只进游标不支持滚动，它只支持游标从头到尾顺序提取。行只在从数据库中提取出来后才检索。对所有由当前用户发出或由其他用户提交、并影响结果集中的行的<code>INSERT、UPDATE、DELETE</code>语句，其效果在这些行从游标中提取时是可见的</p><h3 id="静态-不敏感"><a href="#静态-不敏感" class="headerlink" title="静态/不敏感"></a>静态/不敏感</h3><p>静态游标总是按照打开游标时的原样显示结果集，游标在打开期间，对数据库的<code>INSERT、UPDATE、DELETE</code>影响的行，在游标中都无法反应出来，除非关闭游标重新打开。静态游标在滚动期间很少或根本检测不到变化，但消耗的资源相对很少</p><h3 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h3><p>动态游标与静态游标相对，当游标滚动时，动态游标反应结果集中所做的所有更变，所有用户做的全部<code>INSERT、UPDATE、DELETE</code>语句均通过游标可见</p><h3 id="键集"><a href="#键集" class="headerlink" title="键集"></a>键集</h3><p>由键集驱动的游标由一组唯一标识符(键)控制，这组键称为键集，打开由剪辑驱动的游标时，该游标中各行的成员身份和顺序是固定的</p><h1 id="使用简单的游标"><a href="#使用简单的游标" class="headerlink" title="使用简单的游标"></a>使用简单的游标</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> CUR_STU <span class="keyword">CURSOR</span> <span class="comment">--定义游标</span></span><br><span class="line"><span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> SEX=<span class="string">'女'</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">OPEN</span> CUR_STU   <span class="comment">--OPEN打开游标，然后通过执行DECLARE CURSOR语句的TSQL填充游标结果集</span></span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">NEXT</span> <span class="keyword">FROM</span> CUR_STU  <span class="comment">--FETCH从游标表检索行，NEXT依次从结果集中第一行返回数据</span></span><br><span class="line"><span class="keyword">SELECT</span> @@FETCH_STATUS  <span class="comment">--查看@@FETCH_STATUS的值，游标有数据，则状态值=0，如果游标数据被提取完之后这个状态值为-1</span></span><br><span class="line"><span class="keyword">CLOSE</span> CUR_STU  <span class="comment">--CLOSE关闭一个开放的游标，释放当前的结果集，必须对打开的游标使用CLOSE </span></span><br><span class="line"><span class="keyword">DEALLOCATE</span> CUR_STU  <span class="comment">--DEALLOCATE删除游标引用</span></span><br></pre></td></tr></table></figure><h1 id="使用WHILE循环检索游标中的结果集"><a href="#使用WHILE循环检索游标中的结果集" class="headerlink" title="使用WHILE循环检索游标中的结果集"></a>使用WHILE循环检索游标中的结果集</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> CUR_STU <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> SEX=<span class="string">'男'</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">OPEN</span> CUR_STU</span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">NEXT</span> <span class="keyword">FROM</span> CUR_STU</span><br><span class="line"><span class="keyword">WHILE</span> (<span class="keyword">SELECT</span> @@FETCH_STATUS)=<span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">FETCH</span> <span class="keyword">NEXT</span> <span class="keyword">FROM</span> CUR_STU</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">CLOSE</span> CUR_STU</span><br><span class="line"><span class="keyword">DEALLOCATE</span> CUR_STU</span><br></pre></td></tr></table></figure><h1 id="在存储过程中使用游标"><a href="#在存储过程中使用游标" class="headerlink" title="在存储过程中使用游标"></a>在存储过程中使用游标</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_UPDATE_STU'</span>,<span class="string">'P'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> P_UPDATE_STU</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_UPDATE_STU</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">BEGIN</span> TRY</span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span> <span class="comment">--关闭显示受影响行数消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">ID</span> <span class="built_in">BIGINT</span> <span class="comment">--定义两个变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> @AGE <span class="built_in">INT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> STU_CUR <span class="keyword">CURSOR</span> <span class="keyword">FOR</span>  <span class="comment">--定义游标</span></span><br><span class="line"><span class="keyword">SELECT</span> STU.ID,stu.AGE <span class="keyword">FROM</span> dbo.GRADE GR <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dbo.STUDENT STU <span class="keyword">ON</span> GR.STUDENTID=STU.ID</span><br><span class="line"></span><br><span class="line"><span class="keyword">OPEN</span> STU_CUR  <span class="comment">--打开游标</span></span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">NEXT</span> <span class="keyword">FROM</span> STU_CUR <span class="keyword">INTO</span> @<span class="keyword">ID</span>,@AGE  <span class="comment">--获取第一行赋值给两个变量</span></span><br><span class="line"><span class="keyword">WHILE</span> @@FETCH_STATUS=<span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span> AGE=@AGE+<span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">ID</span>=@<span class="keyword">ID</span></span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">NEXT</span> <span class="keyword">FROM</span> STU_CUR <span class="keyword">INTO</span> @<span class="keyword">ID</span>,@AGE</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line"><span class="keyword">SELECT</span> ERROR_NUMBER(),ERROR_PROCEDURE(),ERROR_MESSAGE()</span><br><span class="line"><span class="keyword">END</span> CATCH</span><br><span class="line"></span><br><span class="line"><span class="keyword">CLOSE</span> STU_CUR</span><br><span class="line"><span class="keyword">DEALLOCATE</span> STU_CUR</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%a6%82%e5%bf%b5&quot;&gt;概念&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b8%b8%e6%a0%87%e7%b1%bb%e5%9e%8b&quot;&gt;游标类型：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e5%8f%aa%
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习13--流程控制语句</title>
    <link href="http://www.dimsum.fun/2020/05/23/37.TSqlReview13/"/>
    <id>http://www.dimsum.fun/2020/05/23/37.TSqlReview13/</id>
    <published>2020-05-23T08:17:00.000Z</published>
    <updated>2020-05-23T10:12:55.672Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#beginend">BEGIN…END</a></li><li><a href="#ifelse">IF…ELSE…</a></li><li><a href="#while">WHILE</a><ul><li><a href="#%e5%9c%a8while%e4%b8%ad%e4%bd%bf%e7%94%a8breakcontinue">在WHILE中使用BREAK、CONTINUE</a></li></ul></li><li><a href="#goto">GOTO</a><ul><li><a href="#%e4%bd%bf%e7%94%a8goto%e8%af%ad%e5%8f%a5%e5%ae%9e%e7%8e%b0%e5%be%aa%e7%8e%af">使用GOTO语句实现循环</a></li></ul></li><li><a href="#waitfor">WAITFOR</a></li></ul><h1 id="BEGIN…END"><a href="#BEGIN…END" class="headerlink" title="BEGIN…END"></a>BEGIN…END</h1><p>可以包含多个TSQL语言，一次性执行多个TSQL语言</p><h1 id="IF…ELSE…"><a href="#IF…ELSE…" class="headerlink" title="IF…ELSE…"></a>IF…ELSE…</h1><p>当<code>IF</code>中的条件满足时，执行<code>IF</code>条件后的TSQL语句，若<code>IF</code>中的条件不满足，则执行<code>ELSE</code>后的TSQL语句</p><p>具体语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF 布尔表达式</span><br><span class="line">TSQL</span><br><span class="line">ELSE <span class="comment">--ELSE子句可选</span></span><br><span class="line">TSQL</span><br></pre></td></tr></table></figure><p><strong>注意：<code>IF</code>或<code>ELSE</code>条件只能影响一个TSQL语句，若要在<code>IF</code>或<code>ELSE</code>条件后面执行多个TSQL，则需要用<code>BEGIN...END</code>关键字</strong></p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF(<span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'YOYOYO'</span>)&gt;<span class="number">18</span></span><br><span class="line">PRINT <span class="string">'已成年'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">PRINT <span class="string">'未成年'</span></span><br></pre></td></tr></table></figure><p>使用嵌套的<code>IF...ELSE...</code>，示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> @age <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">SELECT</span> @age=AGE <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'YOYOYO'</span></span><br><span class="line"><span class="keyword">IF</span> @age&gt;=<span class="number">18</span></span><br><span class="line">PRINT <span class="string">'已成年'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">IF</span>(@age&gt;=<span class="number">12</span>)</span><br><span class="line">PRINT <span class="string">'小朋友'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">PRINT <span class="string">'小小朋友'</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h1 id="WHILE"><a href="#WHILE" class="headerlink" title="WHILE"></a>WHILE</h1><p>设置重复执行SQL语句或语句块的条件，指要指定的条件为真，就重复执行语句。可以使用<code>BREAK</code>和<code>CONTINUE</code>关键字在循环内部控制<code>WHILE</code>循环中语句的执行</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WHILE (<span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Jame'</span>)&lt;<span class="number">18</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span> AGE=AGE+<span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Jame'</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Jame'</span> <span class="comment">--查询检查结果</span></span><br></pre></td></tr></table></figure><h2 id="在WHILE中使用BREAK、CONTINUE"><a href="#在WHILE中使用BREAK、CONTINUE" class="headerlink" title="在WHILE中使用BREAK、CONTINUE"></a>在WHILE中使用BREAK、CONTINUE</h2><ul><li>BREAK：退出循环，即推出当前循环，执行出现在END关键字后面的语句</li><li>CONTINUE：跳出本次循环，进行循环条件判断</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WHILE (<span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Jame'</span>)&lt;<span class="number">30</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span> AGE=AGE+<span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Jame'</span></span><br><span class="line"><span class="keyword">IF</span>(<span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Jame'</span>)&lt;<span class="number">22</span></span><br><span class="line">CONTINUE</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    BREAK</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Jame'</span></span><br></pre></td></tr></table></figure><h1 id="GOTO"><a href="#GOTO" class="headerlink" title="GOTO"></a>GOTO</h1><p>将执行流更改到标签处，<code>GOTO</code>语句和标签可在过程、批处理或语句块中的任意位置使用</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用GOTO语句循环出10到20之间的数字</span></span><br><span class="line"><span class="keyword">DECLARE</span> @N <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">SET</span> @N=<span class="number">10</span></span><br><span class="line">LABEL:  <span class="comment">--标签名称要以冒号结束</span></span><br><span class="line"><span class="keyword">IF</span> @N&lt;<span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SET</span> @N=@N+<span class="number">1</span></span><br><span class="line">PRINT @N</span><br><span class="line"><span class="keyword">GOTO</span> LABEL  <span class="comment">--GOTO指定跳转的标签名称</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="使用GOTO语句实现循环"><a href="#使用GOTO语句实现循环" class="headerlink" title="使用GOTO语句实现循环"></a>使用GOTO语句实现循环</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LABEL1:</span><br><span class="line">IF(<span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Jame'</span>)&lt;<span class="number">25</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span> AGE=AGE+<span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Jame'</span></span><br><span class="line"><span class="keyword">GOTO</span> LABEL1</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'Jame'</span></span><br></pre></td></tr></table></figure><h1 id="WAITFOR"><a href="#WAITFOR" class="headerlink" title="WAITFOR"></a>WAITFOR</h1><p>控制语句执行的时间</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">WAITFOR <span class="built_in">TIME</span> <span class="string">'16:52'</span> <span class="comment">--在几点开始执行，不能指定日期</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">WAITFOR DELAY <span class="string">'00:00:10'</span> <span class="comment">--多长时间后开始，最长为24小时，不能指定日期</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#beginend&quot;&gt;BEGIN…END&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ifelse&quot;&gt;IF…ELSE…&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#while&quot;&gt;WHILE&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e5
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习12--CASE表达式</title>
    <link href="http://www.dimsum.fun/2020/05/23/36.TSqlReview12/"/>
    <id>http://www.dimsum.fun/2020/05/23/36.TSqlReview12/</id>
    <published>2020-05-23T07:48:00.000Z</published>
    <updated>2020-05-23T10:12:55.672Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#case%e7%ae%80%e5%8d%95%e8%a1%a8%e8%be%be%e5%bc%8f">CASE简单表达式</a></li><li><a href="#case%e6%90%9c%e7%b4%a2%e8%a1%a8%e8%be%be%e5%bc%8f">CASE搜索表达式</a></li><li><a href="#%e5%9c%a8order-bygroup-by%e4%b8%ad%e4%bd%bf%e7%94%a8case%e8%a1%a8%e8%be%be%e5%bc%8f">在ORDER BY、GROUP BY中使用CASE表达式</a></li><li><a href="#%e5%9c%a8update%e4%b8%ad%e4%bd%bf%e7%94%a8case%e8%a1%a8%e8%be%be%e5%bc%8f">在UPDATE中使用CASE表达式</a></li></ul><h1 id="CASE简单表达式"><a href="#CASE简单表达式" class="headerlink" title="CASE简单表达式"></a>CASE简单表达式</h1><p><code>CASE</code>简单表达式仅用于同行检查，将第一个表达式与每个<code>WHEN</code>子句中的表达式进行等同行检查，以确定它们是否等效</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NAME</span>,AGE,</span><br><span class="line">(<span class="keyword">CASE</span> SEX </span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'男'</span> <span class="keyword">THEN</span> <span class="string">'是'</span> </span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'否'</span> </span><br><span class="line"> <span class="keyword">END</span>) <span class="keyword">AS</span> 是否男性</span><br><span class="line"><span class="keyword">FROM</span> dbo.STUDENT</span><br></pre></td></tr></table></figure><h1 id="CASE搜索表达式"><a href="#CASE搜索表达式" class="headerlink" title="CASE搜索表达式"></a>CASE搜索表达式</h1><p><code>CASE</code>搜索表达式按照指定顺序对每个<code>WHEN</code>子句的<strong>布尔表达式</strong>进行计算</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NAME</span>,SEX,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="comment">--注意这里CASE后面没带字段名称</span></span><br><span class="line"><span class="keyword">WHEN</span> AGE &gt; <span class="string">'18'</span> <span class="keyword">THEN</span> <span class="string">'成年'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'未成年'</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">) <span class="keyword">AS</span> 是否成年</span><br><span class="line"><span class="keyword">FROM</span> dbo.STUDENT</span><br></pre></td></tr></table></figure><h1 id="在ORDER-BY、GROUP-BY中使用CASE表达式"><a href="#在ORDER-BY、GROUP-BY中使用CASE表达式" class="headerlink" title="在ORDER BY、GROUP BY中使用CASE表达式"></a>在ORDER BY、GROUP BY中使用CASE表达式</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> AGE&gt;<span class="number">18</span> <span class="keyword">THEN</span> <span class="string">'已成年'</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">'未成年'</span></span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line">) <span class="keyword">AS</span> 是否成年,<span class="keyword">COUNT</span>(<span class="keyword">ID</span>) <span class="keyword">AS</span> 人数</span><br><span class="line"><span class="keyword">FROM</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> AGE&gt;<span class="number">18</span> <span class="keyword">THEN</span> <span class="string">'已成年'</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">'未成年'</span></span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 是否成年</span><br></pre></td></tr></table></figure><h1 id="在UPDATE中使用CASE表达式"><a href="#在UPDATE中使用CASE表达式" class="headerlink" title="在UPDATE中使用CASE表达式"></a>在UPDATE中使用CASE表达式</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dbo.STUDENT <span class="keyword">SET</span></span><br><span class="line">AGE=</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">NAME</span> </span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'Hello'</span> <span class="keyword">THEN</span> <span class="number">18</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'world'</span> <span class="keyword">THEN</span> <span class="number">11</span></span><br><span class="line"><span class="keyword">ELSE</span> AGE</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#case%e7%ae%80%e5%8d%95%e8%a1%a8%e8%be%be%e5%bc%8f&quot;&gt;CASE简单表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#case%e6%90%9c%e7%b4%a2%e8%a1%a8%e8%be
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习11--存储过程</title>
    <link href="http://www.dimsum.fun/2020/05/22/35.TSqlReview11/"/>
    <id>http://www.dimsum.fun/2020/05/22/35.TSqlReview11/</id>
    <published>2020-05-22T09:51:00.000Z</published>
    <updated>2020-05-23T10:12:55.672Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e8%a7%a3%e6%9e%90">解析</a></li><li><a href="#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e7%9a%84%e7%b1%bb%e5%9e%8b">存储过程的类型</a></li><li><a href="#%e7%ae%80%e5%8d%95%e7%9a%84%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b">简单的存储过程</a><ul><li><a href="#%e5%88%9b%e5%bb%ba">创建</a></li><li><a href="#%e6%89%a7%e8%a1%8c">执行</a></li><li><a href="#%e4%bf%ae%e6%94%b9">修改</a></li><li><a href="#%e5%88%a0%e9%99%a4">删除</a></li></ul></li><li><a href="#%e6%89%a7%e8%a1%8c%e5%a4%9a%e6%ad%a5%e6%93%8d%e4%bd%9c%e7%9a%84%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b">执行多步操作的存储过程</a></li><li><a href="#%e5%b8%a6%e8%be%93%e5%85%a5%e5%8f%82%e6%95%b0%e7%9a%84%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b">带输入参数的存储过程</a><ul><li><a href="#%e6%a6%82%e5%bf%b5">概念</a></li><li><a href="#%e5%88%9b%e5%bb%ba-1">创建</a></li><li><a href="#%e6%89%a7%e8%a1%8c-1">执行</a></li></ul></li><li><a href="#%e5%b8%a6%e9%80%9a%e9%85%8d%e7%ac%a6%e7%9a%84%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b">带通配符的存储过程</a><ul><li><a href="#%e5%88%9b%e5%bb%ba-2">创建</a></li><li><a href="#%e6%89%a7%e8%a1%8c-2">执行</a></li></ul></li><li><a href="#%e5%b8%a6%e8%be%93%e5%87%ba%e5%8f%82%e6%95%b0%e7%9a%84%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b">带输出参数的存储过程</a><ul><li><a href="#%e5%88%9b%e5%bb%ba-3">创建</a></li><li><a href="#%e6%89%a7%e8%a1%8c-3">执行</a></li></ul></li><li><a href="#%e5%b8%a6%e8%a1%a8%e5%80%bc%e5%8f%82%e6%95%b0%e7%9a%84%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b">带表值参数的存储过程</a><ul><li><a href="#%e5%88%9b%e5%bb%ba-4">创建</a></li><li><a href="#%e6%89%a7%e8%a1%8c-4">执行</a></li></ul></li><li><a href="#%e5%b8%a6%e5%8f%98%e9%87%8f%e7%9a%84%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b">带变量的存储过程</a><ul><li><a href="#%e6%a6%82%e5%bf%b5-1">概念</a></li><li><a href="#%e5%88%9b%e5%bb%ba-5">创建</a></li><li><a href="#%e6%89%a7%e8%a1%8c-5">执行</a></li></ul></li><li><a href="#%e5%8f%af%e6%8d%95%e8%8e%b7%e5%bc%82%e5%b8%b8%e7%9a%84%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b">可捕获异常的存储过程</a><ul><li><a href="#%e6%a6%82%e5%bf%b5-2">概念</a></li><li><a href="#%e5%88%9b%e5%bb%ba-6">创建</a></li><li><a href="#%e6%89%a7%e8%a1%8c-6">执行</a></li></ul></li><li><a href="#%e5%af%b9%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e5%8a%a0%e5%af%86%e5%8f%8a%e9%87%8d%e6%96%b0%e7%bc%96%e8%af%91">对存储过程加密及重新编译</a><ul><li><a href="#%e6%a6%82%e5%bf%b5-3">概念</a></li><li><a href="#%e5%88%9b%e5%bb%ba-7">创建</a></li></ul></li><li><a href="#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e7%9a%84%e4%bc%98%e5%8c%96">存储过程的优化</a></li></ul><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>存储过程是由一个或多个<code>Transact-SQL</code>语句构成的一个组</p><p>存储过程可以：</p><ul><li>接受输入参数并以输出参数的格式向调用程序返回多个值</li><li>包含用于在数据库中执行操作的编程语句，这包括调用其他存储过程</li><li>向调用程序返回状态值，以值明成功或失败(以及失败的原因)</li></ul><p>使用存储过程的好处：</p><ul><li>减少了服务器/客户端网络流量</li><li>更强的安全性</li><li>代码的重复使用</li><li>更容易维护</li><li>改进的性能</li></ul><h1 id="存储过程的类型"><a href="#存储过程的类型" class="headerlink" title="存储过程的类型"></a>存储过程的类型</h1><ul><li>用户定义的存储过程：由用户自己创建的存储过程</li><li>临时存储过程：也是由用户创建的存储过程，存储在<code>tempdb</code>中，名字以<code>#</code>开头，仅在创建该过程的会话中存在，会话结束，临时存储过程即被删除(类似临时表)</li><li>系统存储过程：系统存储过程是由SQL Server附带的，系统过程以<code>sp_</code>开头，帮助用户使用、管理数据库</li></ul><h1 id="简单的存储过程"><a href="#简单的存储过程" class="headerlink" title="简单的存储过程"></a>简单的存储过程</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_STUDENT'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">NAME</span>,AGE <span class="keyword">FROM</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC dbo.P_STUDENT  <span class="comment">--EXEC是EXECUTE的简写</span></span><br><span class="line"><span class="keyword">EXECUTE</span> dbo.P_STUDENT</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">NAME</span>,AGE,SEX <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> AGE&gt;<span class="number">13</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> dbo.P_STUDENT</span><br></pre></td></tr></table></figure><h1 id="执行多步操作的存储过程"><a href="#执行多步操作的存储过程" class="headerlink" title="执行多步操作的存储过程"></a>执行多步操作的存储过程</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_COURSE02'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> P_COURSE02</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_COURSE02</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> COURSE01 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.COURSE</span><br><span class="line"><span class="keyword">UPDATE</span> COURSE01 <span class="keyword">SET</span> <span class="keyword">NAME</span>=<span class="string">'高数'</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'.NET CORE'</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dbo.COURSE01 <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'JAVA'</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.COURSE01</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h1 id="带输入参数的存储过程"><a href="#带输入参数的存储过程" class="headerlink" title="带输入参数的存储过程"></a>带输入参数的存储过程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>输入参数：调用方将数据值传递给存储过程</li><li>输出参数：存储过程将数据值返回给调用方</li><li>变量：可以在存储过程内部存储和传递数据值，不能将数据从外部传递到存储过程内部</li></ul><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_STUDENT'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line">@sex <span class="built_in">CHAR</span>(<span class="number">2</span>),   <span class="comment">--注意：定义参数位置在存储过程名称粥，参数要以@符号开始</span></span><br><span class="line">@age <span class="built_in">INT</span> = <span class="number">18</span>   <span class="comment">--这里是将age参数的默认值设定为18，当参数由默认值的时候，调用方如果没传该参数的值过来，则使用默认值进行执行</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> <span class="keyword">ID</span>,<span class="keyword">NAME</span>,AGE,SEX <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> SEX=@sex <span class="keyword">AND</span> AGE&gt;@age </span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h2 id="执行-1"><a href="#执行-1" class="headerlink" title="执行"></a>执行</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC dbo.P_STUDENT @sex='女',@age=15</span><br></pre></td></tr></table></figure><h1 id="带通配符的存储过程"><a href="#带通配符的存储过程" class="headerlink" title="带通配符的存储过程"></a>带通配符的存储过程</h1><p>示例：</p><h2 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_STUDENT'</span>,<span class="string">'P'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line">@<span class="keyword">name</span> <span class="keyword">NVARCHAR</span>(<span class="number">100</span>)   <span class="comment">--参数定义方法不变</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">NAME</span>,AGE,SEX <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> @<span class="keyword">name</span>  <span class="comment">--通配符查询得使用LIKE</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h2 id="执行-2"><a href="#执行-2" class="headerlink" title="执行"></a>执行</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC dbo.P_STUDENT @name = N'王%'</span><br></pre></td></tr></table></figure><h1 id="带输出参数的存储过程"><a href="#带输出参数的存储过程" class="headerlink" title="带输出参数的存储过程"></a>带输出参数的存储过程</h1><h2 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_STUDENT'</span>,<span class="string">'P'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line">@<span class="keyword">name</span> <span class="keyword">NVARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">@age <span class="built_in">INT</span> <span class="keyword">OUTPUT</span>  <span class="comment">--OUTPUT或OUT都表示为输出参数</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> @age=AGE <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=@<span class="keyword">name</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h2 id="执行-3"><a href="#执行-3" class="headerlink" title="执行"></a>执行</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行带输出参数的存储过程时一定要先使用DECLARE声明参数</span></span><br><span class="line"><span class="keyword">DECLARE</span> @age <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">EXECUTE</span> dbo.P_STUDENT @<span class="keyword">name</span> = N<span class="string">'李筱思'</span>,</span><br><span class="line">                      @age = @age <span class="keyword">OUTPUT</span></span><br><span class="line"><span class="keyword">SELECT</span> @age 返回值age</span><br></pre></td></tr></table></figure><h1 id="带表值参数的存储过程"><a href="#带表值参数的存储过程" class="headerlink" title="带表值参数的存储过程"></a>带表值参数的存储过程</h1><h2 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="comment">-- 创建表类型</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'TYPE01'</span>,<span class="string">'TT'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TYPE</span> TYPE01</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> TYPE01 <span class="keyword">AS</span> <span class="keyword">TABLE</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">NAME</span> <span class="keyword">NVARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">SEX <span class="built_in">CHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">AGE <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_INSERT_STUDENT'</span>,<span class="string">'P'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> P_INSERT_STUDENT</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_INSERT_STUDENT</span><br><span class="line">@<span class="keyword">DATA</span> TYPE01 READONLY  <span class="comment">--定义输入参数类型为上面定义的TYPE01类型</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT(<span class="keyword">NAME</span>,SEX,AGE) <span class="keyword">SELECT</span> <span class="keyword">NAME</span>,SEX,AGE <span class="keyword">FROM</span> @<span class="keyword">DATA</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h2 id="执行-4"><a href="#执行-4" class="headerlink" title="执行"></a>执行</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行存储类型</span></span><br><span class="line"><span class="comment">-- 先定义表类型的变量@MyData</span></span><br><span class="line"><span class="keyword">DECLARE</span> @MyData <span class="keyword">AS</span> TYPE01</span><br><span class="line"><span class="comment">-- 然后往变量@MyData里添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> @MyData</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'Jame'</span>,<span class="string">'男'</span>,<span class="number">12</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'Alice'</span>,<span class="string">'女'</span>,<span class="number">23</span></span><br><span class="line"><span class="comment">-- 执行存储过程，将上面定义的变量传入存储过程</span></span><br><span class="line">EXEC dbo.P_INSERT_STUDENT @<span class="keyword">DATA</span> = @MyData</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="comment">-- 查看执行结果</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h1 id="带变量的存储过程"><a href="#带变量的存储过程" class="headerlink" title="带变量的存储过程"></a>带变量的存储过程</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>变量：变量分局部变量和全局变量</p><ul><li>局部变量：用户自定义的变量，作用范围在程序内部，局部变量必须先生命，再使用，名称必须以<code>@</code>开头</li><li>全局变量：是SQL系统内部实现定义好的变量，不需要用户参与定义，任何程序均可以随时调用，SQL中共有30多个全局变量，名称都以<code>@@</code>开头，主要用于SQL Server的配置设定值和效能统计数据</li></ul><p>声明局部变量：<code>DECLARE 以@开头的变量名 数据类型(长度)</code></p><p>局部变量复制：</p><ol><li><code>SET 局部变量名=值</code></li><li><code>SELECT 局部变量名=字段名 FROM 表名 ORDER BY 字段名</code>，若<code>SELECT</code>返回值有多个，则数据库引擎会分配最后一个值给变量</li></ol><p>局部变量的作用域：在<code>DECLARE</code>变量开始至脚本或存储过程结束</p><h2 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_STUDENT'</span>,<span class="string">'P'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> dbo.P_STUDENT</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line">@<span class="keyword">NAME</span> <span class="keyword">NVARCHAR</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> @AGE <span class="built_in">INT</span>  <span class="comment">--注意：参数的定义位置在AS前面，变量的定义位置在AS后面</span></span><br><span class="line"><span class="keyword">SELECT</span> @AGE=AGE <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=@<span class="keyword">NAME</span>  <span class="comment">--通过查询结果给变量复制</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> AGE=@AGE <span class="comment">--使用变量进行查询</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h2 id="执行-5"><a href="#执行-5" class="headerlink" title="执行"></a>执行</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC dbo.P_STUDENT @NAME = N'李筱思'</span><br></pre></td></tr></table></figure><h1 id="可捕获异常的存储过程"><a href="#可捕获异常的存储过程" class="headerlink" title="可捕获异常的存储过程"></a>可捕获异常的存储过程</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>使用<code>TRY...CATCH</code>结构来捕获并处理异常</p><p>在<code>TRY</code>块中的SQL发生异常，则执行<code>CATCH</code>块中的SQL，<code>TRY...CATCH</code>不可用在用户自定义函数中</p><h2 id="创建-6"><a href="#创建-6" class="headerlink" title="创建"></a>创建</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_STUDENT'</span>,<span class="string">'P'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> dbo.P_STUDENT</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line">@<span class="keyword">ID</span> <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">@<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">@SEX <span class="built_in">CHAR</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">BEGIN</span> TRY</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT(<span class="keyword">ID</span>,SEX,<span class="keyword">NAME</span>)  <span class="comment">--这里模拟个异常</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">ID</span>,@<span class="keyword">NAME</span>,@SEX</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line"><span class="keyword">SELECT</span> ERROR_NUMBER() <span class="keyword">AS</span> ERROR_NUM,</span><br><span class="line">               ERROR_PROCEDURE() <span class="keyword">AS</span> ERROR_PROC,</span><br><span class="line">               ERROR_SEVERITY() <span class="keyword">AS</span> ERROR_SEVE,</span><br><span class="line">               ERROR_MESSAGE() <span class="keyword">AS</span> ERROR_MSG</span><br><span class="line"><span class="keyword">END</span> CATCH</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h2 id="执行-6"><a href="#执行-6" class="headerlink" title="执行"></a>执行</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC dbo.P_STUDENT @ID = '1',</span><br><span class="line">                   @NAME = '123131',</span><br><span class="line">                   @SEX = '131'</span><br></pre></td></tr></table></figure><h1 id="对存储过程加密及重新编译"><a href="#对存储过程加密及重新编译" class="headerlink" title="对存储过程加密及重新编译"></a>对存储过程加密及重新编译</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>使用<code>EXEC sys.sp_helptext 存储过程名字</code>查看存储过程定义</p><p>使用<code>WITH ENCRYPTION</code>选项对过程定义进行模糊处理</p><p>使用<code>WITH RECOMPILE</code>选项强制重新编译过程：</p><ol><li>数据结构进行了重要更改，则重新编译过程会进行更新并针对这些更改优化过程的查询计划，这样可以提高过程的处理性能</li><li>对过程引用的基础表添加了过程可能从中受益的新索引，可以强制在下次执行过程时对其重新编译</li></ol><h2 id="创建-7"><a href="#创建-7" class="headerlink" title="创建"></a>创建</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> OBJECT_ID(<span class="string">'P_STUDENT'</span>,<span class="string">'P'</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> P_STUDENT</span><br><span class="line">@<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">WITH</span> ENCRYPTION,RECOMPILE</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> @AGE <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">SELECT</span> @AGE=AGE <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=@<span class="keyword">NAME</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> AGE=@AGE</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h1 id="存储过程的优化"><a href="#存储过程的优化" class="headerlink" title="存储过程的优化"></a>存储过程的优化</h1><ol><li>在存储过程中使用<code>SET NOCOUNT ON/OFF</code>关闭或启用显示受TSQL语句影响的行计数消息：<strong><code>SET NOCOUNT ON</code>有利于提升过程执行效率</strong></li><li>当在过程中创建或引用数据库对象时使用架构名称，减少数据库引擎解析对象名称所用的处理时间：<strong>就是类似<code>dbo.STUDENT</code>这样的写法，补上前面的<code>dbo</code>，不要直接写<code>STUDENT</code></strong></li><li>避免函数包装在<code>WHERE</code>和<code>JOIN</code>子句中指定的列，这样做会使列具有不确定性并且禁止查询处理器使用索引</li><li>避免在返回许多行数据的<code>SELECT</code>语句中使用标量函数。因为标量函数必须应用于每一行，会降低性能</li><li>避免使用<code>SELECT *</code>。而是应指定所需的列名称</li><li>避免处理或返回过多的数据，尽可能在过程代码中缩小结果的范围</li><li>通过使用<code>BEGIN/END TRANSACTION</code>来使用显示事务并且保留尽可能短的事务。更长的事务意味着更长的记录锁定和更高的死锁风险</li><li>通过<code>TRY...CATCH...</code>功能进行过程内的错误处理，<code>TRY...CATCH...</code>可以封装整个TSQL语句块</li><li>在过程主体中对<code>CREATE TABLE</code>或<code>ALTER TABLE</code>语句引用的所有表列使用<code>DEFAULT</code>关键字，这将禁止将<code>NULL</code>传递到不允许<code>NULL</code>值的列</li><li>对于临时表中的每一列使用<code>NULL</code>或<code>NOT NULL</code></li><li>使用<code>UNION ALL</code>运算符来代替<code>UNION</code>或<code>OR</code>运算符，除非存在针对非重复值的特定需要。<code>UNION ALL</code>运算符要求更少的处理开销，因为重复值不从结果集中筛选出来</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e8%a7%a3%e6%9e%90&quot;&gt;解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e7%9a%84%e7%b1%bb%e5%9e%8b&quot;&gt;存储过程的类型&lt;/a
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习10--索引</title>
    <link href="http://www.dimsum.fun/2020/05/22/34.TSqlReview10/"/>
    <id>http://www.dimsum.fun/2020/05/22/34.TSqlReview10/</id>
    <published>2020-05-22T08:19:00.000Z</published>
    <updated>2020-05-22T11:00:01.085Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e8%a7%a3%e6%9e%90">解析</a></li><li><a href="#%e5%88%86%e7%b1%bb">分类</a><ul><li><a href="#%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95">聚集索引</a></li><li><a href="#%e9%9d%9e%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95">非聚集索引</a></li><li><a href="#%e5%94%af%e4%b8%80%e7%b4%a2%e5%bc%95">唯一索引</a></li></ul></li><li><a href="#%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96%e5%99%a8%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95">查询优化器如何使用索引</a></li><li><a href="#%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95">创建索引</a><ul><li><a href="#%e9%9a%90%e5%bc%8f%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95">隐式创建索引</a></li><li><a href="#%e6%98%be%e7%a4%ba%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95">显示创建索引</a></li></ul></li><li><a href="#%e5%88%a0%e9%99%a4%e7%b4%a2%e5%bc%95">删除索引</a></li><li><a href="#%e6%9f%a5%e7%9c%8bsql-server%e7%9a%84%e6%9f%a5%e8%af%a2%e6%ad%a5%e9%aa%a4">查看SQL Server的查询步骤</a></li><li><a href="#%e5%9c%a8%e5%93%aa%e4%ba%9b%e5%ad%97%e6%ae%b5%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95">在哪些字段创建索引</a></li></ul><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>索引就像书中的目录，使你能快速定位到所需的信息，数据库中的索引可以加快检索表或视图中的信息速度。索引包含表或视图中的一列或多列生成的键，这些键存储在一个结构(B树)中，时SQL Server可以快速有效的查找域键值相关联的行</p><p>索引类似一个微表，索引中只存储索引所在列的件值，需要查询数据时，若可以用到索引中的列，则首先会在索引表中查询，而不是直接从数据表中查询数据</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>聚集索引是指数据表回根据索引表中键值的顺序存储和排序表数据，因为一张表只能按照一个顺序排序，所以一张表只能由一个聚集索引</p><h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><p>非聚集索引中的键值只是在逻辑上排序，并不对表中的数据进行排序，因此叫做非聚集索引，一张表可以有多个非聚集索引，当一个表有聚集索引时，非聚集索引时指向聚集索引的指针，也就是说当使用非聚集索引查询数据时，SQL Server先从非聚集索引中查到该键值，再去查该键值对应的聚集索引键值，再从聚集索引中找到需要的数据，如果表中没有聚集索引，那么非聚集索引就是一个行定位符</p><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>唯一索引指的时不允许该索引键列有两行重复的值，聚集索引和非聚集索引都可以是唯一索引</p><h1 id="查询优化器如何使用索引"><a href="#查询优化器如何使用索引" class="headerlink" title="查询优化器如何使用索引"></a>查询优化器如何使用索引</h1><p>当执行查询时，查询优化器评估可用于检索数据的每个方法，然后选择最有效的方法，可能采用的方法包括扫描表和扫描一个或多个索引(如果有).</p><p>扫描表时，查询优化器读取表中的所有行，并提取满足查询条件的行，扫描表会有许多磁盘I/O操作，并占用大量资源</p><p>查询优化器使用索引时，搜索索引键列，查找到查询所需行的存储位置，然后从该位置提取匹配行，通常，搜索索引比搜索表要快很多，因为索引与表不同，一般每行包含的列非常少，且行遵循排序顺序</p><h1 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h1><h2 id="隐式创建索引"><a href="#隐式创建索引" class="headerlink" title="隐式创建索引"></a>隐式创建索引</h2><p>创建<code>PRIMARY KEY</code>约束后，会自动创建唯一聚集索引；创建<code>UNIQUE</code>约束后，会自动创建唯一非聚集索引<br>这里不做示例，需要查看示例返回看约束</p><h2 id="显示创建索引"><a href="#显示创建索引" class="headerlink" title="显示创建索引"></a>显示创建索引</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建唯一聚集索引</span></span><br><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> CLUSTERED <span class="keyword">INDEX</span> INDEX_ID  <span class="comment">--创建唯一聚集索引</span></span><br><span class="line"><span class="keyword">ON</span> dbo.STUDENT(<span class="keyword">ID</span> <span class="keyword">DESC</span>) <span class="comment">--指定STUDENT表的ID列</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一非聚集索引</span></span><br><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> NONCLUSTERED <span class="keyword">INDEX</span> INDEX_NAME</span><br><span class="line"><span class="keyword">ON</span> dbo.STUDENT(<span class="keyword">NAME</span> <span class="keyword">DESC</span>)</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h1 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> dbo.STUDENT.[INDEX_NAME]</span><br></pre></td></tr></table></figure><h1 id="查看SQL-Server的查询步骤"><a href="#查看SQL-Server的查询步骤" class="headerlink" title="查看SQL Server的查询步骤"></a>查看SQL Server的查询步骤</h1><p>查看SQL Server的查询步骤，已经是否选择了哪个索引，帮助用户分析哪些索引被系统引用</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SHOWPLAN_ALL <span class="keyword">ON</span> <span class="comment">--开启显示查询步骤</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.STUDENT <span class="keyword">WHERE</span> <span class="keyword">ID</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="在哪些字段创建索引"><a href="#在哪些字段创建索引" class="headerlink" title="在哪些字段创建索引"></a>在哪些字段创建索引</h1><ol><li>查询经常引用的列可创建聚集索引</li><li>频繁更新的列不应该创建聚集索引，可创建非聚集索引</li><li>用户<code>GROUP BY</code>和<code>ORDER BY</code>的列</li><li>若要创建组合聚集索引，应把最常用的字段放在组合键中靠前的位置</li><li>一个表中的索引最好不要超过5个，因为创建索引后，向表中写数据时，SQL Server既要向数据表中写数据，同时也要向创建的索引中写数据，索引越多需要写入越多，因此新建索引时要考虑这个因素</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e8%a7%a3%e6%9e%90&quot;&gt;解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e5%88%86%e7%b1%bb&quot;&gt;分类&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e8%81%9a%e9%9b%86%e7%b4%a2%e5
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习09--视图</title>
    <link href="http://www.dimsum.fun/2020/05/22/33.TSqlReview09/"/>
    <id>http://www.dimsum.fun/2020/05/22/33.TSqlReview09/</id>
    <published>2020-05-22T07:36:00.000Z</published>
    <updated>2020-05-22T11:00:01.085Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e8%a7%a3%e6%9e%90">解析</a></li><li><a href="#%e8%a7%86%e5%9b%be%e7%9a%84%e4%bd%9c%e7%94%a8">视图的作用</a></li><li><a href="#%e5%88%9b%e5%bb%ba%e8%a7%86%e5%9b%be">创建视图</a></li><li><a href="#%e4%bf%ae%e6%94%b9%e8%a7%86%e5%9b%be">修改视图</a></li><li><a href="#%e6%9b%b4%e6%96%b0%e8%a7%86%e5%9b%be%e6%95%b0%e6%8d%ae">更新视图数据</a></li><li><a href="#%e4%bd%bf%e7%94%a8%e7%b3%bb%e7%bb%9f%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e6%9f%a5%e7%9c%8b%e5%88%9b%e5%bb%ba%e8%a7%86%e5%9b%be%e8%84%9a%e6%9c%ac">使用系统存储过程查看创建视图脚本</a></li><li><a href="#%e5%8a%a0%e5%af%86%e8%a7%86%e5%9b%be">加密视图</a></li><li><a href="#%e5%88%a0%e9%99%a4%e8%a7%86%e5%9b%be">删除视图</a></li></ul><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>视图是一个虚拟表，其内容由查询定义，同表一样，视图包含一系列带有名称的列和行数据，行和列数据来自定义视图的查询所引用的表，并且在引用视图时动态生成</p><h1 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h1><ol><li>集中用户需要的数据</li><li>用作安全机制，数据库管理元只允许用户通过视图查询数据，而不授予用户直接访问视图基础表的权限</li><li>提高性能，存储复杂查询</li></ol><h1 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> V_BEST_SCORE</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.GRADE <span class="keyword">WHERE</span> SCORE&gt;<span class="number">90</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h1 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> dbo.V_BEST_SCORE</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.GRADE <span class="keyword">WHERE</span> SCORE&gt;<span class="number">95</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h1 id="更新视图数据"><a href="#更新视图数据" class="headerlink" title="更新视图数据"></a>更新视图数据</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">UPDATE</span> dbo.V_BEST_SCORE <span class="keyword">SET</span> SCORE=<span class="number">96</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><p><em>注：更新视图数据同时也会更新源表数据</em></p><h1 id="使用系统存储过程查看创建视图脚本"><a href="#使用系统存储过程查看创建视图脚本" class="headerlink" title="使用系统存储过程查看创建视图脚本"></a>使用系统存储过程查看创建视图脚本</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sys.sp_helptext 'V_BEST_SCORE'</span><br></pre></td></tr></table></figure><h1 id="加密视图"><a href="#加密视图" class="headerlink" title="加密视图"></a>加密视图</h1><p>使用<code>WITH ENCRYPTION</code>加密视图脚本，<code>WITH CHECK OPTION</code>强制更新视图的数据并且符合创建视图时的筛选条件<br>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> dbo.V_BEST_SCORE <span class="keyword">WITH</span> ENCRYPTION</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.GRADE <span class="keyword">WHERE</span> SCORE&gt;<span class="number">90</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span></span><br></pre></td></tr></table></figure><p>加密了视图之后，使用<code>sp_helptext</code>存储过程就无法查看视图脚本了</p><p>使用<code>WITH CHECK OPTION</code>表示如果更新视图数据，必须保证更新完数据还在视图里，即参照上面的示例，如果将<code>SCORE</code>更新成91，则可以更新成功，如果将<code>SCORE</code>更新成89，则无法更新成功</p><h1 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> dbo.V_BEST_SCORE</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e8%a7%a3%e6%9e%90&quot;&gt;解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e8%a7%86%e5%9b%be%e7%9a%84%e4%bd%9c%e7%94%a8&quot;&gt;视图的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习08--数据完整性(约束)</title>
    <link href="http://www.dimsum.fun/2020/05/22/32.TSqlReview08/"/>
    <id>http://www.dimsum.fun/2020/05/22/32.TSqlReview08/</id>
    <published>2020-05-22T03:17:00.000Z</published>
    <updated>2020-05-22T11:00:01.084Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e6%95%b0%e6%8d%ae%e5%ae%8c%e6%95%b4%e6%80%a7">数据完整性</a><ul><li><a href="#%e6%a6%82%e5%bf%b5">概念</a></li><li><a href="#%e7%b1%bb%e5%9e%8b">类型</a></li><li><a href="#%e7%ba%a6%e6%9d%9f">约束</a></li></ul></li><li><a href="#%e5%9f%9f%e5%ae%8c%e6%95%b4%e6%80%a7%e7%b1%bb%e5%9e%8b">域完整性类型</a><ul><li><a href="#default%e7%ba%a6%e6%9d%9f">DEFAULT约束</a><ul><li><a href="#%e4%b8%ba%e7%8e%b0%e6%9c%89%e8%a1%a8%e6%b7%bb%e5%8a%a0default%e7%ba%a6%e6%9d%9f">为现有表添加DEFAULT约束</a></li><li><a href="#%e5%88%9b%e5%bb%ba%e8%a1%a8%e6%97%b6%e6%b7%bb%e5%8a%a0default%e7%ba%a6%e6%9d%9f">创建表时添加DEFAULT约束</a></li></ul></li><li><a href="#check%e7%ba%a6%e6%9d%9f">CHECK约束</a><ul><li><a href="#%e5%88%9b%e5%bb%ba%e8%a1%a8%e6%97%b6%e6%b7%bb%e5%8a%a0check%e7%ba%a6%e6%9d%9f">创建表时添加CHECK约束</a></li><li><a href="#%e4%b8%ba%e7%8e%b0%e6%9c%89%e8%a1%a8%e6%b7%bb%e5%8a%a0check%e7%ba%a6%e6%9d%9f">为现有表添加CHECK约束</a></li><li><a href="#%e5%88%a0%e9%99%a4%e7%ba%a6%e6%9d%9f">删除约束</a></li></ul></li><li><a href="#null%e7%ba%a6%e6%9d%9f">NULL约束</a><ul><li><a href="#%e5%88%9b%e5%bb%ba%e8%a1%a8%e6%97%b6%e6%8c%87%e5%ae%9a%e6%98%af%e5%90%a6%e5%85%81%e8%ae%b8%e4%b8%banull">创建表时指定是否允许为NULL</a></li><li><a href="#%e4%bf%ae%e6%94%b9%e7%8e%b0%e6%9c%89%e8%a1%a8%e7%9a%84%e5%ad%97%e6%ae%b5%e6%98%af%e5%90%a6%e5%85%81%e8%ae%b8%e4%b8%banull">修改现有表的字段是否允许为NULL</a></li></ul></li></ul></li><li><a href="#%e5%ae%9e%e4%bd%93%e5%ae%8c%e6%95%b4%e6%80%a7%e7%b1%bb%e5%9e%8b">实体完整性类型</a><ul><li><a href="#primary-key%e7%ba%a6%e6%9d%9f">primary key约束</a><ul><li><a href="#%e5%88%9b%e5%bb%ba%e8%a1%a8%e6%97%b6%e6%8c%87%e5%ae%9a%e4%b8%bb%e9%94%ae">创建表时指定主键</a></li><li><a href="#%e7%bb%99%e7%8e%b0%e6%9c%89%e7%9a%84%e8%a1%a8%e6%b7%bb%e5%8a%a0%e4%b8%bb%e9%94%ae">给现有的表添加主键</a></li></ul></li><li><a href="#unique%e7%ba%a6%e6%9d%9f">UNIQUE约束</a><ul><li><a href="#%e5%88%9b%e5%bb%ba%e8%a1%a8%e6%97%b6%e5%90%8c%e6%97%b6%e5%88%9b%e5%bb%baunique%e7%ba%a6%e6%9d%9f">创建表时同时创建UNIQUE约束</a></li><li><a href="#%e7%bb%99%e7%8e%b0%e6%9c%89%e7%9a%84%e8%a1%a8%e6%b7%bb%e5%8a%a0unique%e7%ba%a6%e6%9d%9f">给现有的表添加UNIQUE约束</a></li></ul></li></ul></li><li><a href="#%e5%bc%95%e7%94%a8%e5%ae%8c%e6%95%b4%e6%80%a7%e7%b1%bb%e5%9e%8b">引用完整性类型</a><ul><li><a href="#foreign-key%e7%ba%a6%e6%9d%9f">FOREIGN KEY约束</a></li></ul></li><li><a href="#%e6%80%bb%e7%bb%93">总结</a></li></ul><h1 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数据完整性是指存储在数据库中数据的准确性和可靠性，它是应防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li>域完整性：域完整性指特定列的项的有效性</li><li>实体完整性：要求表中的所有行具有唯一的标识，例如主关键字值</li><li>引用完整性：确保量表之间的关系在更新和删除期间保持同步<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2>使用不同的约束强制数据完整性。约束时重要的数据库对象</li></ul><h1 id="域完整性类型"><a href="#域完整性类型" class="headerlink" title="域完整性类型"></a>域完整性类型</h1><h2 id="DEFAULT约束"><a href="#DEFAULT约束" class="headerlink" title="DEFAULT约束"></a>DEFAULT约束</h2><p>指定列的默认值</p><h3 id="为现有表添加DEFAULT约束"><a href="#为现有表添加DEFAULT约束" class="headerlink" title="为现有表添加DEFAULT约束"></a>为现有表添加DEFAULT约束</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> DEF_SEX  <span class="comment">--添加的约束名称</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="string">'男'</span>  <span class="comment">--约束类型及约束的值</span></span><br><span class="line"><span class="keyword">FOR</span> SEX  <span class="comment">--添加约束的列</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h3 id="创建表时添加DEFAULT约束"><a href="#创建表时添加DEFAULT约束" class="headerlink" title="创建表时添加DEFAULT约束"></a>创建表时添加DEFAULT约束</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP_DEFAULT</span><br><span class="line">(</span><br><span class="line"><span class="keyword">Id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">JOB <span class="keyword">NVARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">'.NET CORE DEV'</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><p><em>注：每一列只能有一个<code>DEFAULT</code>约束，不能用于<code>IDENTITY</code>属性的列，若默认值长度大于该字段允许的字符空间，则插入到该列的值会被截断</em></p><h2 id="CHECK约束"><a href="#CHECK约束" class="headerlink" title="CHECK约束"></a>CHECK约束</h2><p>限制列可接受的值，控制列值的范围，检车列值</p><p><code>CHECK</code>约束默认检查现有数据和所有新数据，使用<code>WITH NOCHECK</code>中检查新数据</p><h3 id="创建表时添加CHECK约束"><a href="#创建表时添加CHECK约束" class="headerlink" title="创建表时添加CHECK约束"></a>创建表时添加CHECK约束</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP_CHECK</span><br><span class="line">(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">JOB <span class="keyword">NVARCHAR</span>(<span class="number">100</span>) <span class="keyword">CHECK</span>(JOB=<span class="string">'JAVA'</span> <span class="keyword">OR</span> JOB=<span class="string">'C#'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h3 id="为现有表添加CHECK约束"><a href="#为现有表添加CHECK约束" class="headerlink" title="为现有表添加CHECK约束"></a>为现有表添加CHECK约束</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbo.STUDENT <span class="comment">--[WITH NOCHECK] 添加WITH NOCHECK则指检查新数据，不检查表里原有数据</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> CHECK_AGE  <span class="comment">--指定约束名称</span></span><br><span class="line"><span class="keyword">CHECK</span>(AGE&gt;=<span class="number">0</span> <span class="keyword">AND</span> AGE&lt;=<span class="number">150</span>) <span class="comment">--指定约束访范围</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> CHECK_AGE <span class="comment">--约束名称</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h2 id="NULL约束"><a href="#NULL约束" class="headerlink" title="NULL约束"></a>NULL约束</h2><p>指定列是否允许<code>NULL</code>，空值(或<code>NULL</code>)不同于<code>0</code>、空白或长度为0的字符串(如””)。NULL的意思是没有输入</p><h3 id="创建表时指定是否允许为NULL"><a href="#创建表时指定是否允许为NULL" class="headerlink" title="创建表时指定是否允许为NULL"></a>创建表时指定是否允许为NULL</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP_NULL</span><br><span class="line">(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">NAME</span> <span class="keyword">NVARCHAR</span>(<span class="number">100</span>) <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h3 id="修改现有表的字段是否允许为NULL"><a href="#修改现有表的字段是否允许为NULL" class="headerlink" title="修改现有表的字段是否允许为NULL"></a>修改现有表的字段是否允许为NULL</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="comment">--NOT NULL修改为NULL则标识允许为NULL</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h1 id="实体完整性类型"><a href="#实体完整性类型" class="headerlink" title="实体完整性类型"></a>实体完整性类型</h1><h2 id="primary-key约束"><a href="#primary-key约束" class="headerlink" title="primary key约束"></a>primary key约束</h2><p>能唯一标识表中每一行的值的一列或一组列，这样的一列或多列称为表的主键。一个表只能有一个<code>primary key</code>约束，并且<code>primary key</code>约束中的列不允许空值，不允许重复。如果对多列定义了<code>primary key</code>约束，则一列中的值可能会重复，但来自<code>primary key</code>约束定义中所有列的任何值组合必须唯一。</p><h3 id="创建表时指定主键"><a href="#创建表时指定主键" class="headerlink" title="创建表时指定主键"></a>创建表时指定主键</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP_PK</span><br><span class="line">(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">BIGINT</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">ID</span>),</span><br><span class="line"><span class="keyword">NAME</span> <span class="keyword">NVARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h3 id="给现有的表添加主键"><a href="#给现有的表添加主键" class="headerlink" title="给现有的表添加主键"></a>给现有的表添加主键</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> PK_ID <span class="comment">--约束名称</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">ID</span>) <span class="comment">--指定主键列</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h2 id="UNIQUE约束"><a href="#UNIQUE约束" class="headerlink" title="UNIQUE约束"></a>UNIQUE约束</h2><p>确保在非主键列中不输入重复的值，可以对一个表定义多个<code>UNIQUE</code>约束，但只能定义一个<code>PRIMARY KEY</code>约束，<code>UNIQUE</code>约束允许一个<code>NULL</code>值，而<code>PARMARY KEY</code>约束不允许有<code>NULL</code>值</p><p>创建<code>UNIQUE</code>约束时，同时会创建一个同名的非聚集索引，当插入或修改数据时，<code>UNIQUE</code>约束自动执行校验数据</p><h3 id="创建表时同时创建UNIQUE约束"><a href="#创建表时同时创建UNIQUE约束" class="headerlink" title="创建表时同时创建UNIQUE约束"></a>创建表时同时创建UNIQUE约束</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP_UNIUQE</span><br><span class="line">(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">NAME</span> <span class="keyword">NVARCHAR</span>(<span class="number">20</span>) <span class="keyword">CONSTRAINT</span> UNIQUE_NAME <span class="keyword">UNIQUE</span>(<span class="keyword">NAME</span>) <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h3 id="给现有的表添加UNIQUE约束"><a href="#给现有的表添加UNIQUE约束" class="headerlink" title="给现有的表添加UNIQUE约束"></a>给现有的表添加UNIQUE约束</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbo.STUDENT</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> UNIQUE_NAME</span><br><span class="line"><span class="keyword">UNIQUE</span>(<span class="keyword">NAME</span>)</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h1 id="引用完整性类型"><a href="#引用完整性类型" class="headerlink" title="引用完整性类型"></a>引用完整性类型</h1><h2 id="FOREIGN-KEY约束"><a href="#FOREIGN-KEY约束" class="headerlink" title="FOREIGN KEY约束"></a>FOREIGN KEY约束</h2><p>用于建立和加强两个表数据之间的链接，可以是一列或多列，称为表的外键(<code>FK</code>)，一个表可以有多个<code>FOREIGN KEY</code>约束，选作外键必须与其他对应的主键列具有相同的数据类型，每个键中列的数必须相等，即如果主键是一列，则外键是一列，如果主键是多列，则外键对应也是多列。<code>FOREIGN KEY</code>约束不仅可以与另一个表的<code>PRIMARY KEY</code>约束相关联，还可以定义为引用另一个表的<code>UNIQUE</code>约束列</p><p>主键要先创建好才能创建外键，<code>FOREIGN KEY</code>约束不能自动创建索引</p><p>外键约束的主要目的时控制可以存储在外键表中的数据，同时它也可以控制对主键表中数据的更改</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> SCHOOL</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dbo.GRADE</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_STUDENT_ID  <span class="comment">--外键约束名称</span></span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(STUDENTID)  <span class="comment">--指定当前表哪一列是外键</span></span><br><span class="line"><span class="keyword">REFERENCES</span> dbo.STUDENT(<span class="keyword">ID</span>) <span class="comment">--这个外键对应的是哪个表的主键</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>DEFAULT</code>、<code>CHECK</code>、<code>NULL</code>约束是针对表中的列进行完整性的控制，因此叫做域完整性</li><li><code>PRIMARY KEY</code>、<code>UNIQUE</code>约束是针对行限制数据行的唯一性，因此叫做实体完整性</li><li><code>FOREIGN KEY</code>约束是针对表与表之间的关系控制数据完整性，因此叫参照完整性</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%95%b0%e6%8d%ae%e5%ae%8c%e6%95%b4%e6%80%a7&quot;&gt;数据完整性&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%a6%82%e5%bf%b5&quot;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL复习07--表或字段添加描述信息</title>
    <link href="http://www.dimsum.fun/2020/05/21/31.TSqlReview07/"/>
    <id>http://www.dimsum.fun/2020/05/21/31.TSqlReview07/</id>
    <published>2020-05-21T10:15:00.000Z</published>
    <updated>2020-05-22T11:00:01.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加-更新-删除表级别的描述信息"><a href="#添加-更新-删除表级别的描述信息" class="headerlink" title="添加/更新/删除表级别的描述信息"></a>添加/更新/删除表级别的描述信息</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC sys.sp_addextendedproperty  <span class="comment">--添加表描述信息</span></span><br><span class="line">     <span class="comment">-- sys.sp_updateextendedproperty  更新表属性信息</span></span><br><span class="line">     <span class="comment">-- sp_dropextendedproperty  删除表属性信息   </span></span><br><span class="line">    @name = N'Student',       <span class="comment">-- 描述的名称，可以设定为表名</span></span><br><span class="line">    @value = N'学生表',      <span class="comment">-- 描述内容</span></span><br><span class="line">    @level0type = N'SCHEMA',   <span class="comment">-- 固定语法</span></span><br><span class="line">    @level0name = N'dbo', <span class="comment">-- 架构</span></span><br><span class="line">    @level1type = N'TABLE',   <span class="comment">-- 类型</span></span><br><span class="line">    @level1name = N'STUDENT' <span class="comment">-- 要添加描述的表名</span></span><br></pre></td></tr></table></figure><h1 id="添加-更新-删除字段描述信息"><a href="#添加-更新-删除字段描述信息" class="headerlink" title="添加/更新/删除字段描述信息"></a>添加/更新/删除字段描述信息</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXEC sys.sp_addextendedproperty  <span class="comment">--添加字段描述信息</span></span><br><span class="line">     <span class="comment">-- sys.sp_updateextendedproperty  更新字段属性信息</span></span><br><span class="line">     <span class="comment">-- sp_dropextendedproperty  删除字段属性信息   </span></span><br><span class="line">    @name = N'ID',       <span class="comment">-- 描述的名称，可以设定为字段名称</span></span><br><span class="line">    @value = N'学生编号',      <span class="comment">-- 描述内容</span></span><br><span class="line">    @level0type = N'SCHEMA',   <span class="comment">-- 固定语法</span></span><br><span class="line">    @level0name = N'dbo', <span class="comment">-- 架构</span></span><br><span class="line">    @level1type = N'TABLE',   <span class="comment">-- 类型</span></span><br><span class="line">    @level1name = N'STUDENT', <span class="comment">-- 表名</span></span><br><span class="line">    @level2type = N'COLUMN',   <span class="comment">-- 列</span></span><br><span class="line">    @level2name = N'ID'  <span class="comment">-- 要添加描述的字段名</span></span><br></pre></td></tr></table></figure><h1 id="查询表中的描述信息"><a href="#查询表中的描述信息" class="headerlink" title="查询表中的描述信息"></a>查询表中的描述信息</h1><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sys.extended_properties a <span class="keyword">WHERE</span> a.major_id=OBJECT_ID(<span class="string">'[dbo].[STUDENT]'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;添加-更新-删除表级别的描述信息&quot;&gt;&lt;a href=&quot;#添加-更新-删除表级别的描述信息&quot; class=&quot;headerlink&quot; title=&quot;添加/更新/删除表级别的描述信息&quot;&gt;&lt;/a&gt;添加/更新/删除表级别的描述信息&lt;/h1&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/categories/SQL-Server/"/>
    
    
      <category term="T-SQL" scheme="http://www.dimsum.fun/tags/T-SQL/"/>
    
      <category term="SQL Server" scheme="http://www.dimsum.fun/tags/SQL-Server/"/>
    
  </entry>
  
</feed>
